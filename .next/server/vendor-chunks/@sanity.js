/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@sanity";
exports.ids = ["vendor-chunks/@sanity"];
exports.modules = {

/***/ "(ssr)/./node_modules/@sanity/image-url/lib/node/builder.js":
/*!************************************************************!*\
  !*** ./node_modules/@sanity/image-url/lib/node/builder.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ImageUrlBuilder = void 0;\nvar urlForImage_1 = __importStar(__webpack_require__(/*! ./urlForImage */ \"(ssr)/./node_modules/@sanity/image-url/lib/node/urlForImage.js\"));\nvar validFits = ['clip', 'crop', 'fill', 'fillmax', 'max', 'scale', 'min'];\nvar validCrops = ['top', 'bottom', 'left', 'right', 'center', 'focalpoint', 'entropy'];\nvar validAutoModes = ['format'];\nfunction isSanityModernClientLike(client) {\n    return client && 'config' in client ? typeof client.config === 'function' : false;\n}\nfunction isSanityClientLike(client) {\n    return client && 'clientConfig' in client ? typeof client.clientConfig === 'object' : false;\n}\nfunction rewriteSpecName(key) {\n    var specs = urlForImage_1.SPEC_NAME_TO_URL_NAME_MAPPINGS;\n    for (var _i = 0, specs_1 = specs; _i < specs_1.length; _i++) {\n        var entry = specs_1[_i];\n        var specName = entry[0], param = entry[1];\n        if (key === specName || key === param) {\n            return specName;\n        }\n    }\n    return key;\n}\nfunction urlBuilder(options) {\n    // Did we get a modernish client?\n    if (isSanityModernClientLike(options)) {\n        // Inherit config from client\n        var _a = options.config(), apiUrl = _a.apiHost, projectId = _a.projectId, dataset = _a.dataset;\n        var apiHost = apiUrl || 'https://api.sanity.io';\n        return new ImageUrlBuilder(null, {\n            baseUrl: apiHost.replace(/^https:\\/\\/api\\./, 'https://cdn.'),\n            projectId: projectId,\n            dataset: dataset,\n        });\n    }\n    // Did we get a SanityClient?\n    if (isSanityClientLike(options)) {\n        // Inherit config from client\n        var _b = options.clientConfig, apiUrl = _b.apiHost, projectId = _b.projectId, dataset = _b.dataset;\n        var apiHost = apiUrl || 'https://api.sanity.io';\n        return new ImageUrlBuilder(null, {\n            baseUrl: apiHost.replace(/^https:\\/\\/api\\./, 'https://cdn.'),\n            projectId: projectId,\n            dataset: dataset,\n        });\n    }\n    // Or just accept the options as given\n    return new ImageUrlBuilder(null, options || {});\n}\nexports[\"default\"] = urlBuilder;\nvar ImageUrlBuilder = /** @class */ (function () {\n    function ImageUrlBuilder(parent, options) {\n        this.options = parent\n            ? __assign(__assign({}, (parent.options || {})), (options || {})) : __assign({}, (options || {})); // Copy options\n    }\n    ImageUrlBuilder.prototype.withOptions = function (options) {\n        var baseUrl = options.baseUrl || this.options.baseUrl;\n        var newOptions = { baseUrl: baseUrl };\n        for (var key in options) {\n            if (options.hasOwnProperty(key)) {\n                var specKey = rewriteSpecName(key);\n                newOptions[specKey] = options[key];\n            }\n        }\n        return new ImageUrlBuilder(this, __assign({ baseUrl: baseUrl }, newOptions));\n    };\n    // The image to be represented. Accepts a Sanity 'image'-document, 'asset'-document or\n    // _id of asset. To get the benefit of automatic hot-spot/crop integration with the content\n    // studio, the 'image'-document must be provided.\n    ImageUrlBuilder.prototype.image = function (source) {\n        return this.withOptions({ source: source });\n    };\n    // Specify the dataset\n    ImageUrlBuilder.prototype.dataset = function (dataset) {\n        return this.withOptions({ dataset: dataset });\n    };\n    // Specify the projectId\n    ImageUrlBuilder.prototype.projectId = function (projectId) {\n        return this.withOptions({ projectId: projectId });\n    };\n    // Specify background color\n    ImageUrlBuilder.prototype.bg = function (bg) {\n        return this.withOptions({ bg: bg });\n    };\n    // Set DPR scaling factor\n    ImageUrlBuilder.prototype.dpr = function (dpr) {\n        // A DPR of 1 is the default - so only include it if we have a different value\n        return this.withOptions(dpr && dpr !== 1 ? { dpr: dpr } : {});\n    };\n    // Specify the width of the image in pixels\n    ImageUrlBuilder.prototype.width = function (width) {\n        return this.withOptions({ width: width });\n    };\n    // Specify the height of the image in pixels\n    ImageUrlBuilder.prototype.height = function (height) {\n        return this.withOptions({ height: height });\n    };\n    // Specify focal point in fraction of image dimensions. Each component 0.0-1.0\n    ImageUrlBuilder.prototype.focalPoint = function (x, y) {\n        return this.withOptions({ focalPoint: { x: x, y: y } });\n    };\n    ImageUrlBuilder.prototype.maxWidth = function (maxWidth) {\n        return this.withOptions({ maxWidth: maxWidth });\n    };\n    ImageUrlBuilder.prototype.minWidth = function (minWidth) {\n        return this.withOptions({ minWidth: minWidth });\n    };\n    ImageUrlBuilder.prototype.maxHeight = function (maxHeight) {\n        return this.withOptions({ maxHeight: maxHeight });\n    };\n    ImageUrlBuilder.prototype.minHeight = function (minHeight) {\n        return this.withOptions({ minHeight: minHeight });\n    };\n    // Specify width and height in pixels\n    ImageUrlBuilder.prototype.size = function (width, height) {\n        return this.withOptions({ width: width, height: height });\n    };\n    // Specify blur between 0 and 100\n    ImageUrlBuilder.prototype.blur = function (blur) {\n        return this.withOptions({ blur: blur });\n    };\n    ImageUrlBuilder.prototype.sharpen = function (sharpen) {\n        return this.withOptions({ sharpen: sharpen });\n    };\n    // Specify the desired rectangle of the image\n    ImageUrlBuilder.prototype.rect = function (left, top, width, height) {\n        return this.withOptions({ rect: { left: left, top: top, width: width, height: height } });\n    };\n    // Specify the image format of the image. 'jpg', 'pjpg', 'png', 'webp'\n    ImageUrlBuilder.prototype.format = function (format) {\n        return this.withOptions({ format: format });\n    };\n    ImageUrlBuilder.prototype.invert = function (invert) {\n        return this.withOptions({ invert: invert });\n    };\n    // Rotation in degrees 0, 90, 180, 270\n    ImageUrlBuilder.prototype.orientation = function (orientation) {\n        return this.withOptions({ orientation: orientation });\n    };\n    // Compression quality 0-100\n    ImageUrlBuilder.prototype.quality = function (quality) {\n        return this.withOptions({ quality: quality });\n    };\n    // Make it a download link. Parameter is default filename.\n    ImageUrlBuilder.prototype.forceDownload = function (download) {\n        return this.withOptions({ download: download });\n    };\n    // Flip image horizontally\n    ImageUrlBuilder.prototype.flipHorizontal = function () {\n        return this.withOptions({ flipHorizontal: true });\n    };\n    // Flip image vertically\n    ImageUrlBuilder.prototype.flipVertical = function () {\n        return this.withOptions({ flipVertical: true });\n    };\n    // Ignore crop/hotspot from image record, even when present\n    ImageUrlBuilder.prototype.ignoreImageParams = function () {\n        return this.withOptions({ ignoreImageParams: true });\n    };\n    ImageUrlBuilder.prototype.fit = function (value) {\n        if (validFits.indexOf(value) === -1) {\n            throw new Error(\"Invalid fit mode \\\"\".concat(value, \"\\\"\"));\n        }\n        return this.withOptions({ fit: value });\n    };\n    ImageUrlBuilder.prototype.crop = function (value) {\n        if (validCrops.indexOf(value) === -1) {\n            throw new Error(\"Invalid crop mode \\\"\".concat(value, \"\\\"\"));\n        }\n        return this.withOptions({ crop: value });\n    };\n    // Saturation\n    ImageUrlBuilder.prototype.saturation = function (saturation) {\n        return this.withOptions({ saturation: saturation });\n    };\n    ImageUrlBuilder.prototype.auto = function (value) {\n        if (validAutoModes.indexOf(value) === -1) {\n            throw new Error(\"Invalid auto mode \\\"\".concat(value, \"\\\"\"));\n        }\n        return this.withOptions({ auto: value });\n    };\n    // Specify the number of pixels to pad the image\n    ImageUrlBuilder.prototype.pad = function (pad) {\n        return this.withOptions({ pad: pad });\n    };\n    // Vanity URL for more SEO friendly URLs\n    ImageUrlBuilder.prototype.vanityName = function (value) {\n        return this.withOptions({ vanityName: value });\n    };\n    ImageUrlBuilder.prototype.frame = function (frame) {\n        if (frame !== 1) {\n            throw new Error(\"Invalid frame value \\\"\".concat(frame, \"\\\"\"));\n        }\n        return this.withOptions({ frame: frame });\n    };\n    // Gets the url based on the submitted parameters\n    ImageUrlBuilder.prototype.url = function () {\n        return (0, urlForImage_1.default)(this.options);\n    };\n    // Alias for url()\n    ImageUrlBuilder.prototype.toString = function () {\n        return this.url();\n    };\n    return ImageUrlBuilder;\n}());\nexports.ImageUrlBuilder = ImageUrlBuilder;\n//# sourceMappingURL=builder.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNhbml0eS9pbWFnZS11cmwvbGliL25vZGUvYnVpbGRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQSxpREFBaUQsT0FBTztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxvQ0FBb0MsZ0JBQWdCO0FBQ3ZGLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsMENBQTBDLDRCQUE0QjtBQUN0RSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsdUJBQXVCO0FBQ3ZCLGlDQUFpQyxtQkFBTyxDQUFDLHFGQUFlO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MscUJBQXFCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0Esa0JBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsdUJBQXVCLGtCQUFrQixnQkFBZ0IsZ0JBQWdCLElBQUk7QUFDL0c7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxrQkFBa0I7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxnQkFBZ0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGtCQUFrQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0Msc0JBQXNCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxRQUFRO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELFdBQVcsSUFBSTtBQUNwRTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsY0FBYztBQUNoRDtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsZ0JBQWdCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxjQUFjLGNBQWM7QUFDOUQ7QUFDQTtBQUNBLGtDQUFrQyxvQkFBb0I7QUFDdEQ7QUFDQTtBQUNBLGtDQUFrQyxvQkFBb0I7QUFDdEQ7QUFDQTtBQUNBLGtDQUFrQyxzQkFBc0I7QUFDeEQ7QUFDQTtBQUNBLGtDQUFrQyxzQkFBc0I7QUFDeEQ7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLDhCQUE4QjtBQUNoRTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsWUFBWTtBQUM5QztBQUNBO0FBQ0Esa0NBQWtDLGtCQUFrQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsUUFBUSxzREFBc0Q7QUFDaEc7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGdCQUFnQjtBQUNsRDtBQUNBO0FBQ0Esa0NBQWtDLGdCQUFnQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsMEJBQTBCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxrQkFBa0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLG9CQUFvQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0Msc0JBQXNCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxvQkFBb0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHlCQUF5QjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFlBQVk7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxhQUFhO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyx3QkFBd0I7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxhQUFhO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxVQUFVO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxtQkFBbUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxjQUFjO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELHVCQUF1QjtBQUN2QiIsInNvdXJjZXMiOlsiRzpcXE15IENhcmVlclxcV0VCIEFORCBNT0JJTEUgQVBQIERFVkVMT1BFTUVOVCAgKEhUTUwsQ1NTLCBKUyApXFxGcm9udC1FbmQgRGV2ZWxvcGVtZW50XFxGaW5hbCBQcm9qZWN0XFxGcm9udGVuZFxcbm9kZV9tb2R1bGVzXFxAc2FuaXR5XFxpbWFnZS11cmxcXGxpYlxcbm9kZVxcYnVpbGRlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSW1hZ2VVcmxCdWlsZGVyID0gdm9pZCAwO1xudmFyIHVybEZvckltYWdlXzEgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vdXJsRm9ySW1hZ2VcIikpO1xudmFyIHZhbGlkRml0cyA9IFsnY2xpcCcsICdjcm9wJywgJ2ZpbGwnLCAnZmlsbG1heCcsICdtYXgnLCAnc2NhbGUnLCAnbWluJ107XG52YXIgdmFsaWRDcm9wcyA9IFsndG9wJywgJ2JvdHRvbScsICdsZWZ0JywgJ3JpZ2h0JywgJ2NlbnRlcicsICdmb2NhbHBvaW50JywgJ2VudHJvcHknXTtcbnZhciB2YWxpZEF1dG9Nb2RlcyA9IFsnZm9ybWF0J107XG5mdW5jdGlvbiBpc1Nhbml0eU1vZGVybkNsaWVudExpa2UoY2xpZW50KSB7XG4gICAgcmV0dXJuIGNsaWVudCAmJiAnY29uZmlnJyBpbiBjbGllbnQgPyB0eXBlb2YgY2xpZW50LmNvbmZpZyA9PT0gJ2Z1bmN0aW9uJyA6IGZhbHNlO1xufVxuZnVuY3Rpb24gaXNTYW5pdHlDbGllbnRMaWtlKGNsaWVudCkge1xuICAgIHJldHVybiBjbGllbnQgJiYgJ2NsaWVudENvbmZpZycgaW4gY2xpZW50ID8gdHlwZW9mIGNsaWVudC5jbGllbnRDb25maWcgPT09ICdvYmplY3QnIDogZmFsc2U7XG59XG5mdW5jdGlvbiByZXdyaXRlU3BlY05hbWUoa2V5KSB7XG4gICAgdmFyIHNwZWNzID0gdXJsRm9ySW1hZ2VfMS5TUEVDX05BTUVfVE9fVVJMX05BTUVfTUFQUElOR1M7XG4gICAgZm9yICh2YXIgX2kgPSAwLCBzcGVjc18xID0gc3BlY3M7IF9pIDwgc3BlY3NfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gc3BlY3NfMVtfaV07XG4gICAgICAgIHZhciBzcGVjTmFtZSA9IGVudHJ5WzBdLCBwYXJhbSA9IGVudHJ5WzFdO1xuICAgICAgICBpZiAoa2V5ID09PSBzcGVjTmFtZSB8fCBrZXkgPT09IHBhcmFtKSB7XG4gICAgICAgICAgICByZXR1cm4gc3BlY05hbWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGtleTtcbn1cbmZ1bmN0aW9uIHVybEJ1aWxkZXIob3B0aW9ucykge1xuICAgIC8vIERpZCB3ZSBnZXQgYSBtb2Rlcm5pc2ggY2xpZW50P1xuICAgIGlmIChpc1Nhbml0eU1vZGVybkNsaWVudExpa2Uob3B0aW9ucykpIHtcbiAgICAgICAgLy8gSW5oZXJpdCBjb25maWcgZnJvbSBjbGllbnRcbiAgICAgICAgdmFyIF9hID0gb3B0aW9ucy5jb25maWcoKSwgYXBpVXJsID0gX2EuYXBpSG9zdCwgcHJvamVjdElkID0gX2EucHJvamVjdElkLCBkYXRhc2V0ID0gX2EuZGF0YXNldDtcbiAgICAgICAgdmFyIGFwaUhvc3QgPSBhcGlVcmwgfHwgJ2h0dHBzOi8vYXBpLnNhbml0eS5pbyc7XG4gICAgICAgIHJldHVybiBuZXcgSW1hZ2VVcmxCdWlsZGVyKG51bGwsIHtcbiAgICAgICAgICAgIGJhc2VVcmw6IGFwaUhvc3QucmVwbGFjZSgvXmh0dHBzOlxcL1xcL2FwaVxcLi8sICdodHRwczovL2Nkbi4nKSxcbiAgICAgICAgICAgIHByb2plY3RJZDogcHJvamVjdElkLFxuICAgICAgICAgICAgZGF0YXNldDogZGF0YXNldCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIERpZCB3ZSBnZXQgYSBTYW5pdHlDbGllbnQ/XG4gICAgaWYgKGlzU2FuaXR5Q2xpZW50TGlrZShvcHRpb25zKSkge1xuICAgICAgICAvLyBJbmhlcml0IGNvbmZpZyBmcm9tIGNsaWVudFxuICAgICAgICB2YXIgX2IgPSBvcHRpb25zLmNsaWVudENvbmZpZywgYXBpVXJsID0gX2IuYXBpSG9zdCwgcHJvamVjdElkID0gX2IucHJvamVjdElkLCBkYXRhc2V0ID0gX2IuZGF0YXNldDtcbiAgICAgICAgdmFyIGFwaUhvc3QgPSBhcGlVcmwgfHwgJ2h0dHBzOi8vYXBpLnNhbml0eS5pbyc7XG4gICAgICAgIHJldHVybiBuZXcgSW1hZ2VVcmxCdWlsZGVyKG51bGwsIHtcbiAgICAgICAgICAgIGJhc2VVcmw6IGFwaUhvc3QucmVwbGFjZSgvXmh0dHBzOlxcL1xcL2FwaVxcLi8sICdodHRwczovL2Nkbi4nKSxcbiAgICAgICAgICAgIHByb2plY3RJZDogcHJvamVjdElkLFxuICAgICAgICAgICAgZGF0YXNldDogZGF0YXNldCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIE9yIGp1c3QgYWNjZXB0IHRoZSBvcHRpb25zIGFzIGdpdmVuXG4gICAgcmV0dXJuIG5ldyBJbWFnZVVybEJ1aWxkZXIobnVsbCwgb3B0aW9ucyB8fCB7fSk7XG59XG5leHBvcnRzLmRlZmF1bHQgPSB1cmxCdWlsZGVyO1xudmFyIEltYWdlVXJsQnVpbGRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBJbWFnZVVybEJ1aWxkZXIocGFyZW50LCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IHBhcmVudFxuICAgICAgICAgICAgPyBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgKHBhcmVudC5vcHRpb25zIHx8IHt9KSksIChvcHRpb25zIHx8IHt9KSkgOiBfX2Fzc2lnbih7fSwgKG9wdGlvbnMgfHwge30pKTsgLy8gQ29weSBvcHRpb25zXG4gICAgfVxuICAgIEltYWdlVXJsQnVpbGRlci5wcm90b3R5cGUud2l0aE9wdGlvbnMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB2YXIgYmFzZVVybCA9IG9wdGlvbnMuYmFzZVVybCB8fCB0aGlzLm9wdGlvbnMuYmFzZVVybDtcbiAgICAgICAgdmFyIG5ld09wdGlvbnMgPSB7IGJhc2VVcmw6IGJhc2VVcmwgfTtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3BlY0tleSA9IHJld3JpdGVTcGVjTmFtZShrZXkpO1xuICAgICAgICAgICAgICAgIG5ld09wdGlvbnNbc3BlY0tleV0gPSBvcHRpb25zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBJbWFnZVVybEJ1aWxkZXIodGhpcywgX19hc3NpZ24oeyBiYXNlVXJsOiBiYXNlVXJsIH0sIG5ld09wdGlvbnMpKTtcbiAgICB9O1xuICAgIC8vIFRoZSBpbWFnZSB0byBiZSByZXByZXNlbnRlZC4gQWNjZXB0cyBhIFNhbml0eSAnaW1hZ2UnLWRvY3VtZW50LCAnYXNzZXQnLWRvY3VtZW50IG9yXG4gICAgLy8gX2lkIG9mIGFzc2V0LiBUbyBnZXQgdGhlIGJlbmVmaXQgb2YgYXV0b21hdGljIGhvdC1zcG90L2Nyb3AgaW50ZWdyYXRpb24gd2l0aCB0aGUgY29udGVudFxuICAgIC8vIHN0dWRpbywgdGhlICdpbWFnZSctZG9jdW1lbnQgbXVzdCBiZSBwcm92aWRlZC5cbiAgICBJbWFnZVVybEJ1aWxkZXIucHJvdG90eXBlLmltYWdlID0gZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gdGhpcy53aXRoT3B0aW9ucyh7IHNvdXJjZTogc291cmNlIH0pO1xuICAgIH07XG4gICAgLy8gU3BlY2lmeSB0aGUgZGF0YXNldFxuICAgIEltYWdlVXJsQnVpbGRlci5wcm90b3R5cGUuZGF0YXNldCA9IGZ1bmN0aW9uIChkYXRhc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpdGhPcHRpb25zKHsgZGF0YXNldDogZGF0YXNldCB9KTtcbiAgICB9O1xuICAgIC8vIFNwZWNpZnkgdGhlIHByb2plY3RJZFxuICAgIEltYWdlVXJsQnVpbGRlci5wcm90b3R5cGUucHJvamVjdElkID0gZnVuY3Rpb24gKHByb2plY3RJZCkge1xuICAgICAgICByZXR1cm4gdGhpcy53aXRoT3B0aW9ucyh7IHByb2plY3RJZDogcHJvamVjdElkIH0pO1xuICAgIH07XG4gICAgLy8gU3BlY2lmeSBiYWNrZ3JvdW5kIGNvbG9yXG4gICAgSW1hZ2VVcmxCdWlsZGVyLnByb3RvdHlwZS5iZyA9IGZ1bmN0aW9uIChiZykge1xuICAgICAgICByZXR1cm4gdGhpcy53aXRoT3B0aW9ucyh7IGJnOiBiZyB9KTtcbiAgICB9O1xuICAgIC8vIFNldCBEUFIgc2NhbGluZyBmYWN0b3JcbiAgICBJbWFnZVVybEJ1aWxkZXIucHJvdG90eXBlLmRwciA9IGZ1bmN0aW9uIChkcHIpIHtcbiAgICAgICAgLy8gQSBEUFIgb2YgMSBpcyB0aGUgZGVmYXVsdCAtIHNvIG9ubHkgaW5jbHVkZSBpdCBpZiB3ZSBoYXZlIGEgZGlmZmVyZW50IHZhbHVlXG4gICAgICAgIHJldHVybiB0aGlzLndpdGhPcHRpb25zKGRwciAmJiBkcHIgIT09IDEgPyB7IGRwcjogZHByIH0gOiB7fSk7XG4gICAgfTtcbiAgICAvLyBTcGVjaWZ5IHRoZSB3aWR0aCBvZiB0aGUgaW1hZ2UgaW4gcGl4ZWxzXG4gICAgSW1hZ2VVcmxCdWlsZGVyLnByb3RvdHlwZS53aWR0aCA9IGZ1bmN0aW9uICh3aWR0aCkge1xuICAgICAgICByZXR1cm4gdGhpcy53aXRoT3B0aW9ucyh7IHdpZHRoOiB3aWR0aCB9KTtcbiAgICB9O1xuICAgIC8vIFNwZWNpZnkgdGhlIGhlaWdodCBvZiB0aGUgaW1hZ2UgaW4gcGl4ZWxzXG4gICAgSW1hZ2VVcmxCdWlsZGVyLnByb3RvdHlwZS5oZWlnaHQgPSBmdW5jdGlvbiAoaGVpZ2h0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpdGhPcHRpb25zKHsgaGVpZ2h0OiBoZWlnaHQgfSk7XG4gICAgfTtcbiAgICAvLyBTcGVjaWZ5IGZvY2FsIHBvaW50IGluIGZyYWN0aW9uIG9mIGltYWdlIGRpbWVuc2lvbnMuIEVhY2ggY29tcG9uZW50IDAuMC0xLjBcbiAgICBJbWFnZVVybEJ1aWxkZXIucHJvdG90eXBlLmZvY2FsUG9pbnQgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICByZXR1cm4gdGhpcy53aXRoT3B0aW9ucyh7IGZvY2FsUG9pbnQ6IHsgeDogeCwgeTogeSB9IH0pO1xuICAgIH07XG4gICAgSW1hZ2VVcmxCdWlsZGVyLnByb3RvdHlwZS5tYXhXaWR0aCA9IGZ1bmN0aW9uIChtYXhXaWR0aCkge1xuICAgICAgICByZXR1cm4gdGhpcy53aXRoT3B0aW9ucyh7IG1heFdpZHRoOiBtYXhXaWR0aCB9KTtcbiAgICB9O1xuICAgIEltYWdlVXJsQnVpbGRlci5wcm90b3R5cGUubWluV2lkdGggPSBmdW5jdGlvbiAobWluV2lkdGgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2l0aE9wdGlvbnMoeyBtaW5XaWR0aDogbWluV2lkdGggfSk7XG4gICAgfTtcbiAgICBJbWFnZVVybEJ1aWxkZXIucHJvdG90eXBlLm1heEhlaWdodCA9IGZ1bmN0aW9uIChtYXhIZWlnaHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2l0aE9wdGlvbnMoeyBtYXhIZWlnaHQ6IG1heEhlaWdodCB9KTtcbiAgICB9O1xuICAgIEltYWdlVXJsQnVpbGRlci5wcm90b3R5cGUubWluSGVpZ2h0ID0gZnVuY3Rpb24gKG1pbkhlaWdodCkge1xuICAgICAgICByZXR1cm4gdGhpcy53aXRoT3B0aW9ucyh7IG1pbkhlaWdodDogbWluSGVpZ2h0IH0pO1xuICAgIH07XG4gICAgLy8gU3BlY2lmeSB3aWR0aCBhbmQgaGVpZ2h0IGluIHBpeGVsc1xuICAgIEltYWdlVXJsQnVpbGRlci5wcm90b3R5cGUuc2l6ZSA9IGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpdGhPcHRpb25zKHsgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCB9KTtcbiAgICB9O1xuICAgIC8vIFNwZWNpZnkgYmx1ciBiZXR3ZWVuIDAgYW5kIDEwMFxuICAgIEltYWdlVXJsQnVpbGRlci5wcm90b3R5cGUuYmx1ciA9IGZ1bmN0aW9uIChibHVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpdGhPcHRpb25zKHsgYmx1cjogYmx1ciB9KTtcbiAgICB9O1xuICAgIEltYWdlVXJsQnVpbGRlci5wcm90b3R5cGUuc2hhcnBlbiA9IGZ1bmN0aW9uIChzaGFycGVuKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpdGhPcHRpb25zKHsgc2hhcnBlbjogc2hhcnBlbiB9KTtcbiAgICB9O1xuICAgIC8vIFNwZWNpZnkgdGhlIGRlc2lyZWQgcmVjdGFuZ2xlIG9mIHRoZSBpbWFnZVxuICAgIEltYWdlVXJsQnVpbGRlci5wcm90b3R5cGUucmVjdCA9IGZ1bmN0aW9uIChsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2l0aE9wdGlvbnMoeyByZWN0OiB7IGxlZnQ6IGxlZnQsIHRvcDogdG9wLCB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0IH0gfSk7XG4gICAgfTtcbiAgICAvLyBTcGVjaWZ5IHRoZSBpbWFnZSBmb3JtYXQgb2YgdGhlIGltYWdlLiAnanBnJywgJ3BqcGcnLCAncG5nJywgJ3dlYnAnXG4gICAgSW1hZ2VVcmxCdWlsZGVyLnByb3RvdHlwZS5mb3JtYXQgPSBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpdGhPcHRpb25zKHsgZm9ybWF0OiBmb3JtYXQgfSk7XG4gICAgfTtcbiAgICBJbWFnZVVybEJ1aWxkZXIucHJvdG90eXBlLmludmVydCA9IGZ1bmN0aW9uIChpbnZlcnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2l0aE9wdGlvbnMoeyBpbnZlcnQ6IGludmVydCB9KTtcbiAgICB9O1xuICAgIC8vIFJvdGF0aW9uIGluIGRlZ3JlZXMgMCwgOTAsIDE4MCwgMjcwXG4gICAgSW1hZ2VVcmxCdWlsZGVyLnByb3RvdHlwZS5vcmllbnRhdGlvbiA9IGZ1bmN0aW9uIChvcmllbnRhdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy53aXRoT3B0aW9ucyh7IG9yaWVudGF0aW9uOiBvcmllbnRhdGlvbiB9KTtcbiAgICB9O1xuICAgIC8vIENvbXByZXNzaW9uIHF1YWxpdHkgMC0xMDBcbiAgICBJbWFnZVVybEJ1aWxkZXIucHJvdG90eXBlLnF1YWxpdHkgPSBmdW5jdGlvbiAocXVhbGl0eSkge1xuICAgICAgICByZXR1cm4gdGhpcy53aXRoT3B0aW9ucyh7IHF1YWxpdHk6IHF1YWxpdHkgfSk7XG4gICAgfTtcbiAgICAvLyBNYWtlIGl0IGEgZG93bmxvYWQgbGluay4gUGFyYW1ldGVyIGlzIGRlZmF1bHQgZmlsZW5hbWUuXG4gICAgSW1hZ2VVcmxCdWlsZGVyLnByb3RvdHlwZS5mb3JjZURvd25sb2FkID0gZnVuY3Rpb24gKGRvd25sb2FkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpdGhPcHRpb25zKHsgZG93bmxvYWQ6IGRvd25sb2FkIH0pO1xuICAgIH07XG4gICAgLy8gRmxpcCBpbWFnZSBob3Jpem9udGFsbHlcbiAgICBJbWFnZVVybEJ1aWxkZXIucHJvdG90eXBlLmZsaXBIb3Jpem9udGFsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy53aXRoT3B0aW9ucyh7IGZsaXBIb3Jpem9udGFsOiB0cnVlIH0pO1xuICAgIH07XG4gICAgLy8gRmxpcCBpbWFnZSB2ZXJ0aWNhbGx5XG4gICAgSW1hZ2VVcmxCdWlsZGVyLnByb3RvdHlwZS5mbGlwVmVydGljYWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpdGhPcHRpb25zKHsgZmxpcFZlcnRpY2FsOiB0cnVlIH0pO1xuICAgIH07XG4gICAgLy8gSWdub3JlIGNyb3AvaG90c3BvdCBmcm9tIGltYWdlIHJlY29yZCwgZXZlbiB3aGVuIHByZXNlbnRcbiAgICBJbWFnZVVybEJ1aWxkZXIucHJvdG90eXBlLmlnbm9yZUltYWdlUGFyYW1zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy53aXRoT3B0aW9ucyh7IGlnbm9yZUltYWdlUGFyYW1zOiB0cnVlIH0pO1xuICAgIH07XG4gICAgSW1hZ2VVcmxCdWlsZGVyLnByb3RvdHlwZS5maXQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbGlkRml0cy5pbmRleE9mKHZhbHVlKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZml0IG1vZGUgXFxcIlwiLmNvbmNhdCh2YWx1ZSwgXCJcXFwiXCIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy53aXRoT3B0aW9ucyh7IGZpdDogdmFsdWUgfSk7XG4gICAgfTtcbiAgICBJbWFnZVVybEJ1aWxkZXIucHJvdG90eXBlLmNyb3AgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbGlkQ3JvcHMuaW5kZXhPZih2YWx1ZSkgPT09IC0xKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGNyb3AgbW9kZSBcXFwiXCIuY29uY2F0KHZhbHVlLCBcIlxcXCJcIikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLndpdGhPcHRpb25zKHsgY3JvcDogdmFsdWUgfSk7XG4gICAgfTtcbiAgICAvLyBTYXR1cmF0aW9uXG4gICAgSW1hZ2VVcmxCdWlsZGVyLnByb3RvdHlwZS5zYXR1cmF0aW9uID0gZnVuY3Rpb24gKHNhdHVyYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2l0aE9wdGlvbnMoeyBzYXR1cmF0aW9uOiBzYXR1cmF0aW9uIH0pO1xuICAgIH07XG4gICAgSW1hZ2VVcmxCdWlsZGVyLnByb3RvdHlwZS5hdXRvID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWxpZEF1dG9Nb2Rlcy5pbmRleE9mKHZhbHVlKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYXV0byBtb2RlIFxcXCJcIi5jb25jYXQodmFsdWUsIFwiXFxcIlwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMud2l0aE9wdGlvbnMoeyBhdXRvOiB2YWx1ZSB9KTtcbiAgICB9O1xuICAgIC8vIFNwZWNpZnkgdGhlIG51bWJlciBvZiBwaXhlbHMgdG8gcGFkIHRoZSBpbWFnZVxuICAgIEltYWdlVXJsQnVpbGRlci5wcm90b3R5cGUucGFkID0gZnVuY3Rpb24gKHBhZCkge1xuICAgICAgICByZXR1cm4gdGhpcy53aXRoT3B0aW9ucyh7IHBhZDogcGFkIH0pO1xuICAgIH07XG4gICAgLy8gVmFuaXR5IFVSTCBmb3IgbW9yZSBTRU8gZnJpZW5kbHkgVVJMc1xuICAgIEltYWdlVXJsQnVpbGRlci5wcm90b3R5cGUudmFuaXR5TmFtZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy53aXRoT3B0aW9ucyh7IHZhbml0eU5hbWU6IHZhbHVlIH0pO1xuICAgIH07XG4gICAgSW1hZ2VVcmxCdWlsZGVyLnByb3RvdHlwZS5mcmFtZSA9IGZ1bmN0aW9uIChmcmFtZSkge1xuICAgICAgICBpZiAoZnJhbWUgIT09IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZnJhbWUgdmFsdWUgXFxcIlwiLmNvbmNhdChmcmFtZSwgXCJcXFwiXCIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy53aXRoT3B0aW9ucyh7IGZyYW1lOiBmcmFtZSB9KTtcbiAgICB9O1xuICAgIC8vIEdldHMgdGhlIHVybCBiYXNlZCBvbiB0aGUgc3VibWl0dGVkIHBhcmFtZXRlcnNcbiAgICBJbWFnZVVybEJ1aWxkZXIucHJvdG90eXBlLnVybCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICgwLCB1cmxGb3JJbWFnZV8xLmRlZmF1bHQpKHRoaXMub3B0aW9ucyk7XG4gICAgfTtcbiAgICAvLyBBbGlhcyBmb3IgdXJsKClcbiAgICBJbWFnZVVybEJ1aWxkZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy51cmwoKTtcbiAgICB9O1xuICAgIHJldHVybiBJbWFnZVVybEJ1aWxkZXI7XG59KCkpO1xuZXhwb3J0cy5JbWFnZVVybEJ1aWxkZXIgPSBJbWFnZVVybEJ1aWxkZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1idWlsZGVyLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sanity/image-url/lib/node/builder.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@sanity/image-url/lib/node/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@sanity/image-url/lib/node/index.js ***!
  \**********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nvar builder_1 = __importDefault(__webpack_require__(/*! ./builder */ \"(ssr)/./node_modules/@sanity/image-url/lib/node/builder.js\"));\nmodule.exports = builder_1.default;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNhbml0eS9pbWFnZS11cmwvbGliL25vZGUvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDZDQUE2QztBQUM3QztBQUNBLGdDQUFnQyxtQkFBTyxDQUFDLDZFQUFXO0FBQ25EO0FBQ0EiLCJzb3VyY2VzIjpbIkc6XFxNeSBDYXJlZXJcXFdFQiBBTkQgTU9CSUxFIEFQUCBERVZFTE9QRU1FTlQgIChIVE1MLENTUywgSlMgKVxcRnJvbnQtRW5kIERldmVsb3BlbWVudFxcRmluYWwgUHJvamVjdFxcRnJvbnRlbmRcXG5vZGVfbW9kdWxlc1xcQHNhbml0eVxcaW1hZ2UtdXJsXFxsaWJcXG5vZGVcXGluZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xudmFyIGJ1aWxkZXJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9idWlsZGVyXCIpKTtcbm1vZHVsZS5leHBvcnRzID0gYnVpbGRlcl8xLmRlZmF1bHQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sanity/image-url/lib/node/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@sanity/image-url/lib/node/parseAssetId.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@sanity/image-url/lib/node/parseAssetId.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar example = 'image-Tb9Ew8CXIwaY6R1kjMvI0uRR-2000x3000-jpg';\nfunction parseAssetId(ref) {\n    var _a = ref.split('-'), id = _a[1], dimensionString = _a[2], format = _a[3];\n    if (!id || !dimensionString || !format) {\n        throw new Error(\"Malformed asset _ref '\".concat(ref, \"'. Expected an id like \\\"\").concat(example, \"\\\".\"));\n    }\n    var _b = dimensionString.split('x'), imgWidthStr = _b[0], imgHeightStr = _b[1];\n    var width = +imgWidthStr;\n    var height = +imgHeightStr;\n    var isValidAssetId = isFinite(width) && isFinite(height);\n    if (!isValidAssetId) {\n        throw new Error(\"Malformed asset _ref '\".concat(ref, \"'. Expected an id like \\\"\").concat(example, \"\\\".\"));\n    }\n    return { id: id, width: width, height: height, format: format };\n}\nexports[\"default\"] = parseAssetId;\n//# sourceMappingURL=parseAssetId.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNhbml0eS9pbWFnZS11cmwvbGliL25vZGUvcGFyc2VBc3NldElkLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0Esa0JBQWU7QUFDZiIsInNvdXJjZXMiOlsiRzpcXE15IENhcmVlclxcV0VCIEFORCBNT0JJTEUgQVBQIERFVkVMT1BFTUVOVCAgKEhUTUwsQ1NTLCBKUyApXFxGcm9udC1FbmQgRGV2ZWxvcGVtZW50XFxGaW5hbCBQcm9qZWN0XFxGcm9udGVuZFxcbm9kZV9tb2R1bGVzXFxAc2FuaXR5XFxpbWFnZS11cmxcXGxpYlxcbm9kZVxccGFyc2VBc3NldElkLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGV4YW1wbGUgPSAnaW1hZ2UtVGI5RXc4Q1hJd2FZNlIxa2pNdkkwdVJSLTIwMDB4MzAwMC1qcGcnO1xuZnVuY3Rpb24gcGFyc2VBc3NldElkKHJlZikge1xuICAgIHZhciBfYSA9IHJlZi5zcGxpdCgnLScpLCBpZCA9IF9hWzFdLCBkaW1lbnNpb25TdHJpbmcgPSBfYVsyXSwgZm9ybWF0ID0gX2FbM107XG4gICAgaWYgKCFpZCB8fCAhZGltZW5zaW9uU3RyaW5nIHx8ICFmb3JtYXQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWFsZm9ybWVkIGFzc2V0IF9yZWYgJ1wiLmNvbmNhdChyZWYsIFwiJy4gRXhwZWN0ZWQgYW4gaWQgbGlrZSBcXFwiXCIpLmNvbmNhdChleGFtcGxlLCBcIlxcXCIuXCIpKTtcbiAgICB9XG4gICAgdmFyIF9iID0gZGltZW5zaW9uU3RyaW5nLnNwbGl0KCd4JyksIGltZ1dpZHRoU3RyID0gX2JbMF0sIGltZ0hlaWdodFN0ciA9IF9iWzFdO1xuICAgIHZhciB3aWR0aCA9ICtpbWdXaWR0aFN0cjtcbiAgICB2YXIgaGVpZ2h0ID0gK2ltZ0hlaWdodFN0cjtcbiAgICB2YXIgaXNWYWxpZEFzc2V0SWQgPSBpc0Zpbml0ZSh3aWR0aCkgJiYgaXNGaW5pdGUoaGVpZ2h0KTtcbiAgICBpZiAoIWlzVmFsaWRBc3NldElkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1hbGZvcm1lZCBhc3NldCBfcmVmICdcIi5jb25jYXQocmVmLCBcIicuIEV4cGVjdGVkIGFuIGlkIGxpa2UgXFxcIlwiKS5jb25jYXQoZXhhbXBsZSwgXCJcXFwiLlwiKSk7XG4gICAgfVxuICAgIHJldHVybiB7IGlkOiBpZCwgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCwgZm9ybWF0OiBmb3JtYXQgfTtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IHBhcnNlQXNzZXRJZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhcnNlQXNzZXRJZC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sanity/image-url/lib/node/parseAssetId.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@sanity/image-url/lib/node/parseSource.js":
/*!****************************************************************!*\
  !*** ./node_modules/@sanity/image-url/lib/node/parseSource.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";
eval("\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar isRef = function (src) {\n    var source = src;\n    return source ? typeof source._ref === 'string' : false;\n};\nvar isAsset = function (src) {\n    var source = src;\n    return source ? typeof source._id === 'string' : false;\n};\nvar isAssetStub = function (src) {\n    var source = src;\n    return source && source.asset ? typeof source.asset.url === 'string' : false;\n};\n// Convert an asset-id, asset or image to an image record suitable for processing\n// eslint-disable-next-line complexity\nfunction parseSource(source) {\n    if (!source) {\n        return null;\n    }\n    var image;\n    if (typeof source === 'string' && isUrl(source)) {\n        // Someone passed an existing image url?\n        image = {\n            asset: { _ref: urlToId(source) },\n        };\n    }\n    else if (typeof source === 'string') {\n        // Just an asset id\n        image = {\n            asset: { _ref: source },\n        };\n    }\n    else if (isRef(source)) {\n        // We just got passed an asset directly\n        image = {\n            asset: source,\n        };\n    }\n    else if (isAsset(source)) {\n        // If we were passed an image asset document\n        image = {\n            asset: {\n                _ref: source._id || '',\n            },\n        };\n    }\n    else if (isAssetStub(source)) {\n        // If we were passed a partial asset (`url`, but no `_id`)\n        image = {\n            asset: {\n                _ref: urlToId(source.asset.url),\n            },\n        };\n    }\n    else if (typeof source.asset === 'object') {\n        // Probably an actual image with materialized asset\n        image = __assign({}, source);\n    }\n    else {\n        // We got something that does not look like an image, or it is an image\n        // that currently isn't sporting an asset.\n        return null;\n    }\n    var img = source;\n    if (img.crop) {\n        image.crop = img.crop;\n    }\n    if (img.hotspot) {\n        image.hotspot = img.hotspot;\n    }\n    return applyDefaults(image);\n}\nexports[\"default\"] = parseSource;\nfunction isUrl(url) {\n    return /^https?:\\/\\//.test(\"\".concat(url));\n}\nfunction urlToId(url) {\n    var parts = url.split('/').slice(-1);\n    return \"image-\".concat(parts[0]).replace(/\\.([a-z]+)$/, '-$1');\n}\n// Mock crop and hotspot if image lacks it\nfunction applyDefaults(image) {\n    if (image.crop && image.hotspot) {\n        return image;\n    }\n    // We need to pad in default values for crop or hotspot\n    var result = __assign({}, image);\n    if (!result.crop) {\n        result.crop = {\n            left: 0,\n            top: 0,\n            bottom: 0,\n            right: 0,\n        };\n    }\n    if (!result.hotspot) {\n        result.hotspot = {\n            x: 0.5,\n            y: 0.5,\n            height: 1.0,\n            width: 1.0,\n        };\n    }\n    return result;\n}\n//# sourceMappingURL=parseSource.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNhbml0eS9pbWFnZS11cmwvbGliL25vZGUvcGFyc2VTb3VyY2UuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0EsaURBQWlELE9BQU87QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix1QkFBdUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixjQUFjO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkc6XFxNeSBDYXJlZXJcXFdFQiBBTkQgTU9CSUxFIEFQUCBERVZFTE9QRU1FTlQgIChIVE1MLENTUywgSlMgKVxcRnJvbnQtRW5kIERldmVsb3BlbWVudFxcRmluYWwgUHJvamVjdFxcRnJvbnRlbmRcXG5vZGVfbW9kdWxlc1xcQHNhbml0eVxcaW1hZ2UtdXJsXFxsaWJcXG5vZGVcXHBhcnNlU291cmNlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXNzaWduID0gKHRoaXMgJiYgdGhpcy5fX2Fzc2lnbikgfHwgZnVuY3Rpb24gKCkge1xuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcbiAgICAgICAgICAgICAgICB0W3BdID0gc1twXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBpc1JlZiA9IGZ1bmN0aW9uIChzcmMpIHtcbiAgICB2YXIgc291cmNlID0gc3JjO1xuICAgIHJldHVybiBzb3VyY2UgPyB0eXBlb2Ygc291cmNlLl9yZWYgPT09ICdzdHJpbmcnIDogZmFsc2U7XG59O1xudmFyIGlzQXNzZXQgPSBmdW5jdGlvbiAoc3JjKSB7XG4gICAgdmFyIHNvdXJjZSA9IHNyYztcbiAgICByZXR1cm4gc291cmNlID8gdHlwZW9mIHNvdXJjZS5faWQgPT09ICdzdHJpbmcnIDogZmFsc2U7XG59O1xudmFyIGlzQXNzZXRTdHViID0gZnVuY3Rpb24gKHNyYykge1xuICAgIHZhciBzb3VyY2UgPSBzcmM7XG4gICAgcmV0dXJuIHNvdXJjZSAmJiBzb3VyY2UuYXNzZXQgPyB0eXBlb2Ygc291cmNlLmFzc2V0LnVybCA9PT0gJ3N0cmluZycgOiBmYWxzZTtcbn07XG4vLyBDb252ZXJ0IGFuIGFzc2V0LWlkLCBhc3NldCBvciBpbWFnZSB0byBhbiBpbWFnZSByZWNvcmQgc3VpdGFibGUgZm9yIHByb2Nlc3Npbmdcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG5mdW5jdGlvbiBwYXJzZVNvdXJjZShzb3VyY2UpIHtcbiAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIGltYWdlO1xuICAgIGlmICh0eXBlb2Ygc291cmNlID09PSAnc3RyaW5nJyAmJiBpc1VybChzb3VyY2UpKSB7XG4gICAgICAgIC8vIFNvbWVvbmUgcGFzc2VkIGFuIGV4aXN0aW5nIGltYWdlIHVybD9cbiAgICAgICAgaW1hZ2UgPSB7XG4gICAgICAgICAgICBhc3NldDogeyBfcmVmOiB1cmxUb0lkKHNvdXJjZSkgfSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHNvdXJjZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgLy8gSnVzdCBhbiBhc3NldCBpZFxuICAgICAgICBpbWFnZSA9IHtcbiAgICAgICAgICAgIGFzc2V0OiB7IF9yZWY6IHNvdXJjZSB9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChpc1JlZihzb3VyY2UpKSB7XG4gICAgICAgIC8vIFdlIGp1c3QgZ290IHBhc3NlZCBhbiBhc3NldCBkaXJlY3RseVxuICAgICAgICBpbWFnZSA9IHtcbiAgICAgICAgICAgIGFzc2V0OiBzb3VyY2UsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzQXNzZXQoc291cmNlKSkge1xuICAgICAgICAvLyBJZiB3ZSB3ZXJlIHBhc3NlZCBhbiBpbWFnZSBhc3NldCBkb2N1bWVudFxuICAgICAgICBpbWFnZSA9IHtcbiAgICAgICAgICAgIGFzc2V0OiB7XG4gICAgICAgICAgICAgICAgX3JlZjogc291cmNlLl9pZCB8fCAnJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzQXNzZXRTdHViKHNvdXJjZSkpIHtcbiAgICAgICAgLy8gSWYgd2Ugd2VyZSBwYXNzZWQgYSBwYXJ0aWFsIGFzc2V0IChgdXJsYCwgYnV0IG5vIGBfaWRgKVxuICAgICAgICBpbWFnZSA9IHtcbiAgICAgICAgICAgIGFzc2V0OiB7XG4gICAgICAgICAgICAgICAgX3JlZjogdXJsVG9JZChzb3VyY2UuYXNzZXQudXJsKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBzb3VyY2UuYXNzZXQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIC8vIFByb2JhYmx5IGFuIGFjdHVhbCBpbWFnZSB3aXRoIG1hdGVyaWFsaXplZCBhc3NldFxuICAgICAgICBpbWFnZSA9IF9fYXNzaWduKHt9LCBzb3VyY2UpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gV2UgZ290IHNvbWV0aGluZyB0aGF0IGRvZXMgbm90IGxvb2sgbGlrZSBhbiBpbWFnZSwgb3IgaXQgaXMgYW4gaW1hZ2VcbiAgICAgICAgLy8gdGhhdCBjdXJyZW50bHkgaXNuJ3Qgc3BvcnRpbmcgYW4gYXNzZXQuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgaW1nID0gc291cmNlO1xuICAgIGlmIChpbWcuY3JvcCkge1xuICAgICAgICBpbWFnZS5jcm9wID0gaW1nLmNyb3A7XG4gICAgfVxuICAgIGlmIChpbWcuaG90c3BvdCkge1xuICAgICAgICBpbWFnZS5ob3RzcG90ID0gaW1nLmhvdHNwb3Q7XG4gICAgfVxuICAgIHJldHVybiBhcHBseURlZmF1bHRzKGltYWdlKTtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IHBhcnNlU291cmNlO1xuZnVuY3Rpb24gaXNVcmwodXJsKSB7XG4gICAgcmV0dXJuIC9eaHR0cHM/OlxcL1xcLy8udGVzdChcIlwiLmNvbmNhdCh1cmwpKTtcbn1cbmZ1bmN0aW9uIHVybFRvSWQodXJsKSB7XG4gICAgdmFyIHBhcnRzID0gdXJsLnNwbGl0KCcvJykuc2xpY2UoLTEpO1xuICAgIHJldHVybiBcImltYWdlLVwiLmNvbmNhdChwYXJ0c1swXSkucmVwbGFjZSgvXFwuKFthLXpdKykkLywgJy0kMScpO1xufVxuLy8gTW9jayBjcm9wIGFuZCBob3RzcG90IGlmIGltYWdlIGxhY2tzIGl0XG5mdW5jdGlvbiBhcHBseURlZmF1bHRzKGltYWdlKSB7XG4gICAgaWYgKGltYWdlLmNyb3AgJiYgaW1hZ2UuaG90c3BvdCkge1xuICAgICAgICByZXR1cm4gaW1hZ2U7XG4gICAgfVxuICAgIC8vIFdlIG5lZWQgdG8gcGFkIGluIGRlZmF1bHQgdmFsdWVzIGZvciBjcm9wIG9yIGhvdHNwb3RcbiAgICB2YXIgcmVzdWx0ID0gX19hc3NpZ24oe30sIGltYWdlKTtcbiAgICBpZiAoIXJlc3VsdC5jcm9wKSB7XG4gICAgICAgIHJlc3VsdC5jcm9wID0ge1xuICAgICAgICAgICAgbGVmdDogMCxcbiAgICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICAgIGJvdHRvbTogMCxcbiAgICAgICAgICAgIHJpZ2h0OiAwLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAoIXJlc3VsdC5ob3RzcG90KSB7XG4gICAgICAgIHJlc3VsdC5ob3RzcG90ID0ge1xuICAgICAgICAgICAgeDogMC41LFxuICAgICAgICAgICAgeTogMC41LFxuICAgICAgICAgICAgaGVpZ2h0OiAxLjAsXG4gICAgICAgICAgICB3aWR0aDogMS4wLFxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGFyc2VTb3VyY2UuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sanity/image-url/lib/node/parseSource.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@sanity/image-url/lib/node/urlForImage.js":
/*!****************************************************************!*\
  !*** ./node_modules/@sanity/image-url/lib/node/urlForImage.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.parseSource = exports.SPEC_NAME_TO_URL_NAME_MAPPINGS = void 0;\nvar parseAssetId_1 = __importDefault(__webpack_require__(/*! ./parseAssetId */ \"(ssr)/./node_modules/@sanity/image-url/lib/node/parseAssetId.js\"));\nvar parseSource_1 = __importDefault(__webpack_require__(/*! ./parseSource */ \"(ssr)/./node_modules/@sanity/image-url/lib/node/parseSource.js\"));\nexports.parseSource = parseSource_1.default;\nexports.SPEC_NAME_TO_URL_NAME_MAPPINGS = [\n    ['width', 'w'],\n    ['height', 'h'],\n    ['format', 'fm'],\n    ['download', 'dl'],\n    ['blur', 'blur'],\n    ['sharpen', 'sharp'],\n    ['invert', 'invert'],\n    ['orientation', 'or'],\n    ['minHeight', 'min-h'],\n    ['maxHeight', 'max-h'],\n    ['minWidth', 'min-w'],\n    ['maxWidth', 'max-w'],\n    ['quality', 'q'],\n    ['fit', 'fit'],\n    ['crop', 'crop'],\n    ['saturation', 'sat'],\n    ['auto', 'auto'],\n    ['dpr', 'dpr'],\n    ['pad', 'pad'],\n    ['frame', 'frame']\n];\nfunction urlForImage(options) {\n    var spec = __assign({}, (options || {}));\n    var source = spec.source;\n    delete spec.source;\n    var image = (0, parseSource_1.default)(source);\n    if (!image) {\n        throw new Error(\"Unable to resolve image URL from source (\".concat(JSON.stringify(source), \")\"));\n    }\n    var id = image.asset._ref || image.asset._id || '';\n    var asset = (0, parseAssetId_1.default)(id);\n    // Compute crop rect in terms of pixel coordinates in the raw source image\n    var cropLeft = Math.round(image.crop.left * asset.width);\n    var cropTop = Math.round(image.crop.top * asset.height);\n    var crop = {\n        left: cropLeft,\n        top: cropTop,\n        width: Math.round(asset.width - image.crop.right * asset.width - cropLeft),\n        height: Math.round(asset.height - image.crop.bottom * asset.height - cropTop),\n    };\n    // Compute hot spot rect in terms of pixel coordinates\n    var hotSpotVerticalRadius = (image.hotspot.height * asset.height) / 2;\n    var hotSpotHorizontalRadius = (image.hotspot.width * asset.width) / 2;\n    var hotSpotCenterX = image.hotspot.x * asset.width;\n    var hotSpotCenterY = image.hotspot.y * asset.height;\n    var hotspot = {\n        left: hotSpotCenterX - hotSpotHorizontalRadius,\n        top: hotSpotCenterY - hotSpotVerticalRadius,\n        right: hotSpotCenterX + hotSpotHorizontalRadius,\n        bottom: hotSpotCenterY + hotSpotVerticalRadius,\n    };\n    // If irrelevant, or if we are requested to: don't perform crop/fit based on\n    // the crop/hotspot.\n    if (!(spec.rect || spec.focalPoint || spec.ignoreImageParams || spec.crop)) {\n        spec = __assign(__assign({}, spec), fit({ crop: crop, hotspot: hotspot }, spec));\n    }\n    return specToImageUrl(__assign(__assign({}, spec), { asset: asset }));\n}\nexports[\"default\"] = urlForImage;\n// eslint-disable-next-line complexity\nfunction specToImageUrl(spec) {\n    var cdnUrl = (spec.baseUrl || 'https://cdn.sanity.io').replace(/\\/+$/, '');\n    var vanityStub = spec.vanityName ? \"/\".concat(spec.vanityName) : '';\n    var filename = \"\".concat(spec.asset.id, \"-\").concat(spec.asset.width, \"x\").concat(spec.asset.height, \".\").concat(spec.asset.format).concat(vanityStub);\n    var baseUrl = \"\".concat(cdnUrl, \"/images/\").concat(spec.projectId, \"/\").concat(spec.dataset, \"/\").concat(filename);\n    var params = [];\n    if (spec.rect) {\n        // Only bother url with a crop if it actually crops anything\n        var _a = spec.rect, left = _a.left, top_1 = _a.top, width = _a.width, height = _a.height;\n        var isEffectiveCrop = left !== 0 || top_1 !== 0 || height !== spec.asset.height || width !== spec.asset.width;\n        if (isEffectiveCrop) {\n            params.push(\"rect=\".concat(left, \",\").concat(top_1, \",\").concat(width, \",\").concat(height));\n        }\n    }\n    if (spec.bg) {\n        params.push(\"bg=\".concat(spec.bg));\n    }\n    if (spec.focalPoint) {\n        params.push(\"fp-x=\".concat(spec.focalPoint.x));\n        params.push(\"fp-y=\".concat(spec.focalPoint.y));\n    }\n    var flip = [spec.flipHorizontal && 'h', spec.flipVertical && 'v'].filter(Boolean).join('');\n    if (flip) {\n        params.push(\"flip=\".concat(flip));\n    }\n    // Map from spec name to url param name, and allow using the actual param name as an alternative\n    exports.SPEC_NAME_TO_URL_NAME_MAPPINGS.forEach(function (mapping) {\n        var specName = mapping[0], param = mapping[1];\n        if (typeof spec[specName] !== 'undefined') {\n            params.push(\"\".concat(param, \"=\").concat(encodeURIComponent(spec[specName])));\n        }\n        else if (typeof spec[param] !== 'undefined') {\n            params.push(\"\".concat(param, \"=\").concat(encodeURIComponent(spec[param])));\n        }\n    });\n    if (params.length === 0) {\n        return baseUrl;\n    }\n    return \"\".concat(baseUrl, \"?\").concat(params.join('&'));\n}\nfunction fit(source, spec) {\n    var cropRect;\n    var imgWidth = spec.width;\n    var imgHeight = spec.height;\n    // If we are not constraining the aspect ratio, we'll just use the whole crop\n    if (!(imgWidth && imgHeight)) {\n        return { width: imgWidth, height: imgHeight, rect: source.crop };\n    }\n    var crop = source.crop;\n    var hotspot = source.hotspot;\n    // If we are here, that means aspect ratio is locked and fitting will be a bit harder\n    var desiredAspectRatio = imgWidth / imgHeight;\n    var cropAspectRatio = crop.width / crop.height;\n    if (cropAspectRatio > desiredAspectRatio) {\n        // The crop is wider than the desired aspect ratio. That means we are cutting from the sides\n        var height = Math.round(crop.height);\n        var width = Math.round(height * desiredAspectRatio);\n        var top_2 = Math.max(0, Math.round(crop.top));\n        // Center output horizontally over hotspot\n        var hotspotXCenter = Math.round((hotspot.right - hotspot.left) / 2 + hotspot.left);\n        var left = Math.max(0, Math.round(hotspotXCenter - width / 2));\n        // Keep output within crop\n        if (left < crop.left) {\n            left = crop.left;\n        }\n        else if (left + width > crop.left + crop.width) {\n            left = crop.left + crop.width - width;\n        }\n        cropRect = { left: left, top: top_2, width: width, height: height };\n    }\n    else {\n        // The crop is taller than the desired ratio, we are cutting from top and bottom\n        var width = crop.width;\n        var height = Math.round(width / desiredAspectRatio);\n        var left = Math.max(0, Math.round(crop.left));\n        // Center output vertically over hotspot\n        var hotspotYCenter = Math.round((hotspot.bottom - hotspot.top) / 2 + hotspot.top);\n        var top_3 = Math.max(0, Math.round(hotspotYCenter - height / 2));\n        // Keep output rect within crop\n        if (top_3 < crop.top) {\n            top_3 = crop.top;\n        }\n        else if (top_3 + height > crop.top + crop.height) {\n            top_3 = crop.top + crop.height - height;\n        }\n        cropRect = { left: left, top: top_3, width: width, height: height };\n    }\n    return {\n        width: imgWidth,\n        height: imgHeight,\n        rect: cropRect,\n    };\n}\n//# sourceMappingURL=urlForImage.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNhbml0eS9pbWFnZS11cmwvbGliL25vZGUvdXJsRm9ySW1hZ2UuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0EsaURBQWlELE9BQU87QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG1CQUFtQixHQUFHLHNDQUFzQztBQUM1RCxxQ0FBcUMsbUJBQU8sQ0FBQyx1RkFBZ0I7QUFDN0Qsb0NBQW9DLG1CQUFPLENBQUMscUZBQWU7QUFDM0QsbUJBQW1CO0FBQ25CLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixnQkFBZ0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsZUFBZSw4QkFBOEI7QUFDaEY7QUFDQSw4Q0FBOEMsV0FBVyxjQUFjO0FBQ3ZFO0FBQ0Esa0JBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkc6XFxNeSBDYXJlZXJcXFdFQiBBTkQgTU9CSUxFIEFQUCBERVZFTE9QRU1FTlQgIChIVE1MLENTUywgSlMgKVxcRnJvbnQtRW5kIERldmVsb3BlbWVudFxcRmluYWwgUHJvamVjdFxcRnJvbnRlbmRcXG5vZGVfbW9kdWxlc1xcQHNhbml0eVxcaW1hZ2UtdXJsXFxsaWJcXG5vZGVcXHVybEZvckltYWdlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXNzaWduID0gKHRoaXMgJiYgdGhpcy5fX2Fzc2lnbikgfHwgZnVuY3Rpb24gKCkge1xuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcbiAgICAgICAgICAgICAgICB0W3BdID0gc1twXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucGFyc2VTb3VyY2UgPSBleHBvcnRzLlNQRUNfTkFNRV9UT19VUkxfTkFNRV9NQVBQSU5HUyA9IHZvaWQgMDtcbnZhciBwYXJzZUFzc2V0SWRfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9wYXJzZUFzc2V0SWRcIikpO1xudmFyIHBhcnNlU291cmNlXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vcGFyc2VTb3VyY2VcIikpO1xuZXhwb3J0cy5wYXJzZVNvdXJjZSA9IHBhcnNlU291cmNlXzEuZGVmYXVsdDtcbmV4cG9ydHMuU1BFQ19OQU1FX1RPX1VSTF9OQU1FX01BUFBJTkdTID0gW1xuICAgIFsnd2lkdGgnLCAndyddLFxuICAgIFsnaGVpZ2h0JywgJ2gnXSxcbiAgICBbJ2Zvcm1hdCcsICdmbSddLFxuICAgIFsnZG93bmxvYWQnLCAnZGwnXSxcbiAgICBbJ2JsdXInLCAnYmx1ciddLFxuICAgIFsnc2hhcnBlbicsICdzaGFycCddLFxuICAgIFsnaW52ZXJ0JywgJ2ludmVydCddLFxuICAgIFsnb3JpZW50YXRpb24nLCAnb3InXSxcbiAgICBbJ21pbkhlaWdodCcsICdtaW4taCddLFxuICAgIFsnbWF4SGVpZ2h0JywgJ21heC1oJ10sXG4gICAgWydtaW5XaWR0aCcsICdtaW4tdyddLFxuICAgIFsnbWF4V2lkdGgnLCAnbWF4LXcnXSxcbiAgICBbJ3F1YWxpdHknLCAncSddLFxuICAgIFsnZml0JywgJ2ZpdCddLFxuICAgIFsnY3JvcCcsICdjcm9wJ10sXG4gICAgWydzYXR1cmF0aW9uJywgJ3NhdCddLFxuICAgIFsnYXV0bycsICdhdXRvJ10sXG4gICAgWydkcHInLCAnZHByJ10sXG4gICAgWydwYWQnLCAncGFkJ10sXG4gICAgWydmcmFtZScsICdmcmFtZSddXG5dO1xuZnVuY3Rpb24gdXJsRm9ySW1hZ2Uob3B0aW9ucykge1xuICAgIHZhciBzcGVjID0gX19hc3NpZ24oe30sIChvcHRpb25zIHx8IHt9KSk7XG4gICAgdmFyIHNvdXJjZSA9IHNwZWMuc291cmNlO1xuICAgIGRlbGV0ZSBzcGVjLnNvdXJjZTtcbiAgICB2YXIgaW1hZ2UgPSAoMCwgcGFyc2VTb3VyY2VfMS5kZWZhdWx0KShzb3VyY2UpO1xuICAgIGlmICghaW1hZ2UpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIHJlc29sdmUgaW1hZ2UgVVJMIGZyb20gc291cmNlIChcIi5jb25jYXQoSlNPTi5zdHJpbmdpZnkoc291cmNlKSwgXCIpXCIpKTtcbiAgICB9XG4gICAgdmFyIGlkID0gaW1hZ2UuYXNzZXQuX3JlZiB8fCBpbWFnZS5hc3NldC5faWQgfHwgJyc7XG4gICAgdmFyIGFzc2V0ID0gKDAsIHBhcnNlQXNzZXRJZF8xLmRlZmF1bHQpKGlkKTtcbiAgICAvLyBDb21wdXRlIGNyb3AgcmVjdCBpbiB0ZXJtcyBvZiBwaXhlbCBjb29yZGluYXRlcyBpbiB0aGUgcmF3IHNvdXJjZSBpbWFnZVxuICAgIHZhciBjcm9wTGVmdCA9IE1hdGgucm91bmQoaW1hZ2UuY3JvcC5sZWZ0ICogYXNzZXQud2lkdGgpO1xuICAgIHZhciBjcm9wVG9wID0gTWF0aC5yb3VuZChpbWFnZS5jcm9wLnRvcCAqIGFzc2V0LmhlaWdodCk7XG4gICAgdmFyIGNyb3AgPSB7XG4gICAgICAgIGxlZnQ6IGNyb3BMZWZ0LFxuICAgICAgICB0b3A6IGNyb3BUb3AsXG4gICAgICAgIHdpZHRoOiBNYXRoLnJvdW5kKGFzc2V0LndpZHRoIC0gaW1hZ2UuY3JvcC5yaWdodCAqIGFzc2V0LndpZHRoIC0gY3JvcExlZnQpLFxuICAgICAgICBoZWlnaHQ6IE1hdGgucm91bmQoYXNzZXQuaGVpZ2h0IC0gaW1hZ2UuY3JvcC5ib3R0b20gKiBhc3NldC5oZWlnaHQgLSBjcm9wVG9wKSxcbiAgICB9O1xuICAgIC8vIENvbXB1dGUgaG90IHNwb3QgcmVjdCBpbiB0ZXJtcyBvZiBwaXhlbCBjb29yZGluYXRlc1xuICAgIHZhciBob3RTcG90VmVydGljYWxSYWRpdXMgPSAoaW1hZ2UuaG90c3BvdC5oZWlnaHQgKiBhc3NldC5oZWlnaHQpIC8gMjtcbiAgICB2YXIgaG90U3BvdEhvcml6b250YWxSYWRpdXMgPSAoaW1hZ2UuaG90c3BvdC53aWR0aCAqIGFzc2V0LndpZHRoKSAvIDI7XG4gICAgdmFyIGhvdFNwb3RDZW50ZXJYID0gaW1hZ2UuaG90c3BvdC54ICogYXNzZXQud2lkdGg7XG4gICAgdmFyIGhvdFNwb3RDZW50ZXJZID0gaW1hZ2UuaG90c3BvdC55ICogYXNzZXQuaGVpZ2h0O1xuICAgIHZhciBob3RzcG90ID0ge1xuICAgICAgICBsZWZ0OiBob3RTcG90Q2VudGVyWCAtIGhvdFNwb3RIb3Jpem9udGFsUmFkaXVzLFxuICAgICAgICB0b3A6IGhvdFNwb3RDZW50ZXJZIC0gaG90U3BvdFZlcnRpY2FsUmFkaXVzLFxuICAgICAgICByaWdodDogaG90U3BvdENlbnRlclggKyBob3RTcG90SG9yaXpvbnRhbFJhZGl1cyxcbiAgICAgICAgYm90dG9tOiBob3RTcG90Q2VudGVyWSArIGhvdFNwb3RWZXJ0aWNhbFJhZGl1cyxcbiAgICB9O1xuICAgIC8vIElmIGlycmVsZXZhbnQsIG9yIGlmIHdlIGFyZSByZXF1ZXN0ZWQgdG86IGRvbid0IHBlcmZvcm0gY3JvcC9maXQgYmFzZWQgb25cbiAgICAvLyB0aGUgY3JvcC9ob3RzcG90LlxuICAgIGlmICghKHNwZWMucmVjdCB8fCBzcGVjLmZvY2FsUG9pbnQgfHwgc3BlYy5pZ25vcmVJbWFnZVBhcmFtcyB8fCBzcGVjLmNyb3ApKSB7XG4gICAgICAgIHNwZWMgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgc3BlYyksIGZpdCh7IGNyb3A6IGNyb3AsIGhvdHNwb3Q6IGhvdHNwb3QgfSwgc3BlYykpO1xuICAgIH1cbiAgICByZXR1cm4gc3BlY1RvSW1hZ2VVcmwoX19hc3NpZ24oX19hc3NpZ24oe30sIHNwZWMpLCB7IGFzc2V0OiBhc3NldCB9KSk7XG59XG5leHBvcnRzLmRlZmF1bHQgPSB1cmxGb3JJbWFnZTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG5mdW5jdGlvbiBzcGVjVG9JbWFnZVVybChzcGVjKSB7XG4gICAgdmFyIGNkblVybCA9IChzcGVjLmJhc2VVcmwgfHwgJ2h0dHBzOi8vY2RuLnNhbml0eS5pbycpLnJlcGxhY2UoL1xcLyskLywgJycpO1xuICAgIHZhciB2YW5pdHlTdHViID0gc3BlYy52YW5pdHlOYW1lID8gXCIvXCIuY29uY2F0KHNwZWMudmFuaXR5TmFtZSkgOiAnJztcbiAgICB2YXIgZmlsZW5hbWUgPSBcIlwiLmNvbmNhdChzcGVjLmFzc2V0LmlkLCBcIi1cIikuY29uY2F0KHNwZWMuYXNzZXQud2lkdGgsIFwieFwiKS5jb25jYXQoc3BlYy5hc3NldC5oZWlnaHQsIFwiLlwiKS5jb25jYXQoc3BlYy5hc3NldC5mb3JtYXQpLmNvbmNhdCh2YW5pdHlTdHViKTtcbiAgICB2YXIgYmFzZVVybCA9IFwiXCIuY29uY2F0KGNkblVybCwgXCIvaW1hZ2VzL1wiKS5jb25jYXQoc3BlYy5wcm9qZWN0SWQsIFwiL1wiKS5jb25jYXQoc3BlYy5kYXRhc2V0LCBcIi9cIikuY29uY2F0KGZpbGVuYW1lKTtcbiAgICB2YXIgcGFyYW1zID0gW107XG4gICAgaWYgKHNwZWMucmVjdCkge1xuICAgICAgICAvLyBPbmx5IGJvdGhlciB1cmwgd2l0aCBhIGNyb3AgaWYgaXQgYWN0dWFsbHkgY3JvcHMgYW55dGhpbmdcbiAgICAgICAgdmFyIF9hID0gc3BlYy5yZWN0LCBsZWZ0ID0gX2EubGVmdCwgdG9wXzEgPSBfYS50b3AsIHdpZHRoID0gX2Eud2lkdGgsIGhlaWdodCA9IF9hLmhlaWdodDtcbiAgICAgICAgdmFyIGlzRWZmZWN0aXZlQ3JvcCA9IGxlZnQgIT09IDAgfHwgdG9wXzEgIT09IDAgfHwgaGVpZ2h0ICE9PSBzcGVjLmFzc2V0LmhlaWdodCB8fCB3aWR0aCAhPT0gc3BlYy5hc3NldC53aWR0aDtcbiAgICAgICAgaWYgKGlzRWZmZWN0aXZlQ3JvcCkge1xuICAgICAgICAgICAgcGFyYW1zLnB1c2goXCJyZWN0PVwiLmNvbmNhdChsZWZ0LCBcIixcIikuY29uY2F0KHRvcF8xLCBcIixcIikuY29uY2F0KHdpZHRoLCBcIixcIikuY29uY2F0KGhlaWdodCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChzcGVjLmJnKSB7XG4gICAgICAgIHBhcmFtcy5wdXNoKFwiYmc9XCIuY29uY2F0KHNwZWMuYmcpKTtcbiAgICB9XG4gICAgaWYgKHNwZWMuZm9jYWxQb2ludCkge1xuICAgICAgICBwYXJhbXMucHVzaChcImZwLXg9XCIuY29uY2F0KHNwZWMuZm9jYWxQb2ludC54KSk7XG4gICAgICAgIHBhcmFtcy5wdXNoKFwiZnAteT1cIi5jb25jYXQoc3BlYy5mb2NhbFBvaW50LnkpKTtcbiAgICB9XG4gICAgdmFyIGZsaXAgPSBbc3BlYy5mbGlwSG9yaXpvbnRhbCAmJiAnaCcsIHNwZWMuZmxpcFZlcnRpY2FsICYmICd2J10uZmlsdGVyKEJvb2xlYW4pLmpvaW4oJycpO1xuICAgIGlmIChmbGlwKSB7XG4gICAgICAgIHBhcmFtcy5wdXNoKFwiZmxpcD1cIi5jb25jYXQoZmxpcCkpO1xuICAgIH1cbiAgICAvLyBNYXAgZnJvbSBzcGVjIG5hbWUgdG8gdXJsIHBhcmFtIG5hbWUsIGFuZCBhbGxvdyB1c2luZyB0aGUgYWN0dWFsIHBhcmFtIG5hbWUgYXMgYW4gYWx0ZXJuYXRpdmVcbiAgICBleHBvcnRzLlNQRUNfTkFNRV9UT19VUkxfTkFNRV9NQVBQSU5HUy5mb3JFYWNoKGZ1bmN0aW9uIChtYXBwaW5nKSB7XG4gICAgICAgIHZhciBzcGVjTmFtZSA9IG1hcHBpbmdbMF0sIHBhcmFtID0gbWFwcGluZ1sxXTtcbiAgICAgICAgaWYgKHR5cGVvZiBzcGVjW3NwZWNOYW1lXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBhcmFtcy5wdXNoKFwiXCIuY29uY2F0KHBhcmFtLCBcIj1cIikuY29uY2F0KGVuY29kZVVSSUNvbXBvbmVudChzcGVjW3NwZWNOYW1lXSkpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2Ygc3BlY1twYXJhbV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXJhbXMucHVzaChcIlwiLmNvbmNhdChwYXJhbSwgXCI9XCIpLmNvbmNhdChlbmNvZGVVUklDb21wb25lbnQoc3BlY1twYXJhbV0pKSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAocGFyYW1zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gYmFzZVVybDtcbiAgICB9XG4gICAgcmV0dXJuIFwiXCIuY29uY2F0KGJhc2VVcmwsIFwiP1wiKS5jb25jYXQocGFyYW1zLmpvaW4oJyYnKSk7XG59XG5mdW5jdGlvbiBmaXQoc291cmNlLCBzcGVjKSB7XG4gICAgdmFyIGNyb3BSZWN0O1xuICAgIHZhciBpbWdXaWR0aCA9IHNwZWMud2lkdGg7XG4gICAgdmFyIGltZ0hlaWdodCA9IHNwZWMuaGVpZ2h0O1xuICAgIC8vIElmIHdlIGFyZSBub3QgY29uc3RyYWluaW5nIHRoZSBhc3BlY3QgcmF0aW8sIHdlJ2xsIGp1c3QgdXNlIHRoZSB3aG9sZSBjcm9wXG4gICAgaWYgKCEoaW1nV2lkdGggJiYgaW1nSGVpZ2h0KSkge1xuICAgICAgICByZXR1cm4geyB3aWR0aDogaW1nV2lkdGgsIGhlaWdodDogaW1nSGVpZ2h0LCByZWN0OiBzb3VyY2UuY3JvcCB9O1xuICAgIH1cbiAgICB2YXIgY3JvcCA9IHNvdXJjZS5jcm9wO1xuICAgIHZhciBob3RzcG90ID0gc291cmNlLmhvdHNwb3Q7XG4gICAgLy8gSWYgd2UgYXJlIGhlcmUsIHRoYXQgbWVhbnMgYXNwZWN0IHJhdGlvIGlzIGxvY2tlZCBhbmQgZml0dGluZyB3aWxsIGJlIGEgYml0IGhhcmRlclxuICAgIHZhciBkZXNpcmVkQXNwZWN0UmF0aW8gPSBpbWdXaWR0aCAvIGltZ0hlaWdodDtcbiAgICB2YXIgY3JvcEFzcGVjdFJhdGlvID0gY3JvcC53aWR0aCAvIGNyb3AuaGVpZ2h0O1xuICAgIGlmIChjcm9wQXNwZWN0UmF0aW8gPiBkZXNpcmVkQXNwZWN0UmF0aW8pIHtcbiAgICAgICAgLy8gVGhlIGNyb3AgaXMgd2lkZXIgdGhhbiB0aGUgZGVzaXJlZCBhc3BlY3QgcmF0aW8uIFRoYXQgbWVhbnMgd2UgYXJlIGN1dHRpbmcgZnJvbSB0aGUgc2lkZXNcbiAgICAgICAgdmFyIGhlaWdodCA9IE1hdGgucm91bmQoY3JvcC5oZWlnaHQpO1xuICAgICAgICB2YXIgd2lkdGggPSBNYXRoLnJvdW5kKGhlaWdodCAqIGRlc2lyZWRBc3BlY3RSYXRpbyk7XG4gICAgICAgIHZhciB0b3BfMiA9IE1hdGgubWF4KDAsIE1hdGgucm91bmQoY3JvcC50b3ApKTtcbiAgICAgICAgLy8gQ2VudGVyIG91dHB1dCBob3Jpem9udGFsbHkgb3ZlciBob3RzcG90XG4gICAgICAgIHZhciBob3RzcG90WENlbnRlciA9IE1hdGgucm91bmQoKGhvdHNwb3QucmlnaHQgLSBob3RzcG90LmxlZnQpIC8gMiArIGhvdHNwb3QubGVmdCk7XG4gICAgICAgIHZhciBsZWZ0ID0gTWF0aC5tYXgoMCwgTWF0aC5yb3VuZChob3RzcG90WENlbnRlciAtIHdpZHRoIC8gMikpO1xuICAgICAgICAvLyBLZWVwIG91dHB1dCB3aXRoaW4gY3JvcFxuICAgICAgICBpZiAobGVmdCA8IGNyb3AubGVmdCkge1xuICAgICAgICAgICAgbGVmdCA9IGNyb3AubGVmdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsZWZ0ICsgd2lkdGggPiBjcm9wLmxlZnQgKyBjcm9wLndpZHRoKSB7XG4gICAgICAgICAgICBsZWZ0ID0gY3JvcC5sZWZ0ICsgY3JvcC53aWR0aCAtIHdpZHRoO1xuICAgICAgICB9XG4gICAgICAgIGNyb3BSZWN0ID0geyBsZWZ0OiBsZWZ0LCB0b3A6IHRvcF8yLCB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0IH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBUaGUgY3JvcCBpcyB0YWxsZXIgdGhhbiB0aGUgZGVzaXJlZCByYXRpbywgd2UgYXJlIGN1dHRpbmcgZnJvbSB0b3AgYW5kIGJvdHRvbVxuICAgICAgICB2YXIgd2lkdGggPSBjcm9wLndpZHRoO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gTWF0aC5yb3VuZCh3aWR0aCAvIGRlc2lyZWRBc3BlY3RSYXRpbyk7XG4gICAgICAgIHZhciBsZWZ0ID0gTWF0aC5tYXgoMCwgTWF0aC5yb3VuZChjcm9wLmxlZnQpKTtcbiAgICAgICAgLy8gQ2VudGVyIG91dHB1dCB2ZXJ0aWNhbGx5IG92ZXIgaG90c3BvdFxuICAgICAgICB2YXIgaG90c3BvdFlDZW50ZXIgPSBNYXRoLnJvdW5kKChob3RzcG90LmJvdHRvbSAtIGhvdHNwb3QudG9wKSAvIDIgKyBob3RzcG90LnRvcCk7XG4gICAgICAgIHZhciB0b3BfMyA9IE1hdGgubWF4KDAsIE1hdGgucm91bmQoaG90c3BvdFlDZW50ZXIgLSBoZWlnaHQgLyAyKSk7XG4gICAgICAgIC8vIEtlZXAgb3V0cHV0IHJlY3Qgd2l0aGluIGNyb3BcbiAgICAgICAgaWYgKHRvcF8zIDwgY3JvcC50b3ApIHtcbiAgICAgICAgICAgIHRvcF8zID0gY3JvcC50b3A7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodG9wXzMgKyBoZWlnaHQgPiBjcm9wLnRvcCArIGNyb3AuaGVpZ2h0KSB7XG4gICAgICAgICAgICB0b3BfMyA9IGNyb3AudG9wICsgY3JvcC5oZWlnaHQgLSBoZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgY3JvcFJlY3QgPSB7IGxlZnQ6IGxlZnQsIHRvcDogdG9wXzMsIHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgd2lkdGg6IGltZ1dpZHRoLFxuICAgICAgICBoZWlnaHQ6IGltZ0hlaWdodCxcbiAgICAgICAgcmVjdDogY3JvcFJlY3QsXG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVybEZvckltYWdlLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sanity/image-url/lib/node/urlForImage.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@sanity/eventsource/node.js":
/*!**************************************************!*\
  !*** ./node_modules/@sanity/eventsource/node.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! eventsource */ \"(ssr)/./node_modules/eventsource/lib/eventsource.js\")\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNhbml0eS9ldmVudHNvdXJjZS9ub2RlLmpzIiwibWFwcGluZ3MiOiJBQUFBLDhHQUF1QyIsInNvdXJjZXMiOlsiRzpcXE15IENhcmVlclxcV0VCIEFORCBNT0JJTEUgQVBQIERFVkVMT1BFTUVOVCAgKEhUTUwsQ1NTLCBKUyApXFxGcm9udC1FbmQgRGV2ZWxvcGVtZW50XFxGaW5hbCBQcm9qZWN0XFxGcm9udGVuZFxcbm9kZV9tb2R1bGVzXFxAc2FuaXR5XFxldmVudHNvdXJjZVxcbm9kZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJ2V2ZW50c291cmNlJylcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sanity/eventsource/node.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@sanity/client/dist/_chunks-es/config.js":
/*!***************************************************************!*\
  !*** ./node_modules/@sanity/client/dist/_chunks-es/config.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   dataset: () => (/* binding */ dataset),\n/* harmony export */   defaultConfig: () => (/* binding */ defaultConfig),\n/* harmony export */   hasDataset: () => (/* binding */ hasDataset),\n/* harmony export */   initConfig: () => (/* binding */ initConfig),\n/* harmony export */   printCdnPreviewDraftsWarning: () => (/* binding */ printCdnPreviewDraftsWarning),\n/* harmony export */   printNoDefaultExport: () => (/* binding */ printNoDefaultExport),\n/* harmony export */   requestTag: () => (/* binding */ requestTag),\n/* harmony export */   requireDocumentId: () => (/* binding */ requireDocumentId),\n/* harmony export */   validateApiPerspective: () => (/* binding */ validateApiPerspective),\n/* harmony export */   validateAssetType: () => (/* binding */ validateAssetType),\n/* harmony export */   validateDocumentId: () => (/* binding */ validateDocumentId),\n/* harmony export */   validateInsert: () => (/* binding */ validateInsert),\n/* harmony export */   validateObject: () => (/* binding */ validateObject)\n/* harmony export */ });\nconst BASE_URL = \"https://www.sanity.io/help/\";\nfunction generateHelpUrl(slug) {\n  return BASE_URL + slug;\n}\nconst VALID_ASSET_TYPES = [\"image\", \"file\"], VALID_INSERT_LOCATIONS = [\"before\", \"after\", \"replace\"], dataset = (name) => {\n  if (!/^(~[a-z0-9]{1}[-\\w]{0,63}|[a-z0-9]{1}[-\\w]{0,63})$/.test(name))\n    throw new Error(\n      \"Datasets can only contain lowercase characters, numbers, underscores and dashes, and start with tilde, and be maximum 64 characters\"\n    );\n}, projectId = (id) => {\n  if (!/^[-a-z0-9]+$/i.test(id))\n    throw new Error(\"`projectId` can only contain only a-z, 0-9 and dashes\");\n}, validateAssetType = (type) => {\n  if (VALID_ASSET_TYPES.indexOf(type) === -1)\n    throw new Error(`Invalid asset type: ${type}. Must be one of ${VALID_ASSET_TYPES.join(\", \")}`);\n}, validateObject = (op, val) => {\n  if (val === null || typeof val != \"object\" || Array.isArray(val))\n    throw new Error(`${op}() takes an object of properties`);\n}, validateDocumentId = (op, id) => {\n  if (typeof id != \"string\" || !/^[a-z0-9_][a-z0-9_.-]{0,127}$/i.test(id) || id.includes(\"..\"))\n    throw new Error(`${op}(): \"${id}\" is not a valid document ID`);\n}, requireDocumentId = (op, doc) => {\n  if (!doc._id)\n    throw new Error(`${op}() requires that the document contains an ID (\"_id\" property)`);\n  validateDocumentId(op, doc._id);\n}, validateInsert = (at, selector, items) => {\n  const signature = \"insert(at, selector, items)\";\n  if (VALID_INSERT_LOCATIONS.indexOf(at) === -1) {\n    const valid = VALID_INSERT_LOCATIONS.map((loc) => `\"${loc}\"`).join(\", \");\n    throw new Error(`${signature} takes an \"at\"-argument which is one of: ${valid}`);\n  }\n  if (typeof selector != \"string\")\n    throw new Error(`${signature} takes a \"selector\"-argument which must be a string`);\n  if (!Array.isArray(items))\n    throw new Error(`${signature} takes an \"items\"-argument which must be an array`);\n}, hasDataset = (config) => {\n  if (!config.dataset)\n    throw new Error(\"`dataset` must be provided to perform queries\");\n  return config.dataset || \"\";\n}, requestTag = (tag) => {\n  if (typeof tag != \"string\" || !/^[a-z0-9._-]{1,75}$/i.test(tag))\n    throw new Error(\n      \"Tag can only contain alphanumeric characters, underscores, dashes and dots, and be between one and 75 characters long.\"\n    );\n  return tag;\n};\nfunction once(fn) {\n  let didCall = !1, returnValue;\n  return (...args) => (didCall || (returnValue = fn(...args), didCall = !0), returnValue);\n}\nconst createWarningPrinter = (message) => (\n  // eslint-disable-next-line no-console\n  once((...args) => console.warn(message.join(\" \"), ...args))\n), printCdnAndWithCredentialsWarning = createWarningPrinter([\n  \"Because you set `withCredentials` to true, we will override your `useCdn`\",\n  \"setting to be false since (cookie-based) credentials are never set on the CDN\"\n]), printCdnWarning = createWarningPrinter([\n  \"Since you haven't set a value for `useCdn`, we will deliver content using our\",\n  \"global, edge-cached API-CDN. If you wish to have content delivered faster, set\",\n  \"`useCdn: false` to use the Live API. Note: You may incur higher costs using the live API.\"\n]), printCdnPreviewDraftsWarning = createWarningPrinter([\n  \"The Sanity client is configured with the `perspective` set to `previewDrafts`, which doesn't support the API-CDN.\",\n  \"The Live API will be used instead. Set `useCdn: false` in your configuration to hide this warning.\"\n]), printBrowserTokenWarning = createWarningPrinter([\n  \"You have configured Sanity client to use a token in the browser. This may cause unintentional security issues.\",\n  `See ${generateHelpUrl(\n    \"js-client-browser-token\"\n  )} for more information and how to hide this warning.`\n]), printNoApiVersionSpecifiedWarning = createWarningPrinter([\n  \"Using the Sanity client without specifying an API version is deprecated.\",\n  `See ${generateHelpUrl(\"js-client-api-version\")}`\n]), printNoDefaultExport = createWarningPrinter([\n  \"The default export of @sanity/client has been deprecated. Use the named export `createClient` instead.\"\n]), defaultCdnHost = \"apicdn.sanity.io\", defaultConfig = {\n  apiHost: \"https://api.sanity.io\",\n  apiVersion: \"1\",\n  useProjectHostname: !0,\n  stega: { enabled: !1 }\n}, LOCALHOSTS = [\"localhost\", \"127.0.0.1\", \"0.0.0.0\"], isLocal = (host) => LOCALHOSTS.indexOf(host) !== -1;\nfunction validateApiVersion(apiVersion) {\n  if (apiVersion === \"1\" || apiVersion === \"X\")\n    return;\n  const apiDate = new Date(apiVersion);\n  if (!(/^\\d{4}-\\d{2}-\\d{2}$/.test(apiVersion) && apiDate instanceof Date && apiDate.getTime() > 0))\n    throw new Error(\"Invalid API version string, expected `1` or date in format `YYYY-MM-DD`\");\n}\nfunction validateApiPerspective(perspective) {\n  if (Array.isArray(perspective)) {\n    for (const perspectiveValue of perspective)\n      if (perspectiveValue !== \"published\" && perspectiveValue !== \"drafts\" && !(typeof perspectiveValue == \"string\" && perspectiveValue.startsWith(\"r\") && perspectiveValue !== \"raw\"))\n        throw new TypeError(\n          \"Invalid API perspective value, expected `published`, `drafts` or a valid release identifier string\"\n        );\n    return;\n  }\n  switch (perspective) {\n    case \"previewDrafts\":\n    case \"drafts\":\n    case \"published\":\n    case \"raw\":\n      return;\n    default:\n      throw new TypeError(\n        \"Invalid API perspective string, expected `published`, `previewDrafts` or `raw`\"\n      );\n  }\n}\nconst initConfig = (config, prevConfig) => {\n  const specifiedConfig = {\n    ...prevConfig,\n    ...config,\n    stega: {\n      ...typeof prevConfig.stega == \"boolean\" ? { enabled: prevConfig.stega } : prevConfig.stega || defaultConfig.stega,\n      ...typeof config.stega == \"boolean\" ? { enabled: config.stega } : config.stega || {}\n    }\n  };\n  specifiedConfig.apiVersion || printNoApiVersionSpecifiedWarning();\n  const newConfig = {\n    ...defaultConfig,\n    ...specifiedConfig\n  }, projectBased = newConfig.useProjectHostname;\n  if (typeof Promise > \"u\") {\n    const helpUrl = generateHelpUrl(\"js-client-promise-polyfill\");\n    throw new Error(`No native Promise-implementation found, polyfill needed - see ${helpUrl}`);\n  }\n  if (projectBased && !newConfig.projectId)\n    throw new Error(\"Configuration must contain `projectId`\");\n  if (typeof newConfig.perspective < \"u\" && validateApiPerspective(newConfig.perspective), \"encodeSourceMap\" in newConfig)\n    throw new Error(\n      \"It looks like you're using options meant for '@sanity/preview-kit/client'. 'encodeSourceMap' is not supported in '@sanity/client'. Did you mean 'stega.enabled'?\"\n    );\n  if (\"encodeSourceMapAtPath\" in newConfig)\n    throw new Error(\n      \"It looks like you're using options meant for '@sanity/preview-kit/client'. 'encodeSourceMapAtPath' is not supported in '@sanity/client'. Did you mean 'stega.filter'?\"\n    );\n  if (typeof newConfig.stega.enabled != \"boolean\")\n    throw new Error(`stega.enabled must be a boolean, received ${newConfig.stega.enabled}`);\n  if (newConfig.stega.enabled && newConfig.stega.studioUrl === void 0)\n    throw new Error(\"stega.studioUrl must be defined when stega.enabled is true\");\n  if (newConfig.stega.enabled && typeof newConfig.stega.studioUrl != \"string\" && typeof newConfig.stega.studioUrl != \"function\")\n    throw new Error(\n      `stega.studioUrl must be a string or a function, received ${newConfig.stega.studioUrl}`\n    );\n  const isBrowser = typeof window < \"u\" && window.location && window.location.hostname, isLocalhost = isBrowser && isLocal(window.location.hostname);\n  isBrowser && isLocalhost && newConfig.token && newConfig.ignoreBrowserTokenWarning !== !0 ? printBrowserTokenWarning() : typeof newConfig.useCdn > \"u\" && printCdnWarning(), projectBased && projectId(newConfig.projectId), newConfig.dataset && dataset(newConfig.dataset), \"requestTagPrefix\" in newConfig && (newConfig.requestTagPrefix = newConfig.requestTagPrefix ? requestTag(newConfig.requestTagPrefix).replace(/\\.+$/, \"\") : void 0), newConfig.apiVersion = `${newConfig.apiVersion}`.replace(/^v/, \"\"), newConfig.isDefaultApi = newConfig.apiHost === defaultConfig.apiHost, newConfig.useCdn === !0 && newConfig.withCredentials && printCdnAndWithCredentialsWarning(), newConfig.useCdn = newConfig.useCdn !== !1 && !newConfig.withCredentials, validateApiVersion(newConfig.apiVersion);\n  const hostParts = newConfig.apiHost.split(\"://\", 2), protocol = hostParts[0], host = hostParts[1], cdnHost = newConfig.isDefaultApi ? defaultCdnHost : host;\n  return newConfig.useProjectHostname ? (newConfig.url = `${protocol}://${newConfig.projectId}.${host}/v${newConfig.apiVersion}`, newConfig.cdnUrl = `${protocol}://${newConfig.projectId}.${cdnHost}/v${newConfig.apiVersion}`) : (newConfig.url = `${newConfig.apiHost}/v${newConfig.apiVersion}`, newConfig.cdnUrl = newConfig.url), newConfig;\n};\n\n//# sourceMappingURL=config.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNhbml0eS9jbGllbnQvZGlzdC9fY2h1bmtzLWVzL2NvbmZpZy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixFQUFFLE1BQU0sS0FBSyxVQUFVLEVBQUUsTUFBTSxLQUFLO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsMkNBQTJDLEtBQUssbUJBQW1CLDZCQUE2QjtBQUNoRyxDQUFDO0FBQ0Q7QUFDQSx1QkFBdUIsR0FBRztBQUMxQixDQUFDO0FBQ0QsdURBQXVELE1BQU07QUFDN0QsdUJBQXVCLEdBQUcsT0FBTyxHQUFHO0FBQ3BDLENBQUM7QUFDRDtBQUNBLHVCQUF1QixHQUFHO0FBQzFCO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSwwREFBMEQsSUFBSTtBQUM5RCx1QkFBdUIsV0FBVywwQ0FBMEMsTUFBTTtBQUNsRjtBQUNBO0FBQ0EsdUJBQXVCLFdBQVc7QUFDbEM7QUFDQSx1QkFBdUIsV0FBVztBQUNsQyxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELCtDQUErQyxLQUFLO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsU0FBUyx5Q0FBeUM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELDRCQUE0QjtBQUM5RSw4Q0FBOEMsd0JBQXdCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EscUZBQXFGLFFBQVE7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLHdCQUF3QjtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSwwQkFBMEI7QUFDNUY7QUFDQTtBQUNBLDhjQUE4YyxxQkFBcUI7QUFDbmU7QUFDQSw0REFBNEQsU0FBUyxLQUFLLG9CQUFvQixHQUFHLEtBQUssSUFBSSxxQkFBcUIseUJBQXlCLFNBQVMsS0FBSyxvQkFBb0IsR0FBRyxRQUFRLElBQUkscUJBQXFCLHlCQUF5QixrQkFBa0IsSUFBSSxxQkFBcUI7QUFDbFM7QUFlRTtBQUNGIiwic291cmNlcyI6WyJHOlxcTXkgQ2FyZWVyXFxXRUIgQU5EIE1PQklMRSBBUFAgREVWRUxPUEVNRU5UICAoSFRNTCxDU1MsIEpTIClcXEZyb250LUVuZCBEZXZlbG9wZW1lbnRcXEZpbmFsIFByb2plY3RcXEZyb250ZW5kXFxub2RlX21vZHVsZXNcXEBzYW5pdHlcXGNsaWVudFxcZGlzdFxcX2NodW5rcy1lc1xcY29uZmlnLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IEJBU0VfVVJMID0gXCJodHRwczovL3d3dy5zYW5pdHkuaW8vaGVscC9cIjtcbmZ1bmN0aW9uIGdlbmVyYXRlSGVscFVybChzbHVnKSB7XG4gIHJldHVybiBCQVNFX1VSTCArIHNsdWc7XG59XG5jb25zdCBWQUxJRF9BU1NFVF9UWVBFUyA9IFtcImltYWdlXCIsIFwiZmlsZVwiXSwgVkFMSURfSU5TRVJUX0xPQ0FUSU9OUyA9IFtcImJlZm9yZVwiLCBcImFmdGVyXCIsIFwicmVwbGFjZVwiXSwgZGF0YXNldCA9IChuYW1lKSA9PiB7XG4gIGlmICghL14oflthLXowLTldezF9Wy1cXHddezAsNjN9fFthLXowLTldezF9Wy1cXHddezAsNjN9KSQvLnRlc3QobmFtZSkpXG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJEYXRhc2V0cyBjYW4gb25seSBjb250YWluIGxvd2VyY2FzZSBjaGFyYWN0ZXJzLCBudW1iZXJzLCB1bmRlcnNjb3JlcyBhbmQgZGFzaGVzLCBhbmQgc3RhcnQgd2l0aCB0aWxkZSwgYW5kIGJlIG1heGltdW0gNjQgY2hhcmFjdGVyc1wiXG4gICAgKTtcbn0sIHByb2plY3RJZCA9IChpZCkgPT4ge1xuICBpZiAoIS9eWy1hLXowLTldKyQvaS50ZXN0KGlkKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJgcHJvamVjdElkYCBjYW4gb25seSBjb250YWluIG9ubHkgYS16LCAwLTkgYW5kIGRhc2hlc1wiKTtcbn0sIHZhbGlkYXRlQXNzZXRUeXBlID0gKHR5cGUpID0+IHtcbiAgaWYgKFZBTElEX0FTU0VUX1RZUEVTLmluZGV4T2YodHlwZSkgPT09IC0xKVxuICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBhc3NldCB0eXBlOiAke3R5cGV9LiBNdXN0IGJlIG9uZSBvZiAke1ZBTElEX0FTU0VUX1RZUEVTLmpvaW4oXCIsIFwiKX1gKTtcbn0sIHZhbGlkYXRlT2JqZWN0ID0gKG9wLCB2YWwpID0+IHtcbiAgaWYgKHZhbCA9PT0gbnVsbCB8fCB0eXBlb2YgdmFsICE9IFwib2JqZWN0XCIgfHwgQXJyYXkuaXNBcnJheSh2YWwpKVxuICAgIHRocm93IG5ldyBFcnJvcihgJHtvcH0oKSB0YWtlcyBhbiBvYmplY3Qgb2YgcHJvcGVydGllc2ApO1xufSwgdmFsaWRhdGVEb2N1bWVudElkID0gKG9wLCBpZCkgPT4ge1xuICBpZiAodHlwZW9mIGlkICE9IFwic3RyaW5nXCIgfHwgIS9eW2EtejAtOV9dW2EtejAtOV8uLV17MCwxMjd9JC9pLnRlc3QoaWQpIHx8IGlkLmluY2x1ZGVzKFwiLi5cIikpXG4gICAgdGhyb3cgbmV3IEVycm9yKGAke29wfSgpOiBcIiR7aWR9XCIgaXMgbm90IGEgdmFsaWQgZG9jdW1lbnQgSURgKTtcbn0sIHJlcXVpcmVEb2N1bWVudElkID0gKG9wLCBkb2MpID0+IHtcbiAgaWYgKCFkb2MuX2lkKVxuICAgIHRocm93IG5ldyBFcnJvcihgJHtvcH0oKSByZXF1aXJlcyB0aGF0IHRoZSBkb2N1bWVudCBjb250YWlucyBhbiBJRCAoXCJfaWRcIiBwcm9wZXJ0eSlgKTtcbiAgdmFsaWRhdGVEb2N1bWVudElkKG9wLCBkb2MuX2lkKTtcbn0sIHZhbGlkYXRlSW5zZXJ0ID0gKGF0LCBzZWxlY3RvciwgaXRlbXMpID0+IHtcbiAgY29uc3Qgc2lnbmF0dXJlID0gXCJpbnNlcnQoYXQsIHNlbGVjdG9yLCBpdGVtcylcIjtcbiAgaWYgKFZBTElEX0lOU0VSVF9MT0NBVElPTlMuaW5kZXhPZihhdCkgPT09IC0xKSB7XG4gICAgY29uc3QgdmFsaWQgPSBWQUxJRF9JTlNFUlRfTE9DQVRJT05TLm1hcCgobG9jKSA9PiBgXCIke2xvY31cImApLmpvaW4oXCIsIFwiKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYCR7c2lnbmF0dXJlfSB0YWtlcyBhbiBcImF0XCItYXJndW1lbnQgd2hpY2ggaXMgb25lIG9mOiAke3ZhbGlkfWApO1xuICB9XG4gIGlmICh0eXBlb2Ygc2VsZWN0b3IgIT0gXCJzdHJpbmdcIilcbiAgICB0aHJvdyBuZXcgRXJyb3IoYCR7c2lnbmF0dXJlfSB0YWtlcyBhIFwic2VsZWN0b3JcIi1hcmd1bWVudCB3aGljaCBtdXN0IGJlIGEgc3RyaW5nYCk7XG4gIGlmICghQXJyYXkuaXNBcnJheShpdGVtcykpXG4gICAgdGhyb3cgbmV3IEVycm9yKGAke3NpZ25hdHVyZX0gdGFrZXMgYW4gXCJpdGVtc1wiLWFyZ3VtZW50IHdoaWNoIG11c3QgYmUgYW4gYXJyYXlgKTtcbn0sIGhhc0RhdGFzZXQgPSAoY29uZmlnKSA9PiB7XG4gIGlmICghY29uZmlnLmRhdGFzZXQpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiYGRhdGFzZXRgIG11c3QgYmUgcHJvdmlkZWQgdG8gcGVyZm9ybSBxdWVyaWVzXCIpO1xuICByZXR1cm4gY29uZmlnLmRhdGFzZXQgfHwgXCJcIjtcbn0sIHJlcXVlc3RUYWcgPSAodGFnKSA9PiB7XG4gIGlmICh0eXBlb2YgdGFnICE9IFwic3RyaW5nXCIgfHwgIS9eW2EtejAtOS5fLV17MSw3NX0kL2kudGVzdCh0YWcpKVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiVGFnIGNhbiBvbmx5IGNvbnRhaW4gYWxwaGFudW1lcmljIGNoYXJhY3RlcnMsIHVuZGVyc2NvcmVzLCBkYXNoZXMgYW5kIGRvdHMsIGFuZCBiZSBiZXR3ZWVuIG9uZSBhbmQgNzUgY2hhcmFjdGVycyBsb25nLlwiXG4gICAgKTtcbiAgcmV0dXJuIHRhZztcbn07XG5mdW5jdGlvbiBvbmNlKGZuKSB7XG4gIGxldCBkaWRDYWxsID0gITEsIHJldHVyblZhbHVlO1xuICByZXR1cm4gKC4uLmFyZ3MpID0+IChkaWRDYWxsIHx8IChyZXR1cm5WYWx1ZSA9IGZuKC4uLmFyZ3MpLCBkaWRDYWxsID0gITApLCByZXR1cm5WYWx1ZSk7XG59XG5jb25zdCBjcmVhdGVXYXJuaW5nUHJpbnRlciA9IChtZXNzYWdlKSA9PiAoXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gIG9uY2UoKC4uLmFyZ3MpID0+IGNvbnNvbGUud2FybihtZXNzYWdlLmpvaW4oXCIgXCIpLCAuLi5hcmdzKSlcbiksIHByaW50Q2RuQW5kV2l0aENyZWRlbnRpYWxzV2FybmluZyA9IGNyZWF0ZVdhcm5pbmdQcmludGVyKFtcbiAgXCJCZWNhdXNlIHlvdSBzZXQgYHdpdGhDcmVkZW50aWFsc2AgdG8gdHJ1ZSwgd2Ugd2lsbCBvdmVycmlkZSB5b3VyIGB1c2VDZG5gXCIsXG4gIFwic2V0dGluZyB0byBiZSBmYWxzZSBzaW5jZSAoY29va2llLWJhc2VkKSBjcmVkZW50aWFscyBhcmUgbmV2ZXIgc2V0IG9uIHRoZSBDRE5cIlxuXSksIHByaW50Q2RuV2FybmluZyA9IGNyZWF0ZVdhcm5pbmdQcmludGVyKFtcbiAgXCJTaW5jZSB5b3UgaGF2ZW4ndCBzZXQgYSB2YWx1ZSBmb3IgYHVzZUNkbmAsIHdlIHdpbGwgZGVsaXZlciBjb250ZW50IHVzaW5nIG91clwiLFxuICBcImdsb2JhbCwgZWRnZS1jYWNoZWQgQVBJLUNETi4gSWYgeW91IHdpc2ggdG8gaGF2ZSBjb250ZW50IGRlbGl2ZXJlZCBmYXN0ZXIsIHNldFwiLFxuICBcImB1c2VDZG46IGZhbHNlYCB0byB1c2UgdGhlIExpdmUgQVBJLiBOb3RlOiBZb3UgbWF5IGluY3VyIGhpZ2hlciBjb3N0cyB1c2luZyB0aGUgbGl2ZSBBUEkuXCJcbl0pLCBwcmludENkblByZXZpZXdEcmFmdHNXYXJuaW5nID0gY3JlYXRlV2FybmluZ1ByaW50ZXIoW1xuICBcIlRoZSBTYW5pdHkgY2xpZW50IGlzIGNvbmZpZ3VyZWQgd2l0aCB0aGUgYHBlcnNwZWN0aXZlYCBzZXQgdG8gYHByZXZpZXdEcmFmdHNgLCB3aGljaCBkb2Vzbid0IHN1cHBvcnQgdGhlIEFQSS1DRE4uXCIsXG4gIFwiVGhlIExpdmUgQVBJIHdpbGwgYmUgdXNlZCBpbnN0ZWFkLiBTZXQgYHVzZUNkbjogZmFsc2VgIGluIHlvdXIgY29uZmlndXJhdGlvbiB0byBoaWRlIHRoaXMgd2FybmluZy5cIlxuXSksIHByaW50QnJvd3NlclRva2VuV2FybmluZyA9IGNyZWF0ZVdhcm5pbmdQcmludGVyKFtcbiAgXCJZb3UgaGF2ZSBjb25maWd1cmVkIFNhbml0eSBjbGllbnQgdG8gdXNlIGEgdG9rZW4gaW4gdGhlIGJyb3dzZXIuIFRoaXMgbWF5IGNhdXNlIHVuaW50ZW50aW9uYWwgc2VjdXJpdHkgaXNzdWVzLlwiLFxuICBgU2VlICR7Z2VuZXJhdGVIZWxwVXJsKFxuICAgIFwianMtY2xpZW50LWJyb3dzZXItdG9rZW5cIlxuICApfSBmb3IgbW9yZSBpbmZvcm1hdGlvbiBhbmQgaG93IHRvIGhpZGUgdGhpcyB3YXJuaW5nLmBcbl0pLCBwcmludE5vQXBpVmVyc2lvblNwZWNpZmllZFdhcm5pbmcgPSBjcmVhdGVXYXJuaW5nUHJpbnRlcihbXG4gIFwiVXNpbmcgdGhlIFNhbml0eSBjbGllbnQgd2l0aG91dCBzcGVjaWZ5aW5nIGFuIEFQSSB2ZXJzaW9uIGlzIGRlcHJlY2F0ZWQuXCIsXG4gIGBTZWUgJHtnZW5lcmF0ZUhlbHBVcmwoXCJqcy1jbGllbnQtYXBpLXZlcnNpb25cIil9YFxuXSksIHByaW50Tm9EZWZhdWx0RXhwb3J0ID0gY3JlYXRlV2FybmluZ1ByaW50ZXIoW1xuICBcIlRoZSBkZWZhdWx0IGV4cG9ydCBvZiBAc2FuaXR5L2NsaWVudCBoYXMgYmVlbiBkZXByZWNhdGVkLiBVc2UgdGhlIG5hbWVkIGV4cG9ydCBgY3JlYXRlQ2xpZW50YCBpbnN0ZWFkLlwiXG5dKSwgZGVmYXVsdENkbkhvc3QgPSBcImFwaWNkbi5zYW5pdHkuaW9cIiwgZGVmYXVsdENvbmZpZyA9IHtcbiAgYXBpSG9zdDogXCJodHRwczovL2FwaS5zYW5pdHkuaW9cIixcbiAgYXBpVmVyc2lvbjogXCIxXCIsXG4gIHVzZVByb2plY3RIb3N0bmFtZTogITAsXG4gIHN0ZWdhOiB7IGVuYWJsZWQ6ICExIH1cbn0sIExPQ0FMSE9TVFMgPSBbXCJsb2NhbGhvc3RcIiwgXCIxMjcuMC4wLjFcIiwgXCIwLjAuMC4wXCJdLCBpc0xvY2FsID0gKGhvc3QpID0+IExPQ0FMSE9TVFMuaW5kZXhPZihob3N0KSAhPT0gLTE7XG5mdW5jdGlvbiB2YWxpZGF0ZUFwaVZlcnNpb24oYXBpVmVyc2lvbikge1xuICBpZiAoYXBpVmVyc2lvbiA9PT0gXCIxXCIgfHwgYXBpVmVyc2lvbiA9PT0gXCJYXCIpXG4gICAgcmV0dXJuO1xuICBjb25zdCBhcGlEYXRlID0gbmV3IERhdGUoYXBpVmVyc2lvbik7XG4gIGlmICghKC9eXFxkezR9LVxcZHsyfS1cXGR7Mn0kLy50ZXN0KGFwaVZlcnNpb24pICYmIGFwaURhdGUgaW5zdGFuY2VvZiBEYXRlICYmIGFwaURhdGUuZ2V0VGltZSgpID4gMCkpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBBUEkgdmVyc2lvbiBzdHJpbmcsIGV4cGVjdGVkIGAxYCBvciBkYXRlIGluIGZvcm1hdCBgWVlZWS1NTS1ERGBcIik7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZUFwaVBlcnNwZWN0aXZlKHBlcnNwZWN0aXZlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHBlcnNwZWN0aXZlKSkge1xuICAgIGZvciAoY29uc3QgcGVyc3BlY3RpdmVWYWx1ZSBvZiBwZXJzcGVjdGl2ZSlcbiAgICAgIGlmIChwZXJzcGVjdGl2ZVZhbHVlICE9PSBcInB1Ymxpc2hlZFwiICYmIHBlcnNwZWN0aXZlVmFsdWUgIT09IFwiZHJhZnRzXCIgJiYgISh0eXBlb2YgcGVyc3BlY3RpdmVWYWx1ZSA9PSBcInN0cmluZ1wiICYmIHBlcnNwZWN0aXZlVmFsdWUuc3RhcnRzV2l0aChcInJcIikgJiYgcGVyc3BlY3RpdmVWYWx1ZSAhPT0gXCJyYXdcIikpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgXCJJbnZhbGlkIEFQSSBwZXJzcGVjdGl2ZSB2YWx1ZSwgZXhwZWN0ZWQgYHB1Ymxpc2hlZGAsIGBkcmFmdHNgIG9yIGEgdmFsaWQgcmVsZWFzZSBpZGVudGlmaWVyIHN0cmluZ1wiXG4gICAgICAgICk7XG4gICAgcmV0dXJuO1xuICB9XG4gIHN3aXRjaCAocGVyc3BlY3RpdmUpIHtcbiAgICBjYXNlIFwicHJldmlld0RyYWZ0c1wiOlxuICAgIGNhc2UgXCJkcmFmdHNcIjpcbiAgICBjYXNlIFwicHVibGlzaGVkXCI6XG4gICAgY2FzZSBcInJhd1wiOlxuICAgICAgcmV0dXJuO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICBcIkludmFsaWQgQVBJIHBlcnNwZWN0aXZlIHN0cmluZywgZXhwZWN0ZWQgYHB1Ymxpc2hlZGAsIGBwcmV2aWV3RHJhZnRzYCBvciBgcmF3YFwiXG4gICAgICApO1xuICB9XG59XG5jb25zdCBpbml0Q29uZmlnID0gKGNvbmZpZywgcHJldkNvbmZpZykgPT4ge1xuICBjb25zdCBzcGVjaWZpZWRDb25maWcgPSB7XG4gICAgLi4ucHJldkNvbmZpZyxcbiAgICAuLi5jb25maWcsXG4gICAgc3RlZ2E6IHtcbiAgICAgIC4uLnR5cGVvZiBwcmV2Q29uZmlnLnN0ZWdhID09IFwiYm9vbGVhblwiID8geyBlbmFibGVkOiBwcmV2Q29uZmlnLnN0ZWdhIH0gOiBwcmV2Q29uZmlnLnN0ZWdhIHx8IGRlZmF1bHRDb25maWcuc3RlZ2EsXG4gICAgICAuLi50eXBlb2YgY29uZmlnLnN0ZWdhID09IFwiYm9vbGVhblwiID8geyBlbmFibGVkOiBjb25maWcuc3RlZ2EgfSA6IGNvbmZpZy5zdGVnYSB8fCB7fVxuICAgIH1cbiAgfTtcbiAgc3BlY2lmaWVkQ29uZmlnLmFwaVZlcnNpb24gfHwgcHJpbnROb0FwaVZlcnNpb25TcGVjaWZpZWRXYXJuaW5nKCk7XG4gIGNvbnN0IG5ld0NvbmZpZyA9IHtcbiAgICAuLi5kZWZhdWx0Q29uZmlnLFxuICAgIC4uLnNwZWNpZmllZENvbmZpZ1xuICB9LCBwcm9qZWN0QmFzZWQgPSBuZXdDb25maWcudXNlUHJvamVjdEhvc3RuYW1lO1xuICBpZiAodHlwZW9mIFByb21pc2UgPiBcInVcIikge1xuICAgIGNvbnN0IGhlbHBVcmwgPSBnZW5lcmF0ZUhlbHBVcmwoXCJqcy1jbGllbnQtcHJvbWlzZS1wb2x5ZmlsbFwiKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIG5hdGl2ZSBQcm9taXNlLWltcGxlbWVudGF0aW9uIGZvdW5kLCBwb2x5ZmlsbCBuZWVkZWQgLSBzZWUgJHtoZWxwVXJsfWApO1xuICB9XG4gIGlmIChwcm9qZWN0QmFzZWQgJiYgIW5ld0NvbmZpZy5wcm9qZWN0SWQpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ29uZmlndXJhdGlvbiBtdXN0IGNvbnRhaW4gYHByb2plY3RJZGBcIik7XG4gIGlmICh0eXBlb2YgbmV3Q29uZmlnLnBlcnNwZWN0aXZlIDwgXCJ1XCIgJiYgdmFsaWRhdGVBcGlQZXJzcGVjdGl2ZShuZXdDb25maWcucGVyc3BlY3RpdmUpLCBcImVuY29kZVNvdXJjZU1hcFwiIGluIG5ld0NvbmZpZylcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIkl0IGxvb2tzIGxpa2UgeW91J3JlIHVzaW5nIG9wdGlvbnMgbWVhbnQgZm9yICdAc2FuaXR5L3ByZXZpZXcta2l0L2NsaWVudCcuICdlbmNvZGVTb3VyY2VNYXAnIGlzIG5vdCBzdXBwb3J0ZWQgaW4gJ0BzYW5pdHkvY2xpZW50Jy4gRGlkIHlvdSBtZWFuICdzdGVnYS5lbmFibGVkJz9cIlxuICAgICk7XG4gIGlmIChcImVuY29kZVNvdXJjZU1hcEF0UGF0aFwiIGluIG5ld0NvbmZpZylcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIkl0IGxvb2tzIGxpa2UgeW91J3JlIHVzaW5nIG9wdGlvbnMgbWVhbnQgZm9yICdAc2FuaXR5L3ByZXZpZXcta2l0L2NsaWVudCcuICdlbmNvZGVTb3VyY2VNYXBBdFBhdGgnIGlzIG5vdCBzdXBwb3J0ZWQgaW4gJ0BzYW5pdHkvY2xpZW50Jy4gRGlkIHlvdSBtZWFuICdzdGVnYS5maWx0ZXInP1wiXG4gICAgKTtcbiAgaWYgKHR5cGVvZiBuZXdDb25maWcuc3RlZ2EuZW5hYmxlZCAhPSBcImJvb2xlYW5cIilcbiAgICB0aHJvdyBuZXcgRXJyb3IoYHN0ZWdhLmVuYWJsZWQgbXVzdCBiZSBhIGJvb2xlYW4sIHJlY2VpdmVkICR7bmV3Q29uZmlnLnN0ZWdhLmVuYWJsZWR9YCk7XG4gIGlmIChuZXdDb25maWcuc3RlZ2EuZW5hYmxlZCAmJiBuZXdDb25maWcuc3RlZ2Euc3R1ZGlvVXJsID09PSB2b2lkIDApXG4gICAgdGhyb3cgbmV3IEVycm9yKFwic3RlZ2Euc3R1ZGlvVXJsIG11c3QgYmUgZGVmaW5lZCB3aGVuIHN0ZWdhLmVuYWJsZWQgaXMgdHJ1ZVwiKTtcbiAgaWYgKG5ld0NvbmZpZy5zdGVnYS5lbmFibGVkICYmIHR5cGVvZiBuZXdDb25maWcuc3RlZ2Euc3R1ZGlvVXJsICE9IFwic3RyaW5nXCIgJiYgdHlwZW9mIG5ld0NvbmZpZy5zdGVnYS5zdHVkaW9VcmwgIT0gXCJmdW5jdGlvblwiKVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBzdGVnYS5zdHVkaW9VcmwgbXVzdCBiZSBhIHN0cmluZyBvciBhIGZ1bmN0aW9uLCByZWNlaXZlZCAke25ld0NvbmZpZy5zdGVnYS5zdHVkaW9Vcmx9YFxuICAgICk7XG4gIGNvbnN0IGlzQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgPCBcInVcIiAmJiB3aW5kb3cubG9jYXRpb24gJiYgd2luZG93LmxvY2F0aW9uLmhvc3RuYW1lLCBpc0xvY2FsaG9zdCA9IGlzQnJvd3NlciAmJiBpc0xvY2FsKHdpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZSk7XG4gIGlzQnJvd3NlciAmJiBpc0xvY2FsaG9zdCAmJiBuZXdDb25maWcudG9rZW4gJiYgbmV3Q29uZmlnLmlnbm9yZUJyb3dzZXJUb2tlbldhcm5pbmcgIT09ICEwID8gcHJpbnRCcm93c2VyVG9rZW5XYXJuaW5nKCkgOiB0eXBlb2YgbmV3Q29uZmlnLnVzZUNkbiA+IFwidVwiICYmIHByaW50Q2RuV2FybmluZygpLCBwcm9qZWN0QmFzZWQgJiYgcHJvamVjdElkKG5ld0NvbmZpZy5wcm9qZWN0SWQpLCBuZXdDb25maWcuZGF0YXNldCAmJiBkYXRhc2V0KG5ld0NvbmZpZy5kYXRhc2V0KSwgXCJyZXF1ZXN0VGFnUHJlZml4XCIgaW4gbmV3Q29uZmlnICYmIChuZXdDb25maWcucmVxdWVzdFRhZ1ByZWZpeCA9IG5ld0NvbmZpZy5yZXF1ZXN0VGFnUHJlZml4ID8gcmVxdWVzdFRhZyhuZXdDb25maWcucmVxdWVzdFRhZ1ByZWZpeCkucmVwbGFjZSgvXFwuKyQvLCBcIlwiKSA6IHZvaWQgMCksIG5ld0NvbmZpZy5hcGlWZXJzaW9uID0gYCR7bmV3Q29uZmlnLmFwaVZlcnNpb259YC5yZXBsYWNlKC9edi8sIFwiXCIpLCBuZXdDb25maWcuaXNEZWZhdWx0QXBpID0gbmV3Q29uZmlnLmFwaUhvc3QgPT09IGRlZmF1bHRDb25maWcuYXBpSG9zdCwgbmV3Q29uZmlnLnVzZUNkbiA9PT0gITAgJiYgbmV3Q29uZmlnLndpdGhDcmVkZW50aWFscyAmJiBwcmludENkbkFuZFdpdGhDcmVkZW50aWFsc1dhcm5pbmcoKSwgbmV3Q29uZmlnLnVzZUNkbiA9IG5ld0NvbmZpZy51c2VDZG4gIT09ICExICYmICFuZXdDb25maWcud2l0aENyZWRlbnRpYWxzLCB2YWxpZGF0ZUFwaVZlcnNpb24obmV3Q29uZmlnLmFwaVZlcnNpb24pO1xuICBjb25zdCBob3N0UGFydHMgPSBuZXdDb25maWcuYXBpSG9zdC5zcGxpdChcIjovL1wiLCAyKSwgcHJvdG9jb2wgPSBob3N0UGFydHNbMF0sIGhvc3QgPSBob3N0UGFydHNbMV0sIGNkbkhvc3QgPSBuZXdDb25maWcuaXNEZWZhdWx0QXBpID8gZGVmYXVsdENkbkhvc3QgOiBob3N0O1xuICByZXR1cm4gbmV3Q29uZmlnLnVzZVByb2plY3RIb3N0bmFtZSA/IChuZXdDb25maWcudXJsID0gYCR7cHJvdG9jb2x9Oi8vJHtuZXdDb25maWcucHJvamVjdElkfS4ke2hvc3R9L3Yke25ld0NvbmZpZy5hcGlWZXJzaW9ufWAsIG5ld0NvbmZpZy5jZG5VcmwgPSBgJHtwcm90b2NvbH06Ly8ke25ld0NvbmZpZy5wcm9qZWN0SWR9LiR7Y2RuSG9zdH0vdiR7bmV3Q29uZmlnLmFwaVZlcnNpb259YCkgOiAobmV3Q29uZmlnLnVybCA9IGAke25ld0NvbmZpZy5hcGlIb3N0fS92JHtuZXdDb25maWcuYXBpVmVyc2lvbn1gLCBuZXdDb25maWcuY2RuVXJsID0gbmV3Q29uZmlnLnVybCksIG5ld0NvbmZpZztcbn07XG5leHBvcnQge1xuICBkYXRhc2V0LFxuICBkZWZhdWx0Q29uZmlnLFxuICBoYXNEYXRhc2V0LFxuICBpbml0Q29uZmlnLFxuICBwcmludENkblByZXZpZXdEcmFmdHNXYXJuaW5nLFxuICBwcmludE5vRGVmYXVsdEV4cG9ydCxcbiAgcmVxdWVzdFRhZyxcbiAgcmVxdWlyZURvY3VtZW50SWQsXG4gIHZhbGlkYXRlQXBpUGVyc3BlY3RpdmUsXG4gIHZhbGlkYXRlQXNzZXRUeXBlLFxuICB2YWxpZGF0ZURvY3VtZW50SWQsXG4gIHZhbGlkYXRlSW5zZXJ0LFxuICB2YWxpZGF0ZU9iamVjdFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbmZpZy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sanity/client/dist/_chunks-es/config.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@sanity/client/dist/_chunks-es/stegaClean.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@sanity/client/dist/_chunks-es/stegaClean.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   C: () => (/* binding */ C),\n/* harmony export */   stegaClean: () => (/* binding */ stegaClean),\n/* harmony export */   vercelStegaCleanAll: () => (/* binding */ vercelStegaCleanAll)\n/* harmony export */ });\nvar s = { 0: 8203, 1: 8204, 2: 8205, 3: 8290, 4: 8291, 5: 8288, 6: 65279, 7: 8289, 8: 119155, 9: 119156, a: 119157, b: 119158, c: 119159, d: 119160, e: 119161, f: 119162 }, c = { 0: 8203, 1: 8204, 2: 8205, 3: 65279 }, u = new Array(4).fill(String.fromCodePoint(c[0])).join(\"\");\nfunction E(t) {\n  let e = JSON.stringify(t);\n  return `${u}${Array.from(e).map((r) => {\n    let n = r.charCodeAt(0);\n    if (n > 255) throw new Error(`Only ASCII edit info can be encoded. Error attempting to encode ${e} on character ${r} (${n})`);\n    return Array.from(n.toString(4).padStart(4, \"0\")).map((o) => String.fromCodePoint(c[o])).join(\"\");\n  }).join(\"\")}`;\n}\nfunction I(t) {\n  return !Number.isNaN(Number(t)) || /[a-z]/i.test(t) && !/\\d+(?:[-:\\/]\\d+){2}(?:T\\d+(?:[-:\\/]\\d+){1,2}(\\.\\d+)?Z?)?/.test(t) ? !1 : !!Date.parse(t);\n}\nfunction T(t) {\n  try {\n    new URL(t, t.startsWith(\"/\") ? \"https://acme.com\" : void 0);\n  } catch {\n    return !1;\n  }\n  return !0;\n}\nfunction C(t, e, r = \"auto\") {\n  return r === !0 || r === \"auto\" && (I(t) || T(t)) ? t : `${t}${E(e)}`;\n}\nObject.fromEntries(Object.entries(c).map((t) => t.reverse()));\nObject.fromEntries(Object.entries(s).map((t) => t.reverse()));\nvar S = `${Object.values(s).map((t) => `\\\\u{${t.toString(16)}}`).join(\"\")}`, f = new RegExp(`[${S}]{4,}`, \"gu\");\nfunction _(t) {\n  var e;\n  return { cleaned: t.replace(f, \"\"), encoded: ((e = t.match(f)) == null ? void 0 : e[0]) || \"\" };\n}\nfunction O(t) {\n  return t && JSON.parse(_(JSON.stringify(t)).cleaned);\n}\nfunction stegaClean(result) {\n  return O(result);\n}\nconst vercelStegaCleanAll = stegaClean;\n\n//# sourceMappingURL=stegaClean.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNhbml0eS9jbGllbnQvZGlzdC9fY2h1bmtzLWVzL3N0ZWdhQ2xlYW4uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsVUFBVSxpS0FBaUssUUFBUSxxQ0FBcUM7QUFDeE47QUFDQTtBQUNBLFlBQVksRUFBRSxFQUFFO0FBQ2hCO0FBQ0Esb0dBQW9HLEdBQUcsZUFBZSxHQUFHLEdBQUcsRUFBRTtBQUM5SDtBQUNBLEdBQUcsV0FBVztBQUNkO0FBQ0E7QUFDQSw0RUFBNEUsRUFBRSxxQkFBcUIsSUFBSTtBQUN2RztBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELEVBQUUsRUFBRSxLQUFLO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUNBQWlDLEVBQUUsZ0JBQWdCLFlBQVksc0JBQXNCLEVBQUUsRUFBRSxHQUFHO0FBQ3ZHO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtFO0FBQ0YiLCJzb3VyY2VzIjpbIkc6XFxNeSBDYXJlZXJcXFdFQiBBTkQgTU9CSUxFIEFQUCBERVZFTE9QRU1FTlQgIChIVE1MLENTUywgSlMgKVxcRnJvbnQtRW5kIERldmVsb3BlbWVudFxcRmluYWwgUHJvamVjdFxcRnJvbnRlbmRcXG5vZGVfbW9kdWxlc1xcQHNhbml0eVxcY2xpZW50XFxkaXN0XFxfY2h1bmtzLWVzXFxzdGVnYUNsZWFuLmpzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBzID0geyAwOiA4MjAzLCAxOiA4MjA0LCAyOiA4MjA1LCAzOiA4MjkwLCA0OiA4MjkxLCA1OiA4Mjg4LCA2OiA2NTI3OSwgNzogODI4OSwgODogMTE5MTU1LCA5OiAxMTkxNTYsIGE6IDExOTE1NywgYjogMTE5MTU4LCBjOiAxMTkxNTksIGQ6IDExOTE2MCwgZTogMTE5MTYxLCBmOiAxMTkxNjIgfSwgYyA9IHsgMDogODIwMywgMTogODIwNCwgMjogODIwNSwgMzogNjUyNzkgfSwgdSA9IG5ldyBBcnJheSg0KS5maWxsKFN0cmluZy5mcm9tQ29kZVBvaW50KGNbMF0pKS5qb2luKFwiXCIpO1xuZnVuY3Rpb24gRSh0KSB7XG4gIGxldCBlID0gSlNPTi5zdHJpbmdpZnkodCk7XG4gIHJldHVybiBgJHt1fSR7QXJyYXkuZnJvbShlKS5tYXAoKHIpID0+IHtcbiAgICBsZXQgbiA9IHIuY2hhckNvZGVBdCgwKTtcbiAgICBpZiAobiA+IDI1NSkgdGhyb3cgbmV3IEVycm9yKGBPbmx5IEFTQ0lJIGVkaXQgaW5mbyBjYW4gYmUgZW5jb2RlZC4gRXJyb3IgYXR0ZW1wdGluZyB0byBlbmNvZGUgJHtlfSBvbiBjaGFyYWN0ZXIgJHtyfSAoJHtufSlgKTtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShuLnRvU3RyaW5nKDQpLnBhZFN0YXJ0KDQsIFwiMFwiKSkubWFwKChvKSA9PiBTdHJpbmcuZnJvbUNvZGVQb2ludChjW29dKSkuam9pbihcIlwiKTtcbiAgfSkuam9pbihcIlwiKX1gO1xufVxuZnVuY3Rpb24gSSh0KSB7XG4gIHJldHVybiAhTnVtYmVyLmlzTmFOKE51bWJlcih0KSkgfHwgL1thLXpdL2kudGVzdCh0KSAmJiAhL1xcZCsoPzpbLTpcXC9dXFxkKyl7Mn0oPzpUXFxkKyg/OlstOlxcL11cXGQrKXsxLDJ9KFxcLlxcZCspP1o/KT8vLnRlc3QodCkgPyAhMSA6ICEhRGF0ZS5wYXJzZSh0KTtcbn1cbmZ1bmN0aW9uIFQodCkge1xuICB0cnkge1xuICAgIG5ldyBVUkwodCwgdC5zdGFydHNXaXRoKFwiL1wiKSA/IFwiaHR0cHM6Ly9hY21lLmNvbVwiIDogdm9pZCAwKTtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuICExO1xuICB9XG4gIHJldHVybiAhMDtcbn1cbmZ1bmN0aW9uIEModCwgZSwgciA9IFwiYXV0b1wiKSB7XG4gIHJldHVybiByID09PSAhMCB8fCByID09PSBcImF1dG9cIiAmJiAoSSh0KSB8fCBUKHQpKSA/IHQgOiBgJHt0fSR7RShlKX1gO1xufVxuT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKGMpLm1hcCgodCkgPT4gdC5yZXZlcnNlKCkpKTtcbk9iamVjdC5mcm9tRW50cmllcyhPYmplY3QuZW50cmllcyhzKS5tYXAoKHQpID0+IHQucmV2ZXJzZSgpKSk7XG52YXIgUyA9IGAke09iamVjdC52YWx1ZXMocykubWFwKCh0KSA9PiBgXFxcXHV7JHt0LnRvU3RyaW5nKDE2KX19YCkuam9pbihcIlwiKX1gLCBmID0gbmV3IFJlZ0V4cChgWyR7U31dezQsfWAsIFwiZ3VcIik7XG5mdW5jdGlvbiBfKHQpIHtcbiAgdmFyIGU7XG4gIHJldHVybiB7IGNsZWFuZWQ6IHQucmVwbGFjZShmLCBcIlwiKSwgZW5jb2RlZDogKChlID0gdC5tYXRjaChmKSkgPT0gbnVsbCA/IHZvaWQgMCA6IGVbMF0pIHx8IFwiXCIgfTtcbn1cbmZ1bmN0aW9uIE8odCkge1xuICByZXR1cm4gdCAmJiBKU09OLnBhcnNlKF8oSlNPTi5zdHJpbmdpZnkodCkpLmNsZWFuZWQpO1xufVxuZnVuY3Rpb24gc3RlZ2FDbGVhbihyZXN1bHQpIHtcbiAgcmV0dXJuIE8ocmVzdWx0KTtcbn1cbmNvbnN0IHZlcmNlbFN0ZWdhQ2xlYW5BbGwgPSBzdGVnYUNsZWFuO1xuZXhwb3J0IHtcbiAgQyxcbiAgc3RlZ2FDbGVhbixcbiAgdmVyY2VsU3RlZ2FDbGVhbkFsbFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0ZWdhQ2xlYW4uanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sanity/client/dist/_chunks-es/stegaClean.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@sanity/client/dist/_chunks-es/stegaEncodeSourceMap.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@sanity/client/dist/_chunks-es/stegaEncodeSourceMap.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   encodeIntoResult: () => (/* binding */ encodeIntoResult),\n/* harmony export */   stegaEncodeSourceMap: () => (/* binding */ stegaEncodeSourceMap),\n/* harmony export */   stegaEncodeSourceMap$1: () => (/* binding */ stegaEncodeSourceMap$1)\n/* harmony export */ });\n/* harmony import */ var _stegaClean_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./stegaClean.js */ \"(ssr)/./node_modules/@sanity/client/dist/_chunks-es/stegaClean.js\");\n\nconst reKeySegment = /_key\\s*==\\s*['\"](.*)['\"]/;\nfunction isKeySegment(segment) {\n  return typeof segment == \"string\" ? reKeySegment.test(segment.trim()) : typeof segment == \"object\" && \"_key\" in segment;\n}\nfunction toString(path) {\n  if (!Array.isArray(path))\n    throw new Error(\"Path is not an array\");\n  return path.reduce((target, segment, i) => {\n    const segmentType = typeof segment;\n    if (segmentType === \"number\")\n      return `${target}[${segment}]`;\n    if (segmentType === \"string\")\n      return `${target}${i === 0 ? \"\" : \".\"}${segment}`;\n    if (isKeySegment(segment) && segment._key)\n      return `${target}[_key==\"${segment._key}\"]`;\n    if (Array.isArray(segment)) {\n      const [from, to] = segment;\n      return `${target}[${from}:${to}]`;\n    }\n    throw new Error(`Unsupported path segment \\`${JSON.stringify(segment)}\\``);\n  }, \"\");\n}\nconst ESCAPE = {\n  \"\\f\": \"\\\\f\",\n  \"\\n\": \"\\\\n\",\n  \"\\r\": \"\\\\r\",\n  \"\t\": \"\\\\t\",\n  \"'\": \"\\\\'\",\n  \"\\\\\": \"\\\\\\\\\"\n}, UNESCAPE = {\n  \"\\\\f\": \"\\f\",\n  \"\\\\n\": `\n`,\n  \"\\\\r\": \"\\r\",\n  \"\\\\t\": \"\t\",\n  \"\\\\'\": \"'\",\n  \"\\\\\\\\\": \"\\\\\"\n};\nfunction jsonPath(path) {\n  return `$${path.map((segment) => typeof segment == \"string\" ? `['${segment.replace(/[\\f\\n\\r\\t'\\\\]/g, (match) => ESCAPE[match])}']` : typeof segment == \"number\" ? `[${segment}]` : segment._key !== \"\" ? `[?(@._key=='${segment._key.replace(/['\\\\]/g, (match) => ESCAPE[match])}')]` : `[${segment._index}]`).join(\"\")}`;\n}\nfunction parseJsonPath(path) {\n  const parsed = [], parseRe = /\\['(.*?)'\\]|\\[(\\d+)\\]|\\[\\?\\(@\\._key=='(.*?)'\\)\\]/g;\n  let match;\n  for (; (match = parseRe.exec(path)) !== null; ) {\n    if (match[1] !== void 0) {\n      const key = match[1].replace(/\\\\(\\\\|f|n|r|t|')/g, (m) => UNESCAPE[m]);\n      parsed.push(key);\n      continue;\n    }\n    if (match[2] !== void 0) {\n      parsed.push(parseInt(match[2], 10));\n      continue;\n    }\n    if (match[3] !== void 0) {\n      const _key = match[3].replace(/\\\\(\\\\')/g, (m) => UNESCAPE[m]);\n      parsed.push({\n        _key,\n        _index: -1\n      });\n      continue;\n    }\n  }\n  return parsed;\n}\nfunction jsonPathToStudioPath(path) {\n  return path.map((segment) => {\n    if (typeof segment == \"string\" || typeof segment == \"number\")\n      return segment;\n    if (segment._key !== \"\")\n      return { _key: segment._key };\n    if (segment._index !== -1)\n      return segment._index;\n    throw new Error(`invalid segment:${JSON.stringify(segment)}`);\n  });\n}\nfunction jsonPathToMappingPath(path) {\n  return path.map((segment) => {\n    if (typeof segment == \"string\" || typeof segment == \"number\")\n      return segment;\n    if (segment._index !== -1)\n      return segment._index;\n    throw new Error(`invalid segment:${JSON.stringify(segment)}`);\n  });\n}\nfunction resolveMapping(resultPath, csm) {\n  if (!csm?.mappings)\n    return;\n  const resultMappingPath = jsonPath(jsonPathToMappingPath(resultPath));\n  if (csm.mappings[resultMappingPath] !== void 0)\n    return {\n      mapping: csm.mappings[resultMappingPath],\n      matchedPath: resultMappingPath,\n      pathSuffix: \"\"\n    };\n  const mappings = Object.entries(csm.mappings).filter(([key]) => resultMappingPath.startsWith(key)).sort(([key1], [key2]) => key2.length - key1.length);\n  if (mappings.length == 0)\n    return;\n  const [matchedPath, mapping] = mappings[0], pathSuffix = resultMappingPath.substring(matchedPath.length);\n  return { mapping, matchedPath, pathSuffix };\n}\nfunction isArray(value) {\n  return value !== null && Array.isArray(value);\n}\nfunction isRecord(value) {\n  return typeof value == \"object\" && value !== null;\n}\nfunction walkMap(value, mappingFn, path = []) {\n  if (isArray(value))\n    return value.map((v, idx) => {\n      if (isRecord(v)) {\n        const _key = v._key;\n        if (typeof _key == \"string\")\n          return walkMap(v, mappingFn, path.concat({ _key, _index: idx }));\n      }\n      return walkMap(v, mappingFn, path.concat(idx));\n    });\n  if (isRecord(value)) {\n    if (value._type === \"block\" || value._type === \"span\") {\n      const result = { ...value };\n      return value._type === \"block\" ? result.children = walkMap(value.children, mappingFn, path.concat(\"children\")) : value._type === \"span\" && (result.text = walkMap(value.text, mappingFn, path.concat(\"text\"))), result;\n    }\n    return Object.fromEntries(\n      Object.entries(value).map(([k, v]) => [k, walkMap(v, mappingFn, path.concat(k))])\n    );\n  }\n  return mappingFn(value, path);\n}\nfunction encodeIntoResult(result, csm, encoder) {\n  return walkMap(result, (value, path) => {\n    if (typeof value != \"string\")\n      return value;\n    const resolveMappingResult = resolveMapping(path, csm);\n    if (!resolveMappingResult)\n      return value;\n    const { mapping, matchedPath } = resolveMappingResult;\n    if (mapping.type !== \"value\" || mapping.source.type !== \"documentValue\")\n      return value;\n    const sourceDocument = csm.documents[mapping.source.document], sourcePath = csm.paths[mapping.source.path], matchPathSegments = parseJsonPath(matchedPath), fullSourceSegments = parseJsonPath(sourcePath).concat(path.slice(matchPathSegments.length));\n    return encoder({\n      sourcePath: fullSourceSegments,\n      sourceDocument,\n      resultPath: path,\n      value\n    });\n  });\n}\nconst DRAFTS_FOLDER = \"drafts\", VERSION_FOLDER = \"versions\", PATH_SEPARATOR = \".\", DRAFTS_PREFIX = `${DRAFTS_FOLDER}${PATH_SEPARATOR}`, VERSION_PREFIX = `${VERSION_FOLDER}${PATH_SEPARATOR}`;\nfunction isDraftId(id) {\n  return id.startsWith(DRAFTS_PREFIX);\n}\nfunction isVersionId(id) {\n  return id.startsWith(VERSION_PREFIX);\n}\nfunction isPublishedId(id) {\n  return !isDraftId(id) && !isVersionId(id);\n}\nfunction getVersionFromId(id) {\n  if (!isVersionId(id)) return;\n  const [_versionPrefix, versionId, ..._publishedId] = id.split(PATH_SEPARATOR);\n  return versionId;\n}\nfunction getPublishedId(id) {\n  return isVersionId(id) ? id.split(PATH_SEPARATOR).slice(2).join(PATH_SEPARATOR) : isDraftId(id) ? id.slice(DRAFTS_PREFIX.length) : id;\n}\nfunction createEditUrl(options) {\n  const {\n    baseUrl,\n    workspace: _workspace = \"default\",\n    tool: _tool = \"default\",\n    id: _id,\n    type,\n    path,\n    projectId,\n    dataset\n  } = options;\n  if (!baseUrl)\n    throw new Error(\"baseUrl is required\");\n  if (!path)\n    throw new Error(\"path is required\");\n  if (!_id)\n    throw new Error(\"id is required\");\n  if (baseUrl !== \"/\" && baseUrl.endsWith(\"/\"))\n    throw new Error(\"baseUrl must not end with a slash\");\n  const workspace = _workspace === \"default\" ? void 0 : _workspace, tool = _tool === \"default\" ? void 0 : _tool, id = getPublishedId(_id), stringifiedPath = Array.isArray(path) ? toString(jsonPathToStudioPath(path)) : path, searchParams = new URLSearchParams({\n    baseUrl,\n    id,\n    type,\n    path: stringifiedPath\n  });\n  if (workspace && searchParams.set(\"workspace\", workspace), tool && searchParams.set(\"tool\", tool), projectId && searchParams.set(\"projectId\", projectId), dataset && searchParams.set(\"dataset\", dataset), isPublishedId(_id))\n    searchParams.set(\"perspective\", \"published\");\n  else if (isVersionId(_id)) {\n    const versionId = getVersionFromId(_id);\n    searchParams.set(\"perspective\", versionId);\n  }\n  const segments = [baseUrl === \"/\" ? \"\" : baseUrl];\n  workspace && segments.push(workspace);\n  const routerParams = [\n    \"mode=presentation\",\n    `id=${id}`,\n    `type=${type}`,\n    `path=${encodeURIComponent(stringifiedPath)}`\n  ];\n  return tool && routerParams.push(`tool=${tool}`), segments.push(\"intent\", \"edit\", `${routerParams.join(\";\")}?${searchParams}`), segments.join(\"/\");\n}\nfunction resolveStudioBaseRoute(studioUrl) {\n  let baseUrl = typeof studioUrl == \"string\" ? studioUrl : studioUrl.baseUrl;\n  return baseUrl !== \"/\" && (baseUrl = baseUrl.replace(/\\/$/, \"\")), typeof studioUrl == \"string\" ? { baseUrl } : { ...studioUrl, baseUrl };\n}\nconst filterDefault = ({ sourcePath, resultPath, value }) => {\n  if (isValidDate(value) || isValidURL(value))\n    return !1;\n  const endPath = sourcePath.at(-1);\n  return !(sourcePath.at(-2) === \"slug\" && endPath === \"current\" || typeof endPath == \"string\" && (endPath.startsWith(\"_\") || endPath.endsWith(\"Id\")) || sourcePath.some(\n    (path) => path === \"meta\" || path === \"metadata\" || path === \"openGraph\" || path === \"seo\"\n  ) || hasTypeLike(sourcePath) || hasTypeLike(resultPath) || typeof endPath == \"string\" && denylist.has(endPath));\n}, denylist = /* @__PURE__ */ new Set([\n  \"color\",\n  \"colour\",\n  \"currency\",\n  \"email\",\n  \"format\",\n  \"gid\",\n  \"hex\",\n  \"href\",\n  \"hsl\",\n  \"hsla\",\n  \"icon\",\n  \"id\",\n  \"index\",\n  \"key\",\n  \"language\",\n  \"layout\",\n  \"link\",\n  \"linkAction\",\n  \"locale\",\n  \"lqip\",\n  \"page\",\n  \"path\",\n  \"ref\",\n  \"rgb\",\n  \"rgba\",\n  \"route\",\n  \"secret\",\n  \"slug\",\n  \"status\",\n  \"tag\",\n  \"template\",\n  \"theme\",\n  \"type\",\n  \"textTheme\",\n  \"unit\",\n  \"url\",\n  \"username\",\n  \"variant\",\n  \"website\"\n]);\nfunction isValidDate(dateString) {\n  return /^\\d{4}-\\d{2}-\\d{2}/.test(dateString) ? !!Date.parse(dateString) : !1;\n}\nfunction isValidURL(url) {\n  try {\n    new URL(url, url.startsWith(\"/\") ? \"https://acme.com\" : void 0);\n  } catch {\n    return !1;\n  }\n  return !0;\n}\nfunction hasTypeLike(path) {\n  return path.some((segment) => typeof segment == \"string\" && segment.match(/type/i) !== null);\n}\nconst TRUNCATE_LENGTH = 20;\nfunction stegaEncodeSourceMap(result, resultSourceMap, config) {\n  const { filter, logger, enabled } = config;\n  if (!enabled) {\n    const msg = \"config.enabled must be true, don't call this function otherwise\";\n    throw logger?.error?.(`[@sanity/client]: ${msg}`, { result, resultSourceMap, config }), new TypeError(msg);\n  }\n  if (!resultSourceMap)\n    return logger?.error?.(\"[@sanity/client]: Missing Content Source Map from response body\", {\n      result,\n      resultSourceMap,\n      config\n    }), result;\n  if (!config.studioUrl) {\n    const msg = \"config.studioUrl must be defined\";\n    throw logger?.error?.(`[@sanity/client]: ${msg}`, { result, resultSourceMap, config }), new TypeError(msg);\n  }\n  const report = {\n    encoded: [],\n    skipped: []\n  }, resultWithStega = encodeIntoResult(\n    result,\n    resultSourceMap,\n    ({ sourcePath, sourceDocument, resultPath, value }) => {\n      if ((typeof filter == \"function\" ? filter({ sourcePath, resultPath, filterDefault, sourceDocument, value }) : filterDefault({ sourcePath, resultPath, filterDefault, sourceDocument, value })) === !1)\n        return logger && report.skipped.push({\n          path: prettyPathForLogging(sourcePath),\n          value: `${value.slice(0, TRUNCATE_LENGTH)}${value.length > TRUNCATE_LENGTH ? \"...\" : \"\"}`,\n          length: value.length\n        }), value;\n      logger && report.encoded.push({\n        path: prettyPathForLogging(sourcePath),\n        value: `${value.slice(0, TRUNCATE_LENGTH)}${value.length > TRUNCATE_LENGTH ? \"...\" : \"\"}`,\n        length: value.length\n      });\n      const { baseUrl, workspace, tool } = resolveStudioBaseRoute(\n        typeof config.studioUrl == \"function\" ? config.studioUrl(sourceDocument) : config.studioUrl\n      );\n      if (!baseUrl) return value;\n      const { _id: id, _type: type, _projectId: projectId, _dataset: dataset } = sourceDocument;\n      return (0,_stegaClean_js__WEBPACK_IMPORTED_MODULE_0__.C)(\n        value,\n        {\n          origin: \"sanity.io\",\n          href: createEditUrl({\n            baseUrl,\n            workspace,\n            tool,\n            id,\n            type,\n            path: sourcePath,\n            ...!config.omitCrossDatasetReferenceData && { dataset, projectId }\n          })\n        },\n        // We use custom logic to determine if we should skip encoding\n        !1\n      );\n    }\n  );\n  if (logger) {\n    const isSkipping = report.skipped.length, isEncoding = report.encoded.length;\n    if ((isSkipping || isEncoding) && ((logger?.groupCollapsed || logger.log)?.(\"[@sanity/client]: Encoding source map into result\"), logger.log?.(\n      `[@sanity/client]: Paths encoded: ${report.encoded.length}, skipped: ${report.skipped.length}`\n    )), report.encoded.length > 0 && (logger?.log?.(\"[@sanity/client]: Table of encoded paths\"), (logger?.table || logger.log)?.(report.encoded)), report.skipped.length > 0) {\n      const skipped = /* @__PURE__ */ new Set();\n      for (const { path } of report.skipped)\n        skipped.add(path.replace(reKeySegment, \"0\").replace(/\\[\\d+\\]/g, \"[]\"));\n      logger?.log?.(\"[@sanity/client]: List of skipped paths\", [...skipped.values()]);\n    }\n    (isSkipping || isEncoding) && logger?.groupEnd?.();\n  }\n  return resultWithStega;\n}\nfunction prettyPathForLogging(path) {\n  return toString(jsonPathToStudioPath(path));\n}\nvar stegaEncodeSourceMap$1 = /* @__PURE__ */ Object.freeze({\n  __proto__: null,\n  stegaEncodeSourceMap\n});\n\n//# sourceMappingURL=stegaEncodeSourceMap.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNhbml0eS9jbGllbnQvZGlzdC9fY2h1bmtzLWVzL3N0ZWdhRW5jb2RlU291cmNlTWFwLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTyxHQUFHLFFBQVE7QUFDbEM7QUFDQSxnQkFBZ0IsT0FBTyxFQUFFLG1CQUFtQixFQUFFLFFBQVE7QUFDdEQ7QUFDQSxnQkFBZ0IsT0FBTyxVQUFVLGFBQWE7QUFDOUM7QUFDQTtBQUNBLGdCQUFnQixPQUFPLEdBQUcsS0FBSyxHQUFHLEdBQUc7QUFDckM7QUFDQSxrREFBa0Qsd0JBQXdCO0FBQzFFLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsd0RBQXdELDREQUE0RCx1Q0FBdUMsUUFBUSwwQ0FBMEMseURBQXlELFdBQVcsZUFBZSxhQUFhO0FBQzFUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyx1Q0FBdUM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EsdUNBQXVDLHdCQUF3QjtBQUMvRCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsd0JBQXdCO0FBQy9ELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFD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b3VyY2VzIjpbIkc6XFxNeSBDYXJlZXJcXFdFQiBBTkQgTU9CSUxFIEFQUCBERVZFTE9QRU1FTlQgIChIVE1MLENTUywgSlMgKVxcRnJvbnQtRW5kIERldmVsb3BlbWVudFxcRmluYWwgUHJvamVjdFxcRnJvbnRlbmRcXG5vZGVfbW9kdWxlc1xcQHNhbml0eVxcY2xpZW50XFxkaXN0XFxfY2h1bmtzLWVzXFxzdGVnYUVuY29kZVNvdXJjZU1hcC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDIH0gZnJvbSBcIi4vc3RlZ2FDbGVhbi5qc1wiO1xuY29uc3QgcmVLZXlTZWdtZW50ID0gL19rZXlcXHMqPT1cXHMqWydcIl0oLiopWydcIl0vO1xuZnVuY3Rpb24gaXNLZXlTZWdtZW50KHNlZ21lbnQpIHtcbiAgcmV0dXJuIHR5cGVvZiBzZWdtZW50ID09IFwic3RyaW5nXCIgPyByZUtleVNlZ21lbnQudGVzdChzZWdtZW50LnRyaW0oKSkgOiB0eXBlb2Ygc2VnbWVudCA9PSBcIm9iamVjdFwiICYmIFwiX2tleVwiIGluIHNlZ21lbnQ7XG59XG5mdW5jdGlvbiB0b1N0cmluZyhwYXRoKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShwYXRoKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYXRoIGlzIG5vdCBhbiBhcnJheVwiKTtcbiAgcmV0dXJuIHBhdGgucmVkdWNlKCh0YXJnZXQsIHNlZ21lbnQsIGkpID0+IHtcbiAgICBjb25zdCBzZWdtZW50VHlwZSA9IHR5cGVvZiBzZWdtZW50O1xuICAgIGlmIChzZWdtZW50VHlwZSA9PT0gXCJudW1iZXJcIilcbiAgICAgIHJldHVybiBgJHt0YXJnZXR9WyR7c2VnbWVudH1dYDtcbiAgICBpZiAoc2VnbWVudFR5cGUgPT09IFwic3RyaW5nXCIpXG4gICAgICByZXR1cm4gYCR7dGFyZ2V0fSR7aSA9PT0gMCA/IFwiXCIgOiBcIi5cIn0ke3NlZ21lbnR9YDtcbiAgICBpZiAoaXNLZXlTZWdtZW50KHNlZ21lbnQpICYmIHNlZ21lbnQuX2tleSlcbiAgICAgIHJldHVybiBgJHt0YXJnZXR9W19rZXk9PVwiJHtzZWdtZW50Ll9rZXl9XCJdYDtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShzZWdtZW50KSkge1xuICAgICAgY29uc3QgW2Zyb20sIHRvXSA9IHNlZ21lbnQ7XG4gICAgICByZXR1cm4gYCR7dGFyZ2V0fVske2Zyb219OiR7dG99XWA7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgcGF0aCBzZWdtZW50IFxcYCR7SlNPTi5zdHJpbmdpZnkoc2VnbWVudCl9XFxgYCk7XG4gIH0sIFwiXCIpO1xufVxuY29uc3QgRVNDQVBFID0ge1xuICBcIlxcZlwiOiBcIlxcXFxmXCIsXG4gIFwiXFxuXCI6IFwiXFxcXG5cIixcbiAgXCJcXHJcIjogXCJcXFxcclwiLFxuICBcIlx0XCI6IFwiXFxcXHRcIixcbiAgXCInXCI6IFwiXFxcXCdcIixcbiAgXCJcXFxcXCI6IFwiXFxcXFxcXFxcIlxufSwgVU5FU0NBUEUgPSB7XG4gIFwiXFxcXGZcIjogXCJcXGZcIixcbiAgXCJcXFxcblwiOiBgXG5gLFxuICBcIlxcXFxyXCI6IFwiXFxyXCIsXG4gIFwiXFxcXHRcIjogXCJcdFwiLFxuICBcIlxcXFwnXCI6IFwiJ1wiLFxuICBcIlxcXFxcXFxcXCI6IFwiXFxcXFwiXG59O1xuZnVuY3Rpb24ganNvblBhdGgocGF0aCkge1xuICByZXR1cm4gYCQke3BhdGgubWFwKChzZWdtZW50KSA9PiB0eXBlb2Ygc2VnbWVudCA9PSBcInN0cmluZ1wiID8gYFsnJHtzZWdtZW50LnJlcGxhY2UoL1tcXGZcXG5cXHJcXHQnXFxcXF0vZywgKG1hdGNoKSA9PiBFU0NBUEVbbWF0Y2hdKX0nXWAgOiB0eXBlb2Ygc2VnbWVudCA9PSBcIm51bWJlclwiID8gYFske3NlZ21lbnR9XWAgOiBzZWdtZW50Ll9rZXkgIT09IFwiXCIgPyBgWz8oQC5fa2V5PT0nJHtzZWdtZW50Ll9rZXkucmVwbGFjZSgvWydcXFxcXS9nLCAobWF0Y2gpID0+IEVTQ0FQRVttYXRjaF0pfScpXWAgOiBgWyR7c2VnbWVudC5faW5kZXh9XWApLmpvaW4oXCJcIil9YDtcbn1cbmZ1bmN0aW9uIHBhcnNlSnNvblBhdGgocGF0aCkge1xuICBjb25zdCBwYXJzZWQgPSBbXSwgcGFyc2VSZSA9IC9cXFsnKC4qPyknXFxdfFxcWyhcXGQrKVxcXXxcXFtcXD9cXChAXFwuX2tleT09JyguKj8pJ1xcKVxcXS9nO1xuICBsZXQgbWF0Y2g7XG4gIGZvciAoOyAobWF0Y2ggPSBwYXJzZVJlLmV4ZWMocGF0aCkpICE9PSBudWxsOyApIHtcbiAgICBpZiAobWF0Y2hbMV0gIT09IHZvaWQgMCkge1xuICAgICAgY29uc3Qga2V5ID0gbWF0Y2hbMV0ucmVwbGFjZSgvXFxcXChcXFxcfGZ8bnxyfHR8JykvZywgKG0pID0+IFVORVNDQVBFW21dKTtcbiAgICAgIHBhcnNlZC5wdXNoKGtleSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKG1hdGNoWzJdICE9PSB2b2lkIDApIHtcbiAgICAgIHBhcnNlZC5wdXNoKHBhcnNlSW50KG1hdGNoWzJdLCAxMCkpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChtYXRjaFszXSAhPT0gdm9pZCAwKSB7XG4gICAgICBjb25zdCBfa2V5ID0gbWF0Y2hbM10ucmVwbGFjZSgvXFxcXChcXFxcJykvZywgKG0pID0+IFVORVNDQVBFW21dKTtcbiAgICAgIHBhcnNlZC5wdXNoKHtcbiAgICAgICAgX2tleSxcbiAgICAgICAgX2luZGV4OiAtMVxuICAgICAgfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHBhcnNlZDtcbn1cbmZ1bmN0aW9uIGpzb25QYXRoVG9TdHVkaW9QYXRoKHBhdGgpIHtcbiAgcmV0dXJuIHBhdGgubWFwKChzZWdtZW50KSA9PiB7XG4gICAgaWYgKHR5cGVvZiBzZWdtZW50ID09IFwic3RyaW5nXCIgfHwgdHlwZW9mIHNlZ21lbnQgPT0gXCJudW1iZXJcIilcbiAgICAgIHJldHVybiBzZWdtZW50O1xuICAgIGlmIChzZWdtZW50Ll9rZXkgIT09IFwiXCIpXG4gICAgICByZXR1cm4geyBfa2V5OiBzZWdtZW50Ll9rZXkgfTtcbiAgICBpZiAoc2VnbWVudC5faW5kZXggIT09IC0xKVxuICAgICAgcmV0dXJuIHNlZ21lbnQuX2luZGV4O1xuICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBzZWdtZW50OiR7SlNPTi5zdHJpbmdpZnkoc2VnbWVudCl9YCk7XG4gIH0pO1xufVxuZnVuY3Rpb24ganNvblBhdGhUb01hcHBpbmdQYXRoKHBhdGgpIHtcbiAgcmV0dXJuIHBhdGgubWFwKChzZWdtZW50KSA9PiB7XG4gICAgaWYgKHR5cGVvZiBzZWdtZW50ID09IFwic3RyaW5nXCIgfHwgdHlwZW9mIHNlZ21lbnQgPT0gXCJudW1iZXJcIilcbiAgICAgIHJldHVybiBzZWdtZW50O1xuICAgIGlmIChzZWdtZW50Ll9pbmRleCAhPT0gLTEpXG4gICAgICByZXR1cm4gc2VnbWVudC5faW5kZXg7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIHNlZ21lbnQ6JHtKU09OLnN0cmluZ2lmeShzZWdtZW50KX1gKTtcbiAgfSk7XG59XG5mdW5jdGlvbiByZXNvbHZlTWFwcGluZyhyZXN1bHRQYXRoLCBjc20pIHtcbiAgaWYgKCFjc20/Lm1hcHBpbmdzKVxuICAgIHJldHVybjtcbiAgY29uc3QgcmVzdWx0TWFwcGluZ1BhdGggPSBqc29uUGF0aChqc29uUGF0aFRvTWFwcGluZ1BhdGgocmVzdWx0UGF0aCkpO1xuICBpZiAoY3NtLm1hcHBpbmdzW3Jlc3VsdE1hcHBpbmdQYXRoXSAhPT0gdm9pZCAwKVxuICAgIHJldHVybiB7XG4gICAgICBtYXBwaW5nOiBjc20ubWFwcGluZ3NbcmVzdWx0TWFwcGluZ1BhdGhdLFxuICAgICAgbWF0Y2hlZFBhdGg6IHJlc3VsdE1hcHBpbmdQYXRoLFxuICAgICAgcGF0aFN1ZmZpeDogXCJcIlxuICAgIH07XG4gIGNvbnN0IG1hcHBpbmdzID0gT2JqZWN0LmVudHJpZXMoY3NtLm1hcHBpbmdzKS5maWx0ZXIoKFtrZXldKSA9PiByZXN1bHRNYXBwaW5nUGF0aC5zdGFydHNXaXRoKGtleSkpLnNvcnQoKFtrZXkxXSwgW2tleTJdKSA9PiBrZXkyLmxlbmd0aCAtIGtleTEubGVuZ3RoKTtcbiAgaWYgKG1hcHBpbmdzLmxlbmd0aCA9PSAwKVxuICAgIHJldHVybjtcbiAgY29uc3QgW21hdGNoZWRQYXRoLCBtYXBwaW5nXSA9IG1hcHBpbmdzWzBdLCBwYXRoU3VmZml4ID0gcmVzdWx0TWFwcGluZ1BhdGguc3Vic3RyaW5nKG1hdGNoZWRQYXRoLmxlbmd0aCk7XG4gIHJldHVybiB7IG1hcHBpbmcsIG1hdGNoZWRQYXRoLCBwYXRoU3VmZml4IH07XG59XG5mdW5jdGlvbiBpc0FycmF5KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiBBcnJheS5pc0FycmF5KHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGlzUmVjb3JkKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gXCJvYmplY3RcIiAmJiB2YWx1ZSAhPT0gbnVsbDtcbn1cbmZ1bmN0aW9uIHdhbGtNYXAodmFsdWUsIG1hcHBpbmdGbiwgcGF0aCA9IFtdKSB7XG4gIGlmIChpc0FycmF5KHZhbHVlKSlcbiAgICByZXR1cm4gdmFsdWUubWFwKCh2LCBpZHgpID0+IHtcbiAgICAgIGlmIChpc1JlY29yZCh2KSkge1xuICAgICAgICBjb25zdCBfa2V5ID0gdi5fa2V5O1xuICAgICAgICBpZiAodHlwZW9mIF9rZXkgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICByZXR1cm4gd2Fsa01hcCh2LCBtYXBwaW5nRm4sIHBhdGguY29uY2F0KHsgX2tleSwgX2luZGV4OiBpZHggfSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdhbGtNYXAodiwgbWFwcGluZ0ZuLCBwYXRoLmNvbmNhdChpZHgpKTtcbiAgICB9KTtcbiAgaWYgKGlzUmVjb3JkKHZhbHVlKSkge1xuICAgIGlmICh2YWx1ZS5fdHlwZSA9PT0gXCJibG9ja1wiIHx8IHZhbHVlLl90eXBlID09PSBcInNwYW5cIikge1xuICAgICAgY29uc3QgcmVzdWx0ID0geyAuLi52YWx1ZSB9O1xuICAgICAgcmV0dXJuIHZhbHVlLl90eXBlID09PSBcImJsb2NrXCIgPyByZXN1bHQuY2hpbGRyZW4gPSB3YWxrTWFwKHZhbHVlLmNoaWxkcmVuLCBtYXBwaW5nRm4sIHBhdGguY29uY2F0KFwiY2hpbGRyZW5cIikpIDogdmFsdWUuX3R5cGUgPT09IFwic3BhblwiICYmIChyZXN1bHQudGV4dCA9IHdhbGtNYXAodmFsdWUudGV4dCwgbWFwcGluZ0ZuLCBwYXRoLmNvbmNhdChcInRleHRcIikpKSwgcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgT2JqZWN0LmVudHJpZXModmFsdWUpLm1hcCgoW2ssIHZdKSA9PiBbaywgd2Fsa01hcCh2LCBtYXBwaW5nRm4sIHBhdGguY29uY2F0KGspKV0pXG4gICAgKTtcbiAgfVxuICByZXR1cm4gbWFwcGluZ0ZuKHZhbHVlLCBwYXRoKTtcbn1cbmZ1bmN0aW9uIGVuY29kZUludG9SZXN1bHQocmVzdWx0LCBjc20sIGVuY29kZXIpIHtcbiAgcmV0dXJuIHdhbGtNYXAocmVzdWx0LCAodmFsdWUsIHBhdGgpID0+IHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9IFwic3RyaW5nXCIpXG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgY29uc3QgcmVzb2x2ZU1hcHBpbmdSZXN1bHQgPSByZXNvbHZlTWFwcGluZyhwYXRoLCBjc20pO1xuICAgIGlmICghcmVzb2x2ZU1hcHBpbmdSZXN1bHQpXG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgY29uc3QgeyBtYXBwaW5nLCBtYXRjaGVkUGF0aCB9ID0gcmVzb2x2ZU1hcHBpbmdSZXN1bHQ7XG4gICAgaWYgKG1hcHBpbmcudHlwZSAhPT0gXCJ2YWx1ZVwiIHx8IG1hcHBpbmcuc291cmNlLnR5cGUgIT09IFwiZG9jdW1lbnRWYWx1ZVwiKVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIGNvbnN0IHNvdXJjZURvY3VtZW50ID0gY3NtLmRvY3VtZW50c1ttYXBwaW5nLnNvdXJjZS5kb2N1bWVudF0sIHNvdXJjZVBhdGggPSBjc20ucGF0aHNbbWFwcGluZy5zb3VyY2UucGF0aF0sIG1hdGNoUGF0aFNlZ21lbnRzID0gcGFyc2VKc29uUGF0aChtYXRjaGVkUGF0aCksIGZ1bGxTb3VyY2VTZWdtZW50cyA9IHBhcnNlSnNvblBhdGgoc291cmNlUGF0aCkuY29uY2F0KHBhdGguc2xpY2UobWF0Y2hQYXRoU2VnbWVudHMubGVuZ3RoKSk7XG4gICAgcmV0dXJuIGVuY29kZXIoe1xuICAgICAgc291cmNlUGF0aDogZnVsbFNvdXJjZVNlZ21lbnRzLFxuICAgICAgc291cmNlRG9jdW1lbnQsXG4gICAgICByZXN1bHRQYXRoOiBwYXRoLFxuICAgICAgdmFsdWVcbiAgICB9KTtcbiAgfSk7XG59XG5jb25zdCBEUkFGVFNfRk9MREVSID0gXCJkcmFmdHNcIiwgVkVSU0lPTl9GT0xERVIgPSBcInZlcnNpb25zXCIsIFBBVEhfU0VQQVJBVE9SID0gXCIuXCIsIERSQUZUU19QUkVGSVggPSBgJHtEUkFGVFNfRk9MREVSfSR7UEFUSF9TRVBBUkFUT1J9YCwgVkVSU0lPTl9QUkVGSVggPSBgJHtWRVJTSU9OX0ZPTERFUn0ke1BBVEhfU0VQQVJBVE9SfWA7XG5mdW5jdGlvbiBpc0RyYWZ0SWQoaWQpIHtcbiAgcmV0dXJuIGlkLnN0YXJ0c1dpdGgoRFJBRlRTX1BSRUZJWCk7XG59XG5mdW5jdGlvbiBpc1ZlcnNpb25JZChpZCkge1xuICByZXR1cm4gaWQuc3RhcnRzV2l0aChWRVJTSU9OX1BSRUZJWCk7XG59XG5mdW5jdGlvbiBpc1B1Ymxpc2hlZElkKGlkKSB7XG4gIHJldHVybiAhaXNEcmFmdElkKGlkKSAmJiAhaXNWZXJzaW9uSWQoaWQpO1xufVxuZnVuY3Rpb24gZ2V0VmVyc2lvbkZyb21JZChpZCkge1xuICBpZiAoIWlzVmVyc2lvbklkKGlkKSkgcmV0dXJuO1xuICBjb25zdCBbX3ZlcnNpb25QcmVmaXgsIHZlcnNpb25JZCwgLi4uX3B1Ymxpc2hlZElkXSA9IGlkLnNwbGl0KFBBVEhfU0VQQVJBVE9SKTtcbiAgcmV0dXJuIHZlcnNpb25JZDtcbn1cbmZ1bmN0aW9uIGdldFB1Ymxpc2hlZElkKGlkKSB7XG4gIHJldHVybiBpc1ZlcnNpb25JZChpZCkgPyBpZC5zcGxpdChQQVRIX1NFUEFSQVRPUikuc2xpY2UoMikuam9pbihQQVRIX1NFUEFSQVRPUikgOiBpc0RyYWZ0SWQoaWQpID8gaWQuc2xpY2UoRFJBRlRTX1BSRUZJWC5sZW5ndGgpIDogaWQ7XG59XG5mdW5jdGlvbiBjcmVhdGVFZGl0VXJsKG9wdGlvbnMpIHtcbiAgY29uc3Qge1xuICAgIGJhc2VVcmwsXG4gICAgd29ya3NwYWNlOiBfd29ya3NwYWNlID0gXCJkZWZhdWx0XCIsXG4gICAgdG9vbDogX3Rvb2wgPSBcImRlZmF1bHRcIixcbiAgICBpZDogX2lkLFxuICAgIHR5cGUsXG4gICAgcGF0aCxcbiAgICBwcm9qZWN0SWQsXG4gICAgZGF0YXNldFxuICB9ID0gb3B0aW9ucztcbiAgaWYgKCFiYXNlVXJsKVxuICAgIHRocm93IG5ldyBFcnJvcihcImJhc2VVcmwgaXMgcmVxdWlyZWRcIik7XG4gIGlmICghcGF0aClcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJwYXRoIGlzIHJlcXVpcmVkXCIpO1xuICBpZiAoIV9pZClcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpZCBpcyByZXF1aXJlZFwiKTtcbiAgaWYgKGJhc2VVcmwgIT09IFwiL1wiICYmIGJhc2VVcmwuZW5kc1dpdGgoXCIvXCIpKVxuICAgIHRocm93IG5ldyBFcnJvcihcImJhc2VVcmwgbXVzdCBub3QgZW5kIHdpdGggYSBzbGFzaFwiKTtcbiAgY29uc3Qgd29ya3NwYWNlID0gX3dvcmtzcGFjZSA9PT0gXCJkZWZhdWx0XCIgPyB2b2lkIDAgOiBfd29ya3NwYWNlLCB0b29sID0gX3Rvb2wgPT09IFwiZGVmYXVsdFwiID8gdm9pZCAwIDogX3Rvb2wsIGlkID0gZ2V0UHVibGlzaGVkSWQoX2lkKSwgc3RyaW5naWZpZWRQYXRoID0gQXJyYXkuaXNBcnJheShwYXRoKSA/IHRvU3RyaW5nKGpzb25QYXRoVG9TdHVkaW9QYXRoKHBhdGgpKSA6IHBhdGgsIHNlYXJjaFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoe1xuICAgIGJhc2VVcmwsXG4gICAgaWQsXG4gICAgdHlwZSxcbiAgICBwYXRoOiBzdHJpbmdpZmllZFBhdGhcbiAgfSk7XG4gIGlmICh3b3Jrc3BhY2UgJiYgc2VhcmNoUGFyYW1zLnNldChcIndvcmtzcGFjZVwiLCB3b3Jrc3BhY2UpLCB0b29sICYmIHNlYXJjaFBhcmFtcy5zZXQoXCJ0b29sXCIsIHRvb2wpLCBwcm9qZWN0SWQgJiYgc2VhcmNoUGFyYW1zLnNldChcInByb2plY3RJZFwiLCBwcm9qZWN0SWQpLCBkYXRhc2V0ICYmIHNlYXJjaFBhcmFtcy5zZXQoXCJkYXRhc2V0XCIsIGRhdGFzZXQpLCBpc1B1Ymxpc2hlZElkKF9pZCkpXG4gICAgc2VhcmNoUGFyYW1zLnNldChcInBlcnNwZWN0aXZlXCIsIFwicHVibGlzaGVkXCIpO1xuICBlbHNlIGlmIChpc1ZlcnNpb25JZChfaWQpKSB7XG4gICAgY29uc3QgdmVyc2lvbklkID0gZ2V0VmVyc2lvbkZyb21JZChfaWQpO1xuICAgIHNlYXJjaFBhcmFtcy5zZXQoXCJwZXJzcGVjdGl2ZVwiLCB2ZXJzaW9uSWQpO1xuICB9XG4gIGNvbnN0IHNlZ21lbnRzID0gW2Jhc2VVcmwgPT09IFwiL1wiID8gXCJcIiA6IGJhc2VVcmxdO1xuICB3b3Jrc3BhY2UgJiYgc2VnbWVudHMucHVzaCh3b3Jrc3BhY2UpO1xuICBjb25zdCByb3V0ZXJQYXJhbXMgPSBbXG4gICAgXCJtb2RlPXByZXNlbnRhdGlvblwiLFxuICAgIGBpZD0ke2lkfWAsXG4gICAgYHR5cGU9JHt0eXBlfWAsXG4gICAgYHBhdGg9JHtlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZpZWRQYXRoKX1gXG4gIF07XG4gIHJldHVybiB0b29sICYmIHJvdXRlclBhcmFtcy5wdXNoKGB0b29sPSR7dG9vbH1gKSwgc2VnbWVudHMucHVzaChcImludGVudFwiLCBcImVkaXRcIiwgYCR7cm91dGVyUGFyYW1zLmpvaW4oXCI7XCIpfT8ke3NlYXJjaFBhcmFtc31gKSwgc2VnbWVudHMuam9pbihcIi9cIik7XG59XG5mdW5jdGlvbiByZXNvbHZlU3R1ZGlvQmFzZVJvdXRlKHN0dWRpb1VybCkge1xuICBsZXQgYmFzZVVybCA9IHR5cGVvZiBzdHVkaW9VcmwgPT0gXCJzdHJpbmdcIiA/IHN0dWRpb1VybCA6IHN0dWRpb1VybC5iYXNlVXJsO1xuICByZXR1cm4gYmFzZVVybCAhPT0gXCIvXCIgJiYgKGJhc2VVcmwgPSBiYXNlVXJsLnJlcGxhY2UoL1xcLyQvLCBcIlwiKSksIHR5cGVvZiBzdHVkaW9VcmwgPT0gXCJzdHJpbmdcIiA/IHsgYmFzZVVybCB9IDogeyAuLi5zdHVkaW9VcmwsIGJhc2VVcmwgfTtcbn1cbmNvbnN0IGZpbHRlckRlZmF1bHQgPSAoeyBzb3VyY2VQYXRoLCByZXN1bHRQYXRoLCB2YWx1ZSB9KSA9PiB7XG4gIGlmIChpc1ZhbGlkRGF0ZSh2YWx1ZSkgfHwgaXNWYWxpZFVSTCh2YWx1ZSkpXG4gICAgcmV0dXJuICExO1xuICBjb25zdCBlbmRQYXRoID0gc291cmNlUGF0aC5hdCgtMSk7XG4gIHJldHVybiAhKHNvdXJjZVBhdGguYXQoLTIpID09PSBcInNsdWdcIiAmJiBlbmRQYXRoID09PSBcImN1cnJlbnRcIiB8fCB0eXBlb2YgZW5kUGF0aCA9PSBcInN0cmluZ1wiICYmIChlbmRQYXRoLnN0YXJ0c1dpdGgoXCJfXCIpIHx8IGVuZFBhdGguZW5kc1dpdGgoXCJJZFwiKSkgfHwgc291cmNlUGF0aC5zb21lKFxuICAgIChwYXRoKSA9PiBwYXRoID09PSBcIm1ldGFcIiB8fCBwYXRoID09PSBcIm1ldGFkYXRhXCIgfHwgcGF0aCA9PT0gXCJvcGVuR3JhcGhcIiB8fCBwYXRoID09PSBcInNlb1wiXG4gICkgfHwgaGFzVHlwZUxpa2Uoc291cmNlUGF0aCkgfHwgaGFzVHlwZUxpa2UocmVzdWx0UGF0aCkgfHwgdHlwZW9mIGVuZFBhdGggPT0gXCJzdHJpbmdcIiAmJiBkZW55bGlzdC5oYXMoZW5kUGF0aCkpO1xufSwgZGVueWxpc3QgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXG4gIFwiY29sb3JcIixcbiAgXCJjb2xvdXJcIixcbiAgXCJjdXJyZW5jeVwiLFxuICBcImVtYWlsXCIsXG4gIFwiZm9ybWF0XCIsXG4gIFwiZ2lkXCIsXG4gIFwiaGV4XCIsXG4gIFwiaHJlZlwiLFxuICBcImhzbFwiLFxuICBcImhzbGFcIixcbiAgXCJpY29uXCIsXG4gIFwiaWRcIixcbiAgXCJpbmRleFwiLFxuICBcImtleVwiLFxuICBcImxhbmd1YWdlXCIsXG4gIFwibGF5b3V0XCIsXG4gIFwibGlua1wiLFxuICBcImxpbmtBY3Rpb25cIixcbiAgXCJsb2NhbGVcIixcbiAgXCJscWlwXCIsXG4gIFwicGFnZVwiLFxuICBcInBhdGhcIixcbiAgXCJyZWZcIixcbiAgXCJyZ2JcIixcbiAgXCJyZ2JhXCIsXG4gIFwicm91dGVcIixcbiAgXCJzZWNyZXRcIixcbiAgXCJzbHVnXCIsXG4gIFwic3RhdHVzXCIsXG4gIFwidGFnXCIsXG4gIFwidGVtcGxhdGVcIixcbiAgXCJ0aGVtZVwiLFxuICBcInR5cGVcIixcbiAgXCJ0ZXh0VGhlbWVcIixcbiAgXCJ1bml0XCIsXG4gIFwidXJsXCIsXG4gIFwidXNlcm5hbWVcIixcbiAgXCJ2YXJpYW50XCIsXG4gIFwid2Vic2l0ZVwiXG5dKTtcbmZ1bmN0aW9uIGlzVmFsaWREYXRlKGRhdGVTdHJpbmcpIHtcbiAgcmV0dXJuIC9eXFxkezR9LVxcZHsyfS1cXGR7Mn0vLnRlc3QoZGF0ZVN0cmluZykgPyAhIURhdGUucGFyc2UoZGF0ZVN0cmluZykgOiAhMTtcbn1cbmZ1bmN0aW9uIGlzVmFsaWRVUkwodXJsKSB7XG4gIHRyeSB7XG4gICAgbmV3IFVSTCh1cmwsIHVybC5zdGFydHNXaXRoKFwiL1wiKSA/IFwiaHR0cHM6Ly9hY21lLmNvbVwiIDogdm9pZCAwKTtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuICExO1xuICB9XG4gIHJldHVybiAhMDtcbn1cbmZ1bmN0aW9uIGhhc1R5cGVMaWtlKHBhdGgpIHtcbiAgcmV0dXJuIHBhdGguc29tZSgoc2VnbWVudCkgPT4gdHlwZW9mIHNlZ21lbnQgPT0gXCJzdHJpbmdcIiAmJiBzZWdtZW50Lm1hdGNoKC90eXBlL2kpICE9PSBudWxsKTtcbn1cbmNvbnN0IFRSVU5DQVRFX0xFTkdUSCA9IDIwO1xuZnVuY3Rpb24gc3RlZ2FFbmNvZGVTb3VyY2VNYXAocmVzdWx0LCByZXN1bHRTb3VyY2VNYXAsIGNvbmZpZykge1xuICBjb25zdCB7IGZpbHRlciwgbG9nZ2VyLCBlbmFibGVkIH0gPSBjb25maWc7XG4gIGlmICghZW5hYmxlZCkge1xuICAgIGNvbnN0IG1zZyA9IFwiY29uZmlnLmVuYWJsZWQgbXVzdCBiZSB0cnVlLCBkb24ndCBjYWxsIHRoaXMgZnVuY3Rpb24gb3RoZXJ3aXNlXCI7XG4gICAgdGhyb3cgbG9nZ2VyPy5lcnJvcj8uKGBbQHNhbml0eS9jbGllbnRdOiAke21zZ31gLCB7IHJlc3VsdCwgcmVzdWx0U291cmNlTWFwLCBjb25maWcgfSksIG5ldyBUeXBlRXJyb3IobXNnKTtcbiAgfVxuICBpZiAoIXJlc3VsdFNvdXJjZU1hcClcbiAgICByZXR1cm4gbG9nZ2VyPy5lcnJvcj8uKFwiW0BzYW5pdHkvY2xpZW50XTogTWlzc2luZyBDb250ZW50IFNvdXJjZSBNYXAgZnJvbSByZXNwb25zZSBib2R5XCIsIHtcbiAgICAgIHJlc3VsdCxcbiAgICAgIHJlc3VsdFNvdXJjZU1hcCxcbiAgICAgIGNvbmZpZ1xuICAgIH0pLCByZXN1bHQ7XG4gIGlmICghY29uZmlnLnN0dWRpb1VybCkge1xuICAgIGNvbnN0IG1zZyA9IFwiY29uZmlnLnN0dWRpb1VybCBtdXN0IGJlIGRlZmluZWRcIjtcbiAgICB0aHJvdyBsb2dnZXI/LmVycm9yPy4oYFtAc2FuaXR5L2NsaWVudF06ICR7bXNnfWAsIHsgcmVzdWx0LCByZXN1bHRTb3VyY2VNYXAsIGNvbmZpZyB9KSwgbmV3IFR5cGVFcnJvcihtc2cpO1xuICB9XG4gIGNvbnN0IHJlcG9ydCA9IHtcbiAgICBlbmNvZGVkOiBbXSxcbiAgICBza2lwcGVkOiBbXVxuICB9LCByZXN1bHRXaXRoU3RlZ2EgPSBlbmNvZGVJbnRvUmVzdWx0KFxuICAgIHJlc3VsdCxcbiAgICByZXN1bHRTb3VyY2VNYXAsXG4gICAgKHsgc291cmNlUGF0aCwgc291cmNlRG9jdW1lbnQsIHJlc3VsdFBhdGgsIHZhbHVlIH0pID0+IHtcbiAgICAgIGlmICgodHlwZW9mIGZpbHRlciA9PSBcImZ1bmN0aW9uXCIgPyBmaWx0ZXIoeyBzb3VyY2VQYXRoLCByZXN1bHRQYXRoLCBmaWx0ZXJEZWZhdWx0LCBzb3VyY2VEb2N1bWVudCwgdmFsdWUgfSkgOiBmaWx0ZXJEZWZhdWx0KHsgc291cmNlUGF0aCwgcmVzdWx0UGF0aCwgZmlsdGVyRGVmYXVsdCwgc291cmNlRG9jdW1lbnQsIHZhbHVlIH0pKSA9PT0gITEpXG4gICAgICAgIHJldHVybiBsb2dnZXIgJiYgcmVwb3J0LnNraXBwZWQucHVzaCh7XG4gICAgICAgICAgcGF0aDogcHJldHR5UGF0aEZvckxvZ2dpbmcoc291cmNlUGF0aCksXG4gICAgICAgICAgdmFsdWU6IGAke3ZhbHVlLnNsaWNlKDAsIFRSVU5DQVRFX0xFTkdUSCl9JHt2YWx1ZS5sZW5ndGggPiBUUlVOQ0FURV9MRU5HVEggPyBcIi4uLlwiIDogXCJcIn1gLFxuICAgICAgICAgIGxlbmd0aDogdmFsdWUubGVuZ3RoXG4gICAgICAgIH0pLCB2YWx1ZTtcbiAgICAgIGxvZ2dlciAmJiByZXBvcnQuZW5jb2RlZC5wdXNoKHtcbiAgICAgICAgcGF0aDogcHJldHR5UGF0aEZvckxvZ2dpbmcoc291cmNlUGF0aCksXG4gICAgICAgIHZhbHVlOiBgJHt2YWx1ZS5zbGljZSgwLCBUUlVOQ0FURV9MRU5HVEgpfSR7dmFsdWUubGVuZ3RoID4gVFJVTkNBVEVfTEVOR1RIID8gXCIuLi5cIiA6IFwiXCJ9YCxcbiAgICAgICAgbGVuZ3RoOiB2YWx1ZS5sZW5ndGhcbiAgICAgIH0pO1xuICAgICAgY29uc3QgeyBiYXNlVXJsLCB3b3Jrc3BhY2UsIHRvb2wgfSA9IHJlc29sdmVTdHVkaW9CYXNlUm91dGUoXG4gICAgICAgIHR5cGVvZiBjb25maWcuc3R1ZGlvVXJsID09IFwiZnVuY3Rpb25cIiA/IGNvbmZpZy5zdHVkaW9Vcmwoc291cmNlRG9jdW1lbnQpIDogY29uZmlnLnN0dWRpb1VybFxuICAgICAgKTtcbiAgICAgIGlmICghYmFzZVVybCkgcmV0dXJuIHZhbHVlO1xuICAgICAgY29uc3QgeyBfaWQ6IGlkLCBfdHlwZTogdHlwZSwgX3Byb2plY3RJZDogcHJvamVjdElkLCBfZGF0YXNldDogZGF0YXNldCB9ID0gc291cmNlRG9jdW1lbnQ7XG4gICAgICByZXR1cm4gQyhcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIHtcbiAgICAgICAgICBvcmlnaW46IFwic2FuaXR5LmlvXCIsXG4gICAgICAgICAgaHJlZjogY3JlYXRlRWRpdFVybCh7XG4gICAgICAgICAgICBiYXNlVXJsLFxuICAgICAgICAgICAgd29ya3NwYWNlLFxuICAgICAgICAgICAgdG9vbCxcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgIHBhdGg6IHNvdXJjZVBhdGgsXG4gICAgICAgICAgICAuLi4hY29uZmlnLm9taXRDcm9zc0RhdGFzZXRSZWZlcmVuY2VEYXRhICYmIHsgZGF0YXNldCwgcHJvamVjdElkIH1cbiAgICAgICAgICB9KVxuICAgICAgICB9LFxuICAgICAgICAvLyBXZSB1c2UgY3VzdG9tIGxvZ2ljIHRvIGRldGVybWluZSBpZiB3ZSBzaG91bGQgc2tpcCBlbmNvZGluZ1xuICAgICAgICAhMVxuICAgICAgKTtcbiAgICB9XG4gICk7XG4gIGlmIChsb2dnZXIpIHtcbiAgICBjb25zdCBpc1NraXBwaW5nID0gcmVwb3J0LnNraXBwZWQubGVuZ3RoLCBpc0VuY29kaW5nID0gcmVwb3J0LmVuY29kZWQubGVuZ3RoO1xuICAgIGlmICgoaXNTa2lwcGluZyB8fCBpc0VuY29kaW5nKSAmJiAoKGxvZ2dlcj8uZ3JvdXBDb2xsYXBzZWQgfHwgbG9nZ2VyLmxvZyk/LihcIltAc2FuaXR5L2NsaWVudF06IEVuY29kaW5nIHNvdXJjZSBtYXAgaW50byByZXN1bHRcIiksIGxvZ2dlci5sb2c/LihcbiAgICAgIGBbQHNhbml0eS9jbGllbnRdOiBQYXRocyBlbmNvZGVkOiAke3JlcG9ydC5lbmNvZGVkLmxlbmd0aH0sIHNraXBwZWQ6ICR7cmVwb3J0LnNraXBwZWQubGVuZ3RofWBcbiAgICApKSwgcmVwb3J0LmVuY29kZWQubGVuZ3RoID4gMCAmJiAobG9nZ2VyPy5sb2c/LihcIltAc2FuaXR5L2NsaWVudF06IFRhYmxlIG9mIGVuY29kZWQgcGF0aHNcIiksIChsb2dnZXI/LnRhYmxlIHx8IGxvZ2dlci5sb2cpPy4ocmVwb3J0LmVuY29kZWQpKSwgcmVwb3J0LnNraXBwZWQubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3Qgc2tpcHBlZCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgICBmb3IgKGNvbnN0IHsgcGF0aCB9IG9mIHJlcG9ydC5za2lwcGVkKVxuICAgICAgICBza2lwcGVkLmFkZChwYXRoLnJlcGxhY2UocmVLZXlTZWdtZW50LCBcIjBcIikucmVwbGFjZSgvXFxbXFxkK1xcXS9nLCBcIltdXCIpKTtcbiAgICAgIGxvZ2dlcj8ubG9nPy4oXCJbQHNhbml0eS9jbGllbnRdOiBMaXN0IG9mIHNraXBwZWQgcGF0aHNcIiwgWy4uLnNraXBwZWQudmFsdWVzKCldKTtcbiAgICB9XG4gICAgKGlzU2tpcHBpbmcgfHwgaXNFbmNvZGluZykgJiYgbG9nZ2VyPy5ncm91cEVuZD8uKCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdFdpdGhTdGVnYTtcbn1cbmZ1bmN0aW9uIHByZXR0eVBhdGhGb3JMb2dnaW5nKHBhdGgpIHtcbiAgcmV0dXJuIHRvU3RyaW5nKGpzb25QYXRoVG9TdHVkaW9QYXRoKHBhdGgpKTtcbn1cbnZhciBzdGVnYUVuY29kZVNvdXJjZU1hcCQxID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIHN0ZWdhRW5jb2RlU291cmNlTWFwXG59KTtcbmV4cG9ydCB7XG4gIGVuY29kZUludG9SZXN1bHQsXG4gIHN0ZWdhRW5jb2RlU291cmNlTWFwLFxuICBzdGVnYUVuY29kZVNvdXJjZU1hcCQxXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RlZ2FFbmNvZGVTb3VyY2VNYXAuanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sanity/client/dist/_chunks-es/stegaEncodeSourceMap.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@sanity/client/dist/index.js":
/*!***************************************************!*\
  !*** ./node_modules/@sanity/client/dist/index.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BasePatch: () => (/* binding */ BasePatch),\n/* harmony export */   BaseTransaction: () => (/* binding */ BaseTransaction),\n/* harmony export */   ChannelError: () => (/* binding */ ChannelError),\n/* harmony export */   ClientError: () => (/* binding */ ClientError),\n/* harmony export */   ConnectionFailedError: () => (/* binding */ ConnectionFailedError),\n/* harmony export */   CorsOriginError: () => (/* binding */ CorsOriginError),\n/* harmony export */   DisconnectError: () => (/* binding */ DisconnectError),\n/* harmony export */   MessageError: () => (/* binding */ MessageError),\n/* harmony export */   MessageParseError: () => (/* binding */ MessageParseError),\n/* harmony export */   ObservablePatch: () => (/* binding */ ObservablePatch),\n/* harmony export */   ObservableSanityClient: () => (/* binding */ ObservableSanityClient),\n/* harmony export */   ObservableTransaction: () => (/* binding */ ObservableTransaction),\n/* harmony export */   Patch: () => (/* binding */ Patch),\n/* harmony export */   SanityClient: () => (/* binding */ SanityClient),\n/* harmony export */   ServerError: () => (/* binding */ ServerError),\n/* harmony export */   Transaction: () => (/* binding */ Transaction),\n/* harmony export */   connectEventSource: () => (/* binding */ connectEventSource),\n/* harmony export */   createClient: () => (/* binding */ createClient),\n/* harmony export */   \"default\": () => (/* binding */ deprecatedCreateClient),\n/* harmony export */   requester: () => (/* binding */ requester),\n/* harmony export */   unstable__adapter: () => (/* reexport safe */ get_it__WEBPACK_IMPORTED_MODULE_18__.a),\n/* harmony export */   unstable__environment: () => (/* reexport safe */ get_it__WEBPACK_IMPORTED_MODULE_0__.environment),\n/* harmony export */   validateApiPerspective: () => (/* reexport safe */ _chunks_es_config_js__WEBPACK_IMPORTED_MODULE_7__.validateApiPerspective)\n/* harmony export */ });\n/* harmony import */ var get_it__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! get-it */ \"(ssr)/./node_modules/get-it/dist/index.js\");\n/* harmony import */ var get_it__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! get-it */ \"(ssr)/./node_modules/get-it/dist/_chunks-es/node-request.js\");\n/* harmony import */ var get_it_middleware__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! get-it/middleware */ \"(ssr)/./node_modules/get-it/dist/middleware.js\");\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! rxjs */ \"(ssr)/./node_modules/rxjs/dist/esm5/internal/Observable.js\");\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! rxjs */ \"(ssr)/./node_modules/rxjs/dist/esm5/internal/observable/defer.js\");\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! rxjs */ \"(ssr)/./node_modules/rxjs/dist/esm5/internal/util/isObservable.js\");\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! rxjs */ \"(ssr)/./node_modules/rxjs/dist/esm5/internal/observable/of.js\");\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! rxjs */ \"(ssr)/./node_modules/rxjs/dist/esm5/internal/operators/mergeMap.js\");\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! rxjs */ \"(ssr)/./node_modules/rxjs/dist/esm5/internal/observable/from.js\");\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! rxjs */ \"(ssr)/./node_modules/rxjs/dist/esm5/internal/lastValueFrom.js\");\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! rxjs */ \"(ssr)/./node_modules/rxjs/dist/esm5/internal/operators/shareReplay.js\");\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! rxjs */ \"(ssr)/./node_modules/rxjs/dist/esm5/internal/operators/catchError.js\");\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! rxjs */ \"(ssr)/./node_modules/rxjs/dist/esm5/internal/observable/concat.js\");\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! rxjs */ \"(ssr)/./node_modules/rxjs/dist/esm5/internal/observable/timer.js\");\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! rxjs */ \"(ssr)/./node_modules/rxjs/dist/esm5/internal/observable/throwError.js\");\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! rxjs */ \"(ssr)/./node_modules/rxjs/dist/esm5/internal/observable/empty.js\");\n/* harmony import */ var _chunks_es_stegaClean_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./_chunks-es/stegaClean.js */ \"(ssr)/./node_modules/@sanity/client/dist/_chunks-es/stegaClean.js\");\n/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! rxjs/operators */ \"(ssr)/./node_modules/rxjs/dist/cjs/operators/index.js\");\n/* harmony import */ var _chunks_es_config_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./_chunks-es/config.js */ \"(ssr)/./node_modules/@sanity/client/dist/_chunks-es/config.js\");\n\n\n\n\n\n\n\nclass ClientError extends Error {\n  response;\n  statusCode = 400;\n  responseBody;\n  details;\n  constructor(res) {\n    const props = extractErrorProps(res);\n    super(props.message), Object.assign(this, props);\n  }\n}\nclass ServerError extends Error {\n  response;\n  statusCode = 500;\n  responseBody;\n  details;\n  constructor(res) {\n    const props = extractErrorProps(res);\n    super(props.message), Object.assign(this, props);\n  }\n}\nfunction extractErrorProps(res) {\n  const body = res.body, props = {\n    response: res,\n    statusCode: res.statusCode,\n    responseBody: stringifyBody(body, res),\n    message: \"\",\n    details: void 0\n  };\n  if (body.error && body.message)\n    return props.message = `${body.error} - ${body.message}`, props;\n  if (isMutationError(body) || isActionError(body)) {\n    const allItems = body.error.items || [], items = allItems.slice(0, 5).map((item) => item.error?.description).filter(Boolean);\n    let itemsStr = items.length ? `:\n- ${items.join(`\n- `)}` : \"\";\n    return allItems.length > 5 && (itemsStr += `\n...and ${allItems.length - 5} more`), props.message = `${body.error.description}${itemsStr}`, props.details = body.error, props;\n  }\n  return body.error && body.error.description ? (props.message = body.error.description, props.details = body.error, props) : (props.message = body.error || body.message || httpErrorMessage(res), props);\n}\nfunction isMutationError(body) {\n  return isPlainObject(body) && isPlainObject(body.error) && body.error.type === \"mutationError\" && typeof body.error.description == \"string\";\n}\nfunction isActionError(body) {\n  return isPlainObject(body) && isPlainObject(body.error) && body.error.type === \"actionError\" && typeof body.error.description == \"string\";\n}\nfunction isPlainObject(obj) {\n  return typeof obj == \"object\" && obj !== null && !Array.isArray(obj);\n}\nfunction httpErrorMessage(res) {\n  const statusMessage = res.statusMessage ? ` ${res.statusMessage}` : \"\";\n  return `${res.method}-request to ${res.url} resulted in HTTP ${res.statusCode}${statusMessage}`;\n}\nfunction stringifyBody(body, res) {\n  return (res.headers[\"content-type\"] || \"\").toLowerCase().indexOf(\"application/json\") !== -1 ? JSON.stringify(body, null, 2) : body;\n}\nclass CorsOriginError extends Error {\n  projectId;\n  addOriginUrl;\n  constructor({ projectId }) {\n    super(\"CorsOriginError\"), this.name = \"CorsOriginError\", this.projectId = projectId;\n    const url = new URL(`https://sanity.io/manage/project/${projectId}/api`);\n    if (typeof location < \"u\") {\n      const { origin } = location;\n      url.searchParams.set(\"cors\", \"add\"), url.searchParams.set(\"origin\", origin), this.addOriginUrl = url, this.message = `The current origin is not allowed to connect to the Live Content API. Add it here: ${url}`;\n    } else\n      this.message = `The current origin is not allowed to connect to the Live Content API. Change your configuration here: ${url}`;\n  }\n}\nconst httpError = {\n  onResponse: (res) => {\n    if (res.statusCode >= 500)\n      throw new ServerError(res);\n    if (res.statusCode >= 400)\n      throw new ClientError(res);\n    return res;\n  }\n};\nfunction printWarnings() {\n  const seen = {};\n  return {\n    onResponse: (res) => {\n      const warn = res.headers[\"x-sanity-warning\"], warnings = Array.isArray(warn) ? warn : [warn];\n      for (const msg of warnings)\n        !msg || seen[msg] || (seen[msg] = !0, console.warn(msg));\n      return res;\n    }\n  };\n}\nfunction defineHttpRequest(envMiddleware) {\n  return (0,get_it__WEBPACK_IMPORTED_MODULE_0__.getIt)([\n    (0,get_it_middleware__WEBPACK_IMPORTED_MODULE_1__.retry)({ shouldRetry }),\n    ...envMiddleware,\n    printWarnings(),\n    (0,get_it_middleware__WEBPACK_IMPORTED_MODULE_1__.jsonRequest)(),\n    (0,get_it_middleware__WEBPACK_IMPORTED_MODULE_1__.jsonResponse)(),\n    (0,get_it_middleware__WEBPACK_IMPORTED_MODULE_1__.progress)(),\n    httpError,\n    (0,get_it_middleware__WEBPACK_IMPORTED_MODULE_1__.observable)({ implementation: rxjs__WEBPACK_IMPORTED_MODULE_2__.Observable })\n  ]);\n}\nfunction shouldRetry(err, attempt, options) {\n  if (options.maxRetries === 0) return !1;\n  const isSafe = options.method === \"GET\" || options.method === \"HEAD\", isQuery = (options.uri || options.url).startsWith(\"/data/query\"), isRetriableResponse = err.response && (err.response.statusCode === 429 || err.response.statusCode === 502 || err.response.statusCode === 503);\n  return (isSafe || isQuery) && isRetriableResponse ? !0 : get_it_middleware__WEBPACK_IMPORTED_MODULE_1__.retry.shouldRetry(err, attempt, options);\n}\nclass ConnectionFailedError extends Error {\n  name = \"ConnectionFailedError\";\n}\nclass DisconnectError extends Error {\n  name = \"DisconnectError\";\n  reason;\n  constructor(message, reason, options = {}) {\n    super(message, options), this.reason = reason;\n  }\n}\nclass ChannelError extends Error {\n  name = \"ChannelError\";\n  data;\n  constructor(message, data) {\n    super(message), this.data = data;\n  }\n}\nclass MessageError extends Error {\n  name = \"MessageError\";\n  data;\n  constructor(message, data, options = {}) {\n    super(message, options), this.data = data;\n  }\n}\nclass MessageParseError extends Error {\n  name = \"MessageParseError\";\n}\nconst REQUIRED_EVENTS = [\"channelError\", \"disconnect\"];\nfunction connectEventSource(initEventSource, events) {\n  return (0,rxjs__WEBPACK_IMPORTED_MODULE_3__.defer)(() => {\n    const es = initEventSource();\n    return (0,rxjs__WEBPACK_IMPORTED_MODULE_4__.isObservable)(es) ? es : (0,rxjs__WEBPACK_IMPORTED_MODULE_5__.of)(es);\n  }).pipe((0,rxjs__WEBPACK_IMPORTED_MODULE_6__.mergeMap)((es) => connectWithESInstance(es, events)));\n}\nfunction connectWithESInstance(es, events) {\n  return new rxjs__WEBPACK_IMPORTED_MODULE_2__.Observable((observer) => {\n    const emitOpen = events.includes(\"open\"), emitReconnect = events.includes(\"reconnect\");\n    function onError(evt) {\n      if (\"data\" in evt) {\n        const [parseError, event] = parseEvent(evt);\n        observer.error(\n          parseError ? new MessageParseError(\"Unable to parse EventSource error message\", { cause: event }) : new MessageError((event?.data).message, event)\n        );\n        return;\n      }\n      es.readyState === es.CLOSED ? observer.error(new ConnectionFailedError(\"EventSource connection failed\")) : emitReconnect && observer.next({ type: \"reconnect\" });\n    }\n    function onOpen() {\n      observer.next({ type: \"open\" });\n    }\n    function onMessage(message) {\n      const [parseError, event] = parseEvent(message);\n      if (parseError) {\n        observer.error(\n          new MessageParseError(\"Unable to parse EventSource message\", { cause: parseError })\n        );\n        return;\n      }\n      if (message.type === \"channelError\") {\n        observer.error(new ChannelError(extractErrorMessage(event?.data), event.data));\n        return;\n      }\n      if (message.type === \"disconnect\") {\n        observer.error(\n          new DisconnectError(\n            `Server disconnected client: ${event.data?.reason || \"unknown error\"}`\n          )\n        );\n        return;\n      }\n      observer.next({\n        type: message.type,\n        id: message.lastEventId,\n        ...event.data ? { data: event.data } : {}\n      });\n    }\n    es.addEventListener(\"error\", onError), emitOpen && es.addEventListener(\"open\", onOpen);\n    const cleanedEvents = [.../* @__PURE__ */ new Set([...REQUIRED_EVENTS, ...events])].filter((type) => type !== \"error\" && type !== \"open\" && type !== \"reconnect\");\n    return cleanedEvents.forEach((type) => es.addEventListener(type, onMessage)), () => {\n      es.removeEventListener(\"error\", onError), emitOpen && es.removeEventListener(\"open\", onOpen), cleanedEvents.forEach((type) => es.removeEventListener(type, onMessage)), es.close();\n    };\n  });\n}\nfunction parseEvent(message) {\n  try {\n    const data = typeof message.data == \"string\" && JSON.parse(message.data);\n    return [\n      null,\n      {\n        type: message.type,\n        id: message.lastEventId,\n        ...isEmptyObject(data) ? {} : { data }\n      }\n    ];\n  } catch (err) {\n    return [err, null];\n  }\n}\nfunction extractErrorMessage(err) {\n  return err.error ? err.error.description ? err.error.description : typeof err.error == \"string\" ? err.error : JSON.stringify(err.error, null, 2) : err.message || \"Unknown listener error\";\n}\nfunction isEmptyObject(data) {\n  for (const _ in data)\n    return !1;\n  return !0;\n}\nfunction getSelection(sel) {\n  if (typeof sel == \"string\")\n    return { id: sel };\n  if (Array.isArray(sel))\n    return { query: \"*[_id in $ids]\", params: { ids: sel } };\n  if (typeof sel == \"object\" && sel !== null && \"query\" in sel && typeof sel.query == \"string\")\n    return \"params\" in sel && typeof sel.params == \"object\" && sel.params !== null ? { query: sel.query, params: sel.params } : { query: sel.query };\n  const selectionOpts = [\n    \"* Document ID (<docId>)\",\n    \"* Array of document IDs\",\n    \"* Object containing `query`\"\n  ].join(`\n`);\n  throw new Error(`Unknown selection - must be one of:\n\n${selectionOpts}`);\n}\nclass BasePatch {\n  selection;\n  operations;\n  constructor(selection, operations = {}) {\n    this.selection = selection, this.operations = operations;\n  }\n  /**\n   * Sets the given attributes to the document. Does NOT merge objects.\n   * The operation is added to the current patch, ready to be commited by `commit()`\n   *\n   * @param attrs - Attributes to set. To set a deep attribute, use JSONMatch, eg: \\{\"nested.prop\": \"value\"\\}\n   */\n  set(attrs) {\n    return this._assign(\"set\", attrs);\n  }\n  /**\n   * Sets the given attributes to the document if they are not currently set. Does NOT merge objects.\n   * The operation is added to the current patch, ready to be commited by `commit()`\n   *\n   * @param attrs - Attributes to set. To set a deep attribute, use JSONMatch, eg: \\{\"nested.prop\": \"value\"\\}\n   */\n  setIfMissing(attrs) {\n    return this._assign(\"setIfMissing\", attrs);\n  }\n  /**\n   * Performs a \"diff-match-patch\" operation on the string attributes provided.\n   * The operation is added to the current patch, ready to be commited by `commit()`\n   *\n   * @param attrs - Attributes to perform operation on. To set a deep attribute, use JSONMatch, eg: \\{\"nested.prop\": \"dmp\"\\}\n   */\n  diffMatchPatch(attrs) {\n    return (0,_chunks_es_config_js__WEBPACK_IMPORTED_MODULE_7__.validateObject)(\"diffMatchPatch\", attrs), this._assign(\"diffMatchPatch\", attrs);\n  }\n  /**\n   * Unsets the attribute paths provided.\n   * The operation is added to the current patch, ready to be commited by `commit()`\n   *\n   * @param attrs - Attribute paths to unset.\n   */\n  unset(attrs) {\n    if (!Array.isArray(attrs))\n      throw new Error(\"unset(attrs) takes an array of attributes to unset, non-array given\");\n    return this.operations = Object.assign({}, this.operations, { unset: attrs }), this;\n  }\n  /**\n   * Increment a numeric value. Each entry in the argument is either an attribute or a JSON path. The value may be a positive or negative integer or floating-point value. The operation will fail if target value is not a numeric value, or doesn't exist.\n   *\n   * @param attrs - Object of attribute paths to increment, values representing the number to increment by.\n   */\n  inc(attrs) {\n    return this._assign(\"inc\", attrs);\n  }\n  /**\n   * Decrement a numeric value. Each entry in the argument is either an attribute or a JSON path. The value may be a positive or negative integer or floating-point value. The operation will fail if target value is not a numeric value, or doesn't exist.\n   *\n   * @param attrs - Object of attribute paths to decrement, values representing the number to decrement by.\n   */\n  dec(attrs) {\n    return this._assign(\"dec\", attrs);\n  }\n  /**\n   * Provides methods for modifying arrays, by inserting, appending and replacing elements via a JSONPath expression.\n   *\n   * @param at - Location to insert at, relative to the given selector, or 'replace' the matched path\n   * @param selector - JSONPath expression, eg `comments[-1]` or `blocks[_key==\"abc123\"]`\n   * @param items - Array of items to insert/replace\n   */\n  insert(at, selector, items) {\n    return (0,_chunks_es_config_js__WEBPACK_IMPORTED_MODULE_7__.validateInsert)(at, selector, items), this._assign(\"insert\", { [at]: selector, items });\n  }\n  /**\n   * Append the given items to the array at the given JSONPath\n   *\n   * @param selector - Attribute/path to append to, eg `comments` or `person.hobbies`\n   * @param items - Array of items to append to the array\n   */\n  append(selector, items) {\n    return this.insert(\"after\", `${selector}[-1]`, items);\n  }\n  /**\n   * Prepend the given items to the array at the given JSONPath\n   *\n   * @param selector - Attribute/path to prepend to, eg `comments` or `person.hobbies`\n   * @param items - Array of items to prepend to the array\n   */\n  prepend(selector, items) {\n    return this.insert(\"before\", `${selector}[0]`, items);\n  }\n  /**\n   * Change the contents of an array by removing existing elements and/or adding new elements.\n   *\n   * @param selector - Attribute or JSONPath expression for array\n   * @param start - Index at which to start changing the array (with origin 0). If greater than the length of the array, actual starting index will be set to the length of the array. If negative, will begin that many elements from the end of the array (with origin -1) and will be set to 0 if absolute value is greater than the length of the array.x\n   * @param deleteCount - An integer indicating the number of old array elements to remove.\n   * @param items - The elements to add to the array, beginning at the start index. If you don't specify any elements, splice() will only remove elements from the array.\n   */\n  splice(selector, start, deleteCount, items) {\n    const delAll = typeof deleteCount > \"u\" || deleteCount === -1, startIndex = start < 0 ? start - 1 : start, delCount = delAll ? -1 : Math.max(0, start + deleteCount), delRange = startIndex < 0 && delCount >= 0 ? \"\" : delCount, rangeSelector = `${selector}[${startIndex}:${delRange}]`;\n    return this.insert(\"replace\", rangeSelector, items || []);\n  }\n  /**\n   * Adds a revision clause, preventing the document from being patched if the `_rev` property does not match the given value\n   *\n   * @param rev - Revision to lock the patch to\n   */\n  ifRevisionId(rev) {\n    return this.operations.ifRevisionID = rev, this;\n  }\n  /**\n   * Return a plain JSON representation of the patch\n   */\n  serialize() {\n    return { ...getSelection(this.selection), ...this.operations };\n  }\n  /**\n   * Return a plain JSON representation of the patch\n   */\n  toJSON() {\n    return this.serialize();\n  }\n  /**\n   * Clears the patch of all operations\n   */\n  reset() {\n    return this.operations = {}, this;\n  }\n  _assign(op, props, merge = !0) {\n    return (0,_chunks_es_config_js__WEBPACK_IMPORTED_MODULE_7__.validateObject)(op, props), this.operations = Object.assign({}, this.operations, {\n      [op]: Object.assign({}, merge && this.operations[op] || {}, props)\n    }), this;\n  }\n  _set(op, props) {\n    return this._assign(op, props, !1);\n  }\n}\nclass ObservablePatch extends BasePatch {\n  #client;\n  constructor(selection, operations, client) {\n    super(selection, operations), this.#client = client;\n  }\n  /**\n   * Clones the patch\n   */\n  clone() {\n    return new ObservablePatch(this.selection, { ...this.operations }, this.#client);\n  }\n  commit(options) {\n    if (!this.#client)\n      throw new Error(\n        \"No `client` passed to patch, either provide one or pass the patch to a clients `mutate()` method\"\n      );\n    const returnFirst = typeof this.selection == \"string\", opts = Object.assign({ returnFirst, returnDocuments: !0 }, options);\n    return this.#client.mutate({ patch: this.serialize() }, opts);\n  }\n}\nclass Patch extends BasePatch {\n  #client;\n  constructor(selection, operations, client) {\n    super(selection, operations), this.#client = client;\n  }\n  /**\n   * Clones the patch\n   */\n  clone() {\n    return new Patch(this.selection, { ...this.operations }, this.#client);\n  }\n  commit(options) {\n    if (!this.#client)\n      throw new Error(\n        \"No `client` passed to patch, either provide one or pass the patch to a clients `mutate()` method\"\n      );\n    const returnFirst = typeof this.selection == \"string\", opts = Object.assign({ returnFirst, returnDocuments: !0 }, options);\n    return this.#client.mutate({ patch: this.serialize() }, opts);\n  }\n}\nconst defaultMutateOptions = { returnDocuments: !1 };\nclass BaseTransaction {\n  operations;\n  trxId;\n  constructor(operations = [], transactionId) {\n    this.operations = operations, this.trxId = transactionId;\n  }\n  /**\n   * Creates a new Sanity document. If `_id` is provided and already exists, the mutation will fail. If no `_id` is given, one will automatically be generated by the database.\n   * The operation is added to the current transaction, ready to be commited by `commit()`\n   *\n   * @param doc - Document to create. Requires a `_type` property.\n   */\n  create(doc) {\n    return (0,_chunks_es_config_js__WEBPACK_IMPORTED_MODULE_7__.validateObject)(\"create\", doc), this._add({ create: doc });\n  }\n  /**\n   * Creates a new Sanity document. If a document with the same `_id` already exists, the create operation will be ignored.\n   * The operation is added to the current transaction, ready to be commited by `commit()`\n   *\n   * @param doc - Document to create if it does not already exist. Requires `_id` and `_type` properties.\n   */\n  createIfNotExists(doc) {\n    const op = \"createIfNotExists\";\n    return (0,_chunks_es_config_js__WEBPACK_IMPORTED_MODULE_7__.validateObject)(op, doc), (0,_chunks_es_config_js__WEBPACK_IMPORTED_MODULE_7__.requireDocumentId)(op, doc), this._add({ [op]: doc });\n  }\n  /**\n   * Creates a new Sanity document, or replaces an existing one if the same `_id` is already used.\n   * The operation is added to the current transaction, ready to be commited by `commit()`\n   *\n   * @param doc - Document to create or replace. Requires `_id` and `_type` properties.\n   */\n  createOrReplace(doc) {\n    const op = \"createOrReplace\";\n    return (0,_chunks_es_config_js__WEBPACK_IMPORTED_MODULE_7__.validateObject)(op, doc), (0,_chunks_es_config_js__WEBPACK_IMPORTED_MODULE_7__.requireDocumentId)(op, doc), this._add({ [op]: doc });\n  }\n  /**\n   * Deletes the document with the given document ID\n   * The operation is added to the current transaction, ready to be commited by `commit()`\n   *\n   * @param documentId - Document ID to delete\n   */\n  delete(documentId) {\n    return (0,_chunks_es_config_js__WEBPACK_IMPORTED_MODULE_7__.validateDocumentId)(\"delete\", documentId), this._add({ delete: { id: documentId } });\n  }\n  transactionId(id) {\n    return id ? (this.trxId = id, this) : this.trxId;\n  }\n  /**\n   * Return a plain JSON representation of the transaction\n   */\n  serialize() {\n    return [...this.operations];\n  }\n  /**\n   * Return a plain JSON representation of the transaction\n   */\n  toJSON() {\n    return this.serialize();\n  }\n  /**\n   * Clears the transaction of all operations\n   */\n  reset() {\n    return this.operations = [], this;\n  }\n  _add(mut) {\n    return this.operations.push(mut), this;\n  }\n}\nclass Transaction extends BaseTransaction {\n  #client;\n  constructor(operations, client, transactionId) {\n    super(operations, transactionId), this.#client = client;\n  }\n  /**\n   * Clones the transaction\n   */\n  clone() {\n    return new Transaction([...this.operations], this.#client, this.trxId);\n  }\n  commit(options) {\n    if (!this.#client)\n      throw new Error(\n        \"No `client` passed to transaction, either provide one or pass the transaction to a clients `mutate()` method\"\n      );\n    return this.#client.mutate(\n      this.serialize(),\n      Object.assign({ transactionId: this.trxId }, defaultMutateOptions, options || {})\n    );\n  }\n  patch(patchOrDocumentId, patchOps) {\n    const isBuilder = typeof patchOps == \"function\", isPatch = typeof patchOrDocumentId != \"string\" && patchOrDocumentId instanceof Patch, isMutationSelection = typeof patchOrDocumentId == \"object\" && (\"query\" in patchOrDocumentId || \"id\" in patchOrDocumentId);\n    if (isPatch)\n      return this._add({ patch: patchOrDocumentId.serialize() });\n    if (isBuilder) {\n      const patch = patchOps(new Patch(patchOrDocumentId, {}, this.#client));\n      if (!(patch instanceof Patch))\n        throw new Error(\"function passed to `patch()` must return the patch\");\n      return this._add({ patch: patch.serialize() });\n    }\n    if (isMutationSelection) {\n      const patch = new Patch(patchOrDocumentId, patchOps || {}, this.#client);\n      return this._add({ patch: patch.serialize() });\n    }\n    return this._add({ patch: { id: patchOrDocumentId, ...patchOps } });\n  }\n}\nclass ObservableTransaction extends BaseTransaction {\n  #client;\n  constructor(operations, client, transactionId) {\n    super(operations, transactionId), this.#client = client;\n  }\n  /**\n   * Clones the transaction\n   */\n  clone() {\n    return new ObservableTransaction([...this.operations], this.#client, this.trxId);\n  }\n  commit(options) {\n    if (!this.#client)\n      throw new Error(\n        \"No `client` passed to transaction, either provide one or pass the transaction to a clients `mutate()` method\"\n      );\n    return this.#client.mutate(\n      this.serialize(),\n      Object.assign({ transactionId: this.trxId }, defaultMutateOptions, options || {})\n    );\n  }\n  patch(patchOrDocumentId, patchOps) {\n    const isBuilder = typeof patchOps == \"function\";\n    if (typeof patchOrDocumentId != \"string\" && patchOrDocumentId instanceof ObservablePatch)\n      return this._add({ patch: patchOrDocumentId.serialize() });\n    if (isBuilder) {\n      const patch = patchOps(new ObservablePatch(patchOrDocumentId, {}, this.#client));\n      if (!(patch instanceof ObservablePatch))\n        throw new Error(\"function passed to `patch()` must return the patch\");\n      return this._add({ patch: patch.serialize() });\n    }\n    return this._add({ patch: { id: patchOrDocumentId, ...patchOps } });\n  }\n}\nconst projectHeader = \"X-Sanity-Project-ID\";\nfunction requestOptions(config, overrides = {}) {\n  const headers2 = {}, token = overrides.token || config.token;\n  token && (headers2.Authorization = `Bearer ${token}`), !overrides.useGlobalApi && !config.useProjectHostname && config.projectId && (headers2[projectHeader] = config.projectId);\n  const withCredentials = !!(typeof overrides.withCredentials > \"u\" ? config.token || config.withCredentials : overrides.withCredentials), timeout = typeof overrides.timeout > \"u\" ? config.timeout : overrides.timeout;\n  return Object.assign({}, overrides, {\n    headers: Object.assign({}, headers2, overrides.headers || {}),\n    timeout: typeof timeout > \"u\" ? 5 * 60 * 1e3 : timeout,\n    proxy: overrides.proxy || config.proxy,\n    json: !0,\n    withCredentials,\n    fetch: typeof overrides.fetch == \"object\" && typeof config.fetch == \"object\" ? { ...config.fetch, ...overrides.fetch } : overrides.fetch || config.fetch\n  });\n}\nconst encodeQueryString = ({\n  query,\n  params = {},\n  options = {}\n}) => {\n  const searchParams = new URLSearchParams(), { tag, includeMutations, returnQuery, ...opts } = options;\n  tag && searchParams.append(\"tag\", tag), searchParams.append(\"query\", query);\n  for (const [key, value] of Object.entries(params))\n    searchParams.append(`$${key}`, JSON.stringify(value));\n  for (const [key, value] of Object.entries(opts))\n    value && searchParams.append(key, `${value}`);\n  return returnQuery === !1 && searchParams.append(\"returnQuery\", \"false\"), includeMutations === !1 && searchParams.append(\"includeMutations\", \"false\"), `?${searchParams}`;\n}, excludeFalsey = (param, defValue) => param === !1 ? void 0 : typeof param > \"u\" ? defValue : param, getMutationQuery = (options = {}) => ({\n  dryRun: options.dryRun,\n  returnIds: !0,\n  returnDocuments: excludeFalsey(options.returnDocuments, !0),\n  visibility: options.visibility || \"sync\",\n  autoGenerateArrayKeys: options.autoGenerateArrayKeys,\n  skipCrossDatasetReferenceValidation: options.skipCrossDatasetReferenceValidation\n}), isResponse = (event) => event.type === \"response\", getBody = (event) => event.body, indexBy = (docs, attr) => docs.reduce((indexed, doc) => (indexed[attr(doc)] = doc, indexed), /* @__PURE__ */ Object.create(null)), getQuerySizeLimit = 11264;\nfunction _fetch(client, httpRequest, _stega, query, _params = {}, options = {}) {\n  const stega = \"stega\" in options ? {\n    ..._stega || {},\n    ...typeof options.stega == \"boolean\" ? { enabled: options.stega } : options.stega || {}\n  } : _stega, params = stega.enabled ? (0,_chunks_es_stegaClean_js__WEBPACK_IMPORTED_MODULE_8__.stegaClean)(_params) : _params, mapResponse = options.filterResponse === !1 ? (res) => res : (res) => res.result, { cache, next, ...opts } = {\n    // Opt out of setting a `signal` on an internal `fetch` if one isn't provided.\n    // This is necessary in React Server Components to avoid opting out of Request Memoization.\n    useAbortSignal: typeof options.signal < \"u\",\n    // Set `resultSourceMap' when stega is enabled, as it's required for encoding.\n    resultSourceMap: stega.enabled ? \"withKeyArraySelector\" : options.resultSourceMap,\n    ...options,\n    // Default to not returning the query, unless `filterResponse` is `false`,\n    // or `returnQuery` is explicitly set. `true` is the default in Content Lake, so skip if truthy\n    returnQuery: options.filterResponse === !1 && options.returnQuery !== !1\n  }, reqOpts = typeof cache < \"u\" || typeof next < \"u\" ? { ...opts, fetch: { cache, next } } : opts, $request = _dataRequest(client, httpRequest, \"query\", { query, params }, reqOpts);\n  return stega.enabled ? $request.pipe(\n    (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_9__.combineLatestWith)(\n      (0,rxjs__WEBPACK_IMPORTED_MODULE_10__.from)(\n        __webpack_require__.e(/*! import() */ \"vendor-chunks/@sanity\").then(__webpack_require__.bind(__webpack_require__, /*! ./_chunks-es/stegaEncodeSourceMap.js */ \"(ssr)/./node_modules/@sanity/client/dist/_chunks-es/stegaEncodeSourceMap.js\")).then(function(n) {\n          return n.stegaEncodeSourceMap$1;\n        }).then(\n          ({ stegaEncodeSourceMap }) => stegaEncodeSourceMap\n        )\n      )\n    ),\n    (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_9__.map)(\n      ([res, stegaEncodeSourceMap]) => {\n        const result = stegaEncodeSourceMap(res.result, res.resultSourceMap, stega);\n        return mapResponse({ ...res, result });\n      }\n    )\n  ) : $request.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_9__.map)(mapResponse));\n}\nfunction _getDocument(client, httpRequest, id, opts = {}) {\n  const options = {\n    uri: _getDataUrl(client, \"doc\", id),\n    json: !0,\n    tag: opts.tag,\n    signal: opts.signal\n  };\n  return _requestObservable(client, httpRequest, options).pipe(\n    (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_9__.filter)(isResponse),\n    (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_9__.map)((event) => event.body.documents && event.body.documents[0])\n  );\n}\nfunction _getDocuments(client, httpRequest, ids, opts = {}) {\n  const options = {\n    uri: _getDataUrl(client, \"doc\", ids.join(\",\")),\n    json: !0,\n    tag: opts.tag,\n    signal: opts.signal\n  };\n  return _requestObservable(client, httpRequest, options).pipe(\n    (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_9__.filter)(isResponse),\n    (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_9__.map)((event) => {\n      const indexed = indexBy(event.body.documents || [], (doc) => doc._id);\n      return ids.map((id) => indexed[id] || null);\n    })\n  );\n}\nfunction _createIfNotExists(client, httpRequest, doc, options) {\n  return (0,_chunks_es_config_js__WEBPACK_IMPORTED_MODULE_7__.requireDocumentId)(\"createIfNotExists\", doc), _create(client, httpRequest, doc, \"createIfNotExists\", options);\n}\nfunction _createOrReplace(client, httpRequest, doc, options) {\n  return (0,_chunks_es_config_js__WEBPACK_IMPORTED_MODULE_7__.requireDocumentId)(\"createOrReplace\", doc), _create(client, httpRequest, doc, \"createOrReplace\", options);\n}\nfunction _delete(client, httpRequest, selection, options) {\n  return _dataRequest(\n    client,\n    httpRequest,\n    \"mutate\",\n    { mutations: [{ delete: getSelection(selection) }] },\n    options\n  );\n}\nfunction _mutate(client, httpRequest, mutations, options) {\n  let mut;\n  mutations instanceof Patch || mutations instanceof ObservablePatch ? mut = { patch: mutations.serialize() } : mutations instanceof Transaction || mutations instanceof ObservableTransaction ? mut = mutations.serialize() : mut = mutations;\n  const muts = Array.isArray(mut) ? mut : [mut], transactionId = options && options.transactionId || void 0;\n  return _dataRequest(client, httpRequest, \"mutate\", { mutations: muts, transactionId }, options);\n}\nfunction _action(client, httpRequest, actions, options) {\n  const acts = Array.isArray(actions) ? actions : [actions], transactionId = options && options.transactionId || void 0, skipCrossDatasetReferenceValidation = options && options.skipCrossDatasetReferenceValidation || void 0, dryRun = options && options.dryRun || void 0;\n  return _dataRequest(\n    client,\n    httpRequest,\n    \"actions\",\n    { actions: acts, transactionId, skipCrossDatasetReferenceValidation, dryRun },\n    options\n  );\n}\nfunction _dataRequest(client, httpRequest, endpoint, body, options = {}) {\n  const isMutation = endpoint === \"mutate\", isAction = endpoint === \"actions\", isQuery = endpoint === \"query\", strQuery = isMutation || isAction ? \"\" : encodeQueryString(body), useGet = !isMutation && !isAction && strQuery.length < getQuerySizeLimit, stringQuery = useGet ? strQuery : \"\", returnFirst = options.returnFirst, { timeout, token, tag, headers: headers2, returnQuery, lastLiveEventId, cacheMode } = options, uri = _getDataUrl(client, endpoint, stringQuery), reqOptions = {\n    method: useGet ? \"GET\" : \"POST\",\n    uri,\n    json: !0,\n    body: useGet ? void 0 : body,\n    query: isMutation && getMutationQuery(options),\n    timeout,\n    headers: headers2,\n    token,\n    tag,\n    returnQuery,\n    perspective: options.perspective,\n    resultSourceMap: options.resultSourceMap,\n    lastLiveEventId: Array.isArray(lastLiveEventId) ? lastLiveEventId[0] : lastLiveEventId,\n    cacheMode,\n    canUseCdn: isQuery,\n    signal: options.signal,\n    fetch: options.fetch,\n    useAbortSignal: options.useAbortSignal,\n    useCdn: options.useCdn\n  };\n  return _requestObservable(client, httpRequest, reqOptions).pipe(\n    (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_9__.filter)(isResponse),\n    (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_9__.map)(getBody),\n    (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_9__.map)((res) => {\n      if (!isMutation)\n        return res;\n      const results = res.results || [];\n      if (options.returnDocuments)\n        return returnFirst ? results[0] && results[0].document : results.map((mut) => mut.document);\n      const key = returnFirst ? \"documentId\" : \"documentIds\", ids = returnFirst ? results[0] && results[0].id : results.map((mut) => mut.id);\n      return {\n        transactionId: res.transactionId,\n        results,\n        [key]: ids\n      };\n    })\n  );\n}\nfunction _create(client, httpRequest, doc, op, options = {}) {\n  const mutation = { [op]: doc }, opts = Object.assign({ returnFirst: !0, returnDocuments: !0 }, options);\n  return _dataRequest(client, httpRequest, \"mutate\", { mutations: [mutation] }, opts);\n}\nfunction _requestObservable(client, httpRequest, options) {\n  const uri = options.url || options.uri, config = client.config(), canUseCdn = typeof options.canUseCdn > \"u\" ? [\"GET\", \"HEAD\"].indexOf(options.method || \"GET\") >= 0 && uri.indexOf(\"/data/\") === 0 : options.canUseCdn;\n  let useCdn = (options.useCdn ?? config.useCdn) && canUseCdn;\n  const tag = options.tag && config.requestTagPrefix ? [config.requestTagPrefix, options.tag].join(\".\") : options.tag || config.requestTagPrefix;\n  if (tag && options.tag !== null && (options.query = { tag: (0,_chunks_es_config_js__WEBPACK_IMPORTED_MODULE_7__.requestTag)(tag), ...options.query }), [\"GET\", \"HEAD\", \"POST\"].indexOf(options.method || \"GET\") >= 0 && uri.indexOf(\"/data/query/\") === 0) {\n    const resultSourceMap = options.resultSourceMap ?? config.resultSourceMap;\n    resultSourceMap !== void 0 && resultSourceMap !== !1 && (options.query = { resultSourceMap, ...options.query });\n    const perspectiveOption = options.perspective || config.perspective;\n    typeof perspectiveOption < \"u\" && ((0,_chunks_es_config_js__WEBPACK_IMPORTED_MODULE_7__.validateApiPerspective)(perspectiveOption), options.query = {\n      perspective: Array.isArray(perspectiveOption) ? perspectiveOption.join(\",\") : perspectiveOption,\n      ...options.query\n    }, perspectiveOption === \"previewDrafts\" && useCdn && (useCdn = !1, (0,_chunks_es_config_js__WEBPACK_IMPORTED_MODULE_7__.printCdnPreviewDraftsWarning)())), options.lastLiveEventId && (options.query = { ...options.query, lastLiveEventId: options.lastLiveEventId }), options.returnQuery === !1 && (options.query = { returnQuery: \"false\", ...options.query }), useCdn && options.cacheMode == \"noStale\" && (options.query = { cacheMode: \"noStale\", ...options.query });\n  }\n  const reqOptions = requestOptions(\n    config,\n    Object.assign({}, options, {\n      url: _getUrl(client, uri, useCdn)\n    })\n  ), request = new rxjs__WEBPACK_IMPORTED_MODULE_2__.Observable(\n    (subscriber) => httpRequest(reqOptions, config.requester).subscribe(subscriber)\n  );\n  return options.signal ? request.pipe(_withAbortSignal(options.signal)) : request;\n}\nfunction _request(client, httpRequest, options) {\n  return _requestObservable(client, httpRequest, options).pipe(\n    (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_9__.filter)((event) => event.type === \"response\"),\n    (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_9__.map)((event) => event.body)\n  );\n}\nfunction _getDataUrl(client, operation, path) {\n  const config = client.config(), catalog = (0,_chunks_es_config_js__WEBPACK_IMPORTED_MODULE_7__.hasDataset)(config), baseUri = `/${operation}/${catalog}`;\n  return `/data${path ? `${baseUri}/${path}` : baseUri}`.replace(/\\/($|\\?)/, \"$1\");\n}\nfunction _getUrl(client, uri, canUseCdn = !1) {\n  const { url, cdnUrl } = client.config();\n  return `${canUseCdn ? cdnUrl : url}/${uri.replace(/^\\//, \"\")}`;\n}\nfunction _withAbortSignal(signal) {\n  return (input) => new rxjs__WEBPACK_IMPORTED_MODULE_2__.Observable((observer) => {\n    const abort = () => observer.error(_createAbortError(signal));\n    if (signal && signal.aborted) {\n      abort();\n      return;\n    }\n    const subscription = input.subscribe(observer);\n    return signal.addEventListener(\"abort\", abort), () => {\n      signal.removeEventListener(\"abort\", abort), subscription.unsubscribe();\n    };\n  });\n}\nconst isDomExceptionSupported = !!globalThis.DOMException;\nfunction _createAbortError(signal) {\n  if (isDomExceptionSupported)\n    return new DOMException(signal?.reason ?? \"The operation was aborted.\", \"AbortError\");\n  const error = new Error(signal?.reason ?? \"The operation was aborted.\");\n  return error.name = \"AbortError\", error;\n}\nclass ObservableAssetsClient {\n  #client;\n  #httpRequest;\n  constructor(client, httpRequest) {\n    this.#client = client, this.#httpRequest = httpRequest;\n  }\n  upload(assetType, body, options) {\n    return _upload(this.#client, this.#httpRequest, assetType, body, options);\n  }\n}\nclass AssetsClient {\n  #client;\n  #httpRequest;\n  constructor(client, httpRequest) {\n    this.#client = client, this.#httpRequest = httpRequest;\n  }\n  upload(assetType, body, options) {\n    const observable2 = _upload(this.#client, this.#httpRequest, assetType, body, options);\n    return (0,rxjs__WEBPACK_IMPORTED_MODULE_11__.lastValueFrom)(\n      observable2.pipe(\n        (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_9__.filter)((event) => event.type === \"response\"),\n        (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_9__.map)(\n          (event) => event.body.document\n        )\n      )\n    );\n  }\n}\nfunction _upload(client, httpRequest, assetType, body, opts = {}) {\n  (0,_chunks_es_config_js__WEBPACK_IMPORTED_MODULE_7__.validateAssetType)(assetType);\n  let meta = opts.extract || void 0;\n  meta && !meta.length && (meta = [\"none\"]);\n  const dataset2 = (0,_chunks_es_config_js__WEBPACK_IMPORTED_MODULE_7__.hasDataset)(client.config()), assetEndpoint = assetType === \"image\" ? \"images\" : \"files\", options = optionsFromFile(opts, body), { tag, label, title, description, creditLine, filename, source } = options, query = {\n    label,\n    title,\n    description,\n    filename,\n    meta,\n    creditLine\n  };\n  return source && (query.sourceId = source.id, query.sourceName = source.name, query.sourceUrl = source.url), _requestObservable(client, httpRequest, {\n    tag,\n    method: \"POST\",\n    timeout: options.timeout || 0,\n    uri: `/assets/${assetEndpoint}/${dataset2}`,\n    headers: options.contentType ? { \"Content-Type\": options.contentType } : {},\n    query,\n    body\n  });\n}\nfunction optionsFromFile(opts, file) {\n  return typeof File > \"u\" || !(file instanceof File) ? opts : Object.assign(\n    {\n      filename: opts.preserveFilename === !1 ? void 0 : file.name,\n      contentType: file.type\n    },\n    opts\n  );\n}\nvar defaults = (obj, defaults2) => Object.keys(defaults2).concat(Object.keys(obj)).reduce((target, prop) => (target[prop] = typeof obj[prop] > \"u\" ? defaults2[prop] : obj[prop], target), {});\nconst pick = (obj, props) => props.reduce((selection, prop) => (typeof obj[prop] > \"u\" || (selection[prop] = obj[prop]), selection), {}), eventSourcePolyfill = (0,rxjs__WEBPACK_IMPORTED_MODULE_3__.defer)(() => Promise.all(/*! import() */[__webpack_require__.e(\"vendor-chunks/@sanity\"), __webpack_require__.e(\"vendor-chunks/eventsource\")]).then(__webpack_require__.t.bind(__webpack_require__, /*! @sanity/eventsource */ \"(ssr)/./node_modules/@sanity/eventsource/node.js\", 19))).pipe(\n  (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_9__.map)(({ default: EventSource2 }) => EventSource2),\n  (0,rxjs__WEBPACK_IMPORTED_MODULE_12__.shareReplay)(1)\n);\nfunction reconnectOnConnectionFailure() {\n  return function(source) {\n    return source.pipe(\n      (0,rxjs__WEBPACK_IMPORTED_MODULE_13__.catchError)((err, caught) => err instanceof ConnectionFailedError ? (0,rxjs__WEBPACK_IMPORTED_MODULE_14__.concat)((0,rxjs__WEBPACK_IMPORTED_MODULE_5__.of)({ type: \"reconnect\" }), (0,rxjs__WEBPACK_IMPORTED_MODULE_15__.timer)(1e3).pipe((0,rxjs__WEBPACK_IMPORTED_MODULE_6__.mergeMap)(() => caught))) : (0,rxjs__WEBPACK_IMPORTED_MODULE_16__.throwError)(() => err))\n    );\n  };\n}\nconst MAX_URL_LENGTH = 14800, possibleOptions = [\n  \"includePreviousRevision\",\n  \"includeResult\",\n  \"includeMutations\",\n  \"visibility\",\n  \"effectFormat\",\n  \"tag\"\n], defaultOptions = {\n  includeResult: !0\n};\nfunction _listen(query, params, opts = {}) {\n  const { url, token, withCredentials, requestTagPrefix } = this.config(), tag = opts.tag && requestTagPrefix ? [requestTagPrefix, opts.tag].join(\".\") : opts.tag, options = { ...defaults(opts, defaultOptions), tag }, listenOpts = pick(options, possibleOptions), qs = encodeQueryString({ query, params, options: { tag, ...listenOpts } }), uri = `${url}${_getDataUrl(this, \"listen\", qs)}`;\n  if (uri.length > MAX_URL_LENGTH)\n    return (0,rxjs__WEBPACK_IMPORTED_MODULE_16__.throwError)(() => new Error(\"Query too large for listener\"));\n  const listenFor = options.events ? options.events : [\"mutation\"], esOptions = {};\n  return (token || withCredentials) && (esOptions.withCredentials = !0), token && (esOptions.headers = {\n    Authorization: `Bearer ${token}`\n  }), connectEventSource(() => (\n    // use polyfill if there is no global EventSource or if we need to set headers\n    (typeof EventSource > \"u\" || esOptions.headers ? eventSourcePolyfill : (0,rxjs__WEBPACK_IMPORTED_MODULE_5__.of)(EventSource)).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_9__.map)((EventSource2) => new EventSource2(uri, esOptions)))\n  ), listenFor).pipe(\n    reconnectOnConnectionFailure(),\n    (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_9__.filter)((event) => listenFor.includes(event.type)),\n    (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_9__.map)(\n      (event) => ({\n        type: event.type,\n        ...\"data\" in event ? event.data : {}\n      })\n    )\n  );\n}\nconst requiredApiVersion = \"2021-03-25\";\nclass LiveClient {\n  #client;\n  constructor(client) {\n    this.#client = client;\n  }\n  /**\n   * Requires `apiVersion` to be `2021-03-25` or later.\n   */\n  events({\n    includeDrafts = !1,\n    tag: _tag\n  } = {}) {\n    const {\n      projectId,\n      apiVersion: _apiVersion,\n      token,\n      withCredentials,\n      requestTagPrefix\n    } = this.#client.config(), apiVersion = _apiVersion.replace(/^v/, \"\");\n    if (apiVersion !== \"X\" && apiVersion < requiredApiVersion)\n      throw new Error(\n        `The live events API requires API version ${requiredApiVersion} or later. The current API version is ${apiVersion}. Please update your API version to use this feature.`\n      );\n    if (includeDrafts && !token && !withCredentials)\n      throw new Error(\n        \"The live events API requires a token or withCredentials when 'includeDrafts: true'. Please update your client configuration. The token should have the lowest possible access role.\"\n      );\n    const path = _getDataUrl(this.#client, \"live/events\"), url = new URL(this.#client.getUrl(path, !1)), tag = _tag && requestTagPrefix ? [requestTagPrefix, _tag].join(\".\") : _tag;\n    tag && url.searchParams.set(\"tag\", tag), includeDrafts && url.searchParams.set(\"includeDrafts\", \"true\");\n    const esOptions = {};\n    includeDrafts && token && (esOptions.headers = {\n      Authorization: `Bearer ${token}`\n    }), includeDrafts && withCredentials && (esOptions.withCredentials = !0);\n    const events = connectEventSource(() => (\n      // use polyfill if there is no global EventSource or if we need to set headers\n      (typeof EventSource > \"u\" || esOptions.headers ? eventSourcePolyfill : (0,rxjs__WEBPACK_IMPORTED_MODULE_5__.of)(EventSource)).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_9__.map)((EventSource2) => new EventSource2(url.href, esOptions)))\n    ), [\n      \"message\",\n      \"restart\",\n      \"welcome\",\n      \"reconnect\"\n    ]).pipe(\n      reconnectOnConnectionFailure(),\n      (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_9__.map)((event) => {\n        if (event.type === \"message\") {\n          const { data, ...rest } = event;\n          return { ...rest, tags: data.tags };\n        }\n        return event;\n      })\n    ), checkCors = fetchObservable(url, {\n      method: \"OPTIONS\",\n      mode: \"cors\",\n      credentials: esOptions.withCredentials ? \"include\" : \"omit\",\n      headers: esOptions.headers\n    }).pipe(\n      (0,rxjs__WEBPACK_IMPORTED_MODULE_6__.mergeMap)(() => rxjs__WEBPACK_IMPORTED_MODULE_17__.EMPTY),\n      (0,rxjs__WEBPACK_IMPORTED_MODULE_13__.catchError)(() => {\n        throw new CorsOriginError({ projectId });\n      })\n    );\n    return (0,rxjs__WEBPACK_IMPORTED_MODULE_14__.concat)(checkCors, events);\n  }\n}\nfunction fetchObservable(url, init) {\n  return new rxjs__WEBPACK_IMPORTED_MODULE_2__.Observable((observer) => {\n    const controller = new AbortController(), signal = controller.signal;\n    return fetch(url, { ...init, signal: controller.signal }).then(\n      (response) => {\n        observer.next(response), observer.complete();\n      },\n      (err) => {\n        signal.aborted || observer.error(err);\n      }\n    ), () => controller.abort();\n  });\n}\nclass ObservableDatasetsClient {\n  #client;\n  #httpRequest;\n  constructor(client, httpRequest) {\n    this.#client = client, this.#httpRequest = httpRequest;\n  }\n  /**\n   * Create a new dataset with the given name\n   *\n   * @param name - Name of the dataset to create\n   * @param options - Options for the dataset\n   */\n  create(name2, options) {\n    return _modify(this.#client, this.#httpRequest, \"PUT\", name2, options);\n  }\n  /**\n   * Edit a dataset with the given name\n   *\n   * @param name - Name of the dataset to edit\n   * @param options - New options for the dataset\n   */\n  edit(name2, options) {\n    return _modify(this.#client, this.#httpRequest, \"PATCH\", name2, options);\n  }\n  /**\n   * Delete a dataset with the given name\n   *\n   * @param name - Name of the dataset to delete\n   */\n  delete(name2) {\n    return _modify(this.#client, this.#httpRequest, \"DELETE\", name2);\n  }\n  /**\n   * Fetch a list of datasets for the configured project\n   */\n  list() {\n    return _request(this.#client, this.#httpRequest, {\n      uri: \"/datasets\",\n      tag: null\n    });\n  }\n}\nclass DatasetsClient {\n  #client;\n  #httpRequest;\n  constructor(client, httpRequest) {\n    this.#client = client, this.#httpRequest = httpRequest;\n  }\n  /**\n   * Create a new dataset with the given name\n   *\n   * @param name - Name of the dataset to create\n   * @param options - Options for the dataset\n   */\n  create(name2, options) {\n    return (0,rxjs__WEBPACK_IMPORTED_MODULE_11__.lastValueFrom)(\n      _modify(this.#client, this.#httpRequest, \"PUT\", name2, options)\n    );\n  }\n  /**\n   * Edit a dataset with the given name\n   *\n   * @param name - Name of the dataset to edit\n   * @param options - New options for the dataset\n   */\n  edit(name2, options) {\n    return (0,rxjs__WEBPACK_IMPORTED_MODULE_11__.lastValueFrom)(\n      _modify(this.#client, this.#httpRequest, \"PATCH\", name2, options)\n    );\n  }\n  /**\n   * Delete a dataset with the given name\n   *\n   * @param name - Name of the dataset to delete\n   */\n  delete(name2) {\n    return (0,rxjs__WEBPACK_IMPORTED_MODULE_11__.lastValueFrom)(_modify(this.#client, this.#httpRequest, \"DELETE\", name2));\n  }\n  /**\n   * Fetch a list of datasets for the configured project\n   */\n  list() {\n    return (0,rxjs__WEBPACK_IMPORTED_MODULE_11__.lastValueFrom)(\n      _request(this.#client, this.#httpRequest, { uri: \"/datasets\", tag: null })\n    );\n  }\n}\nfunction _modify(client, httpRequest, method, name2, options) {\n  return (0,_chunks_es_config_js__WEBPACK_IMPORTED_MODULE_7__.dataset)(name2), _request(client, httpRequest, {\n    method,\n    uri: `/datasets/${name2}`,\n    body: options,\n    tag: null\n  });\n}\nclass ObservableProjectsClient {\n  #client;\n  #httpRequest;\n  constructor(client, httpRequest) {\n    this.#client = client, this.#httpRequest = httpRequest;\n  }\n  list(options) {\n    const uri = options?.includeMembers === !1 ? \"/projects?includeMembers=false\" : \"/projects\";\n    return _request(this.#client, this.#httpRequest, { uri });\n  }\n  /**\n   * Fetch a project by project ID\n   *\n   * @param projectId - ID of the project to fetch\n   */\n  getById(projectId) {\n    return _request(this.#client, this.#httpRequest, { uri: `/projects/${projectId}` });\n  }\n}\nclass ProjectsClient {\n  #client;\n  #httpRequest;\n  constructor(client, httpRequest) {\n    this.#client = client, this.#httpRequest = httpRequest;\n  }\n  list(options) {\n    const uri = options?.includeMembers === !1 ? \"/projects?includeMembers=false\" : \"/projects\";\n    return (0,rxjs__WEBPACK_IMPORTED_MODULE_11__.lastValueFrom)(_request(this.#client, this.#httpRequest, { uri }));\n  }\n  /**\n   * Fetch a project by project ID\n   *\n   * @param projectId - ID of the project to fetch\n   */\n  getById(projectId) {\n    return (0,rxjs__WEBPACK_IMPORTED_MODULE_11__.lastValueFrom)(\n      _request(this.#client, this.#httpRequest, { uri: `/projects/${projectId}` })\n    );\n  }\n}\nclass ObservableUsersClient {\n  #client;\n  #httpRequest;\n  constructor(client, httpRequest) {\n    this.#client = client, this.#httpRequest = httpRequest;\n  }\n  /**\n   * Fetch a user by user ID\n   *\n   * @param id - User ID of the user to fetch. If `me` is provided, a minimal response including the users role is returned.\n   */\n  getById(id) {\n    return _request(\n      this.#client,\n      this.#httpRequest,\n      { uri: `/users/${id}` }\n    );\n  }\n}\nclass UsersClient {\n  #client;\n  #httpRequest;\n  constructor(client, httpRequest) {\n    this.#client = client, this.#httpRequest = httpRequest;\n  }\n  /**\n   * Fetch a user by user ID\n   *\n   * @param id - User ID of the user to fetch. If `me` is provided, a minimal response including the users role is returned.\n   */\n  getById(id) {\n    return (0,rxjs__WEBPACK_IMPORTED_MODULE_11__.lastValueFrom)(\n      _request(this.#client, this.#httpRequest, {\n        uri: `/users/${id}`\n      })\n    );\n  }\n}\nclass ObservableSanityClient {\n  assets;\n  datasets;\n  live;\n  projects;\n  users;\n  /**\n   * Private properties\n   */\n  #clientConfig;\n  #httpRequest;\n  /**\n   * Instance properties\n   */\n  listen = _listen;\n  constructor(httpRequest, config = _chunks_es_config_js__WEBPACK_IMPORTED_MODULE_7__.defaultConfig) {\n    this.config(config), this.#httpRequest = httpRequest, this.assets = new ObservableAssetsClient(this, this.#httpRequest), this.datasets = new ObservableDatasetsClient(this, this.#httpRequest), this.live = new LiveClient(this), this.projects = new ObservableProjectsClient(this, this.#httpRequest), this.users = new ObservableUsersClient(this, this.#httpRequest);\n  }\n  /**\n   * Clone the client - returns a new instance\n   */\n  clone() {\n    return new ObservableSanityClient(this.#httpRequest, this.config());\n  }\n  config(newConfig) {\n    if (newConfig === void 0)\n      return { ...this.#clientConfig };\n    if (this.#clientConfig && this.#clientConfig.allowReconfigure === !1)\n      throw new Error(\n        \"Existing client instance cannot be reconfigured - use `withConfig(newConfig)` to return a new client\"\n      );\n    return this.#clientConfig = (0,_chunks_es_config_js__WEBPACK_IMPORTED_MODULE_7__.initConfig)(newConfig, this.#clientConfig || {}), this;\n  }\n  /**\n   * Clone the client with a new (partial) configuration.\n   *\n   * @param newConfig - New client configuration properties, shallowly merged with existing configuration\n   */\n  withConfig(newConfig) {\n    const thisConfig = this.config();\n    return new ObservableSanityClient(this.#httpRequest, {\n      ...thisConfig,\n      ...newConfig,\n      stega: {\n        ...thisConfig.stega || {},\n        ...typeof newConfig?.stega == \"boolean\" ? { enabled: newConfig.stega } : newConfig?.stega || {}\n      }\n    });\n  }\n  fetch(query, params, options) {\n    return _fetch(\n      this,\n      this.#httpRequest,\n      this.#clientConfig.stega,\n      query,\n      params,\n      options\n    );\n  }\n  /**\n   * Fetch a single document with the given ID.\n   *\n   * @param id - Document ID to fetch\n   * @param options - Request options\n   */\n  getDocument(id, options) {\n    return _getDocument(this, this.#httpRequest, id, options);\n  }\n  /**\n   * Fetch multiple documents in one request.\n   * Should be used sparingly - performing a query is usually a better option.\n   * The order/position of documents is preserved based on the original array of IDs.\n   * If any of the documents are missing, they will be replaced by a `null` entry in the returned array\n   *\n   * @param ids - Document IDs to fetch\n   * @param options - Request options\n   */\n  getDocuments(ids, options) {\n    return _getDocuments(this, this.#httpRequest, ids, options);\n  }\n  create(document, options) {\n    return _create(this, this.#httpRequest, document, \"create\", options);\n  }\n  createIfNotExists(document, options) {\n    return _createIfNotExists(this, this.#httpRequest, document, options);\n  }\n  createOrReplace(document, options) {\n    return _createOrReplace(this, this.#httpRequest, document, options);\n  }\n  delete(selection, options) {\n    return _delete(this, this.#httpRequest, selection, options);\n  }\n  mutate(operations, options) {\n    return _mutate(this, this.#httpRequest, operations, options);\n  }\n  /**\n   * Create a new buildable patch of operations to perform\n   *\n   * @param selection - Document ID, an array of document IDs, or an object with `query` and optional `params`, defining which document(s) to patch\n   * @param operations - Optional object of patch operations to initialize the patch instance with\n   * @returns Patch instance - call `.commit()` to perform the operations defined\n   */\n  patch(selection, operations) {\n    return new ObservablePatch(selection, operations, this);\n  }\n  /**\n   * Create a new transaction of mutations\n   *\n   * @param operations - Optional array of mutation operations to initialize the transaction instance with\n   */\n  transaction(operations) {\n    return new ObservableTransaction(operations, this);\n  }\n  /**\n   * Perform action operations against the configured dataset\n   *\n   * @param operations - Action operation(s) to execute\n   * @param options - Action options\n   */\n  action(operations, options) {\n    return _action(this, this.#httpRequest, operations, options);\n  }\n  /**\n   * Perform an HTTP request against the Sanity API\n   *\n   * @param options - Request options\n   */\n  request(options) {\n    return _request(this, this.#httpRequest, options);\n  }\n  /**\n   * Get a Sanity API URL for the URI provided\n   *\n   * @param uri - URI/path to build URL for\n   * @param canUseCdn - Whether or not to allow using the API CDN for this route\n   */\n  getUrl(uri, canUseCdn) {\n    return _getUrl(this, uri, canUseCdn);\n  }\n  /**\n   * Get a Sanity API URL for the data operation and path provided\n   *\n   * @param operation - Data operation (eg `query`, `mutate`, `listen` or similar)\n   * @param path - Path to append after the operation\n   */\n  getDataUrl(operation, path) {\n    return _getDataUrl(this, operation, path);\n  }\n}\nclass SanityClient {\n  assets;\n  datasets;\n  live;\n  projects;\n  users;\n  /**\n   * Observable version of the Sanity client, with the same configuration as the promise-based one\n   */\n  observable;\n  /**\n   * Private properties\n   */\n  #clientConfig;\n  #httpRequest;\n  /**\n   * Instance properties\n   */\n  listen = _listen;\n  constructor(httpRequest, config = _chunks_es_config_js__WEBPACK_IMPORTED_MODULE_7__.defaultConfig) {\n    this.config(config), this.#httpRequest = httpRequest, this.assets = new AssetsClient(this, this.#httpRequest), this.datasets = new DatasetsClient(this, this.#httpRequest), this.live = new LiveClient(this), this.projects = new ProjectsClient(this, this.#httpRequest), this.users = new UsersClient(this, this.#httpRequest), this.observable = new ObservableSanityClient(httpRequest, config);\n  }\n  /**\n   * Clone the client - returns a new instance\n   */\n  clone() {\n    return new SanityClient(this.#httpRequest, this.config());\n  }\n  config(newConfig) {\n    if (newConfig === void 0)\n      return { ...this.#clientConfig };\n    if (this.#clientConfig && this.#clientConfig.allowReconfigure === !1)\n      throw new Error(\n        \"Existing client instance cannot be reconfigured - use `withConfig(newConfig)` to return a new client\"\n      );\n    return this.observable && this.observable.config(newConfig), this.#clientConfig = (0,_chunks_es_config_js__WEBPACK_IMPORTED_MODULE_7__.initConfig)(newConfig, this.#clientConfig || {}), this;\n  }\n  /**\n   * Clone the client with a new (partial) configuration.\n   *\n   * @param newConfig - New client configuration properties, shallowly merged with existing configuration\n   */\n  withConfig(newConfig) {\n    const thisConfig = this.config();\n    return new SanityClient(this.#httpRequest, {\n      ...thisConfig,\n      ...newConfig,\n      stega: {\n        ...thisConfig.stega || {},\n        ...typeof newConfig?.stega == \"boolean\" ? { enabled: newConfig.stega } : newConfig?.stega || {}\n      }\n    });\n  }\n  fetch(query, params, options) {\n    return (0,rxjs__WEBPACK_IMPORTED_MODULE_11__.lastValueFrom)(\n      _fetch(\n        this,\n        this.#httpRequest,\n        this.#clientConfig.stega,\n        query,\n        params,\n        options\n      )\n    );\n  }\n  /**\n   * Fetch a single document with the given ID.\n   *\n   * @param id - Document ID to fetch\n   * @param options - Request options\n   */\n  getDocument(id, options) {\n    return (0,rxjs__WEBPACK_IMPORTED_MODULE_11__.lastValueFrom)(_getDocument(this, this.#httpRequest, id, options));\n  }\n  /**\n   * Fetch multiple documents in one request.\n   * Should be used sparingly - performing a query is usually a better option.\n   * The order/position of documents is preserved based on the original array of IDs.\n   * If any of the documents are missing, they will be replaced by a `null` entry in the returned array\n   *\n   * @param ids - Document IDs to fetch\n   * @param options - Request options\n   */\n  getDocuments(ids, options) {\n    return (0,rxjs__WEBPACK_IMPORTED_MODULE_11__.lastValueFrom)(_getDocuments(this, this.#httpRequest, ids, options));\n  }\n  create(document, options) {\n    return (0,rxjs__WEBPACK_IMPORTED_MODULE_11__.lastValueFrom)(\n      _create(this, this.#httpRequest, document, \"create\", options)\n    );\n  }\n  createIfNotExists(document, options) {\n    return (0,rxjs__WEBPACK_IMPORTED_MODULE_11__.lastValueFrom)(\n      _createIfNotExists(this, this.#httpRequest, document, options)\n    );\n  }\n  createOrReplace(document, options) {\n    return (0,rxjs__WEBPACK_IMPORTED_MODULE_11__.lastValueFrom)(\n      _createOrReplace(this, this.#httpRequest, document, options)\n    );\n  }\n  delete(selection, options) {\n    return (0,rxjs__WEBPACK_IMPORTED_MODULE_11__.lastValueFrom)(_delete(this, this.#httpRequest, selection, options));\n  }\n  mutate(operations, options) {\n    return (0,rxjs__WEBPACK_IMPORTED_MODULE_11__.lastValueFrom)(_mutate(this, this.#httpRequest, operations, options));\n  }\n  /**\n   * Create a new buildable patch of operations to perform\n   *\n   * @param selection - Document ID, an array of document IDs, or an object with `query` and optional `params`, defining which document(s) to patch\n   * @param operations - Optional object of patch operations to initialize the patch instance with\n   * @returns Patch instance - call `.commit()` to perform the operations defined\n   */\n  patch(documentId, operations) {\n    return new Patch(documentId, operations, this);\n  }\n  /**\n   * Create a new transaction of mutations\n   *\n   * @param operations - Optional array of mutation operations to initialize the transaction instance with\n   */\n  transaction(operations) {\n    return new Transaction(operations, this);\n  }\n  /**\n   * Perform action operations against the configured dataset\n   * Returns a promise that resolves to the transaction result\n   *\n   * @param operations - Action operation(s) to execute\n   * @param options - Action options\n   */\n  action(operations, options) {\n    return (0,rxjs__WEBPACK_IMPORTED_MODULE_11__.lastValueFrom)(_action(this, this.#httpRequest, operations, options));\n  }\n  /**\n   * Perform a request against the Sanity API\n   * NOTE: Only use this for Sanity API endpoints, not for your own APIs!\n   *\n   * @param options - Request options\n   * @returns Promise resolving to the response body\n   */\n  request(options) {\n    return (0,rxjs__WEBPACK_IMPORTED_MODULE_11__.lastValueFrom)(_request(this, this.#httpRequest, options));\n  }\n  /**\n   * Perform an HTTP request a `/data` sub-endpoint\n   * NOTE: Considered internal, thus marked as deprecated. Use `request` instead.\n   *\n   * @deprecated - Use `request()` or your own HTTP library instead\n   * @param endpoint - Endpoint to hit (mutate, query etc)\n   * @param body - Request body\n   * @param options - Request options\n   * @internal\n   */\n  dataRequest(endpoint, body, options) {\n    return (0,rxjs__WEBPACK_IMPORTED_MODULE_11__.lastValueFrom)(_dataRequest(this, this.#httpRequest, endpoint, body, options));\n  }\n  /**\n   * Get a Sanity API URL for the URI provided\n   *\n   * @param uri - URI/path to build URL for\n   * @param canUseCdn - Whether or not to allow using the API CDN for this route\n   */\n  getUrl(uri, canUseCdn) {\n    return _getUrl(this, uri, canUseCdn);\n  }\n  /**\n   * Get a Sanity API URL for the data operation and path provided\n   *\n   * @param operation - Data operation (eg `query`, `mutate`, `listen` or similar)\n   * @param path - Path to append after the operation\n   */\n  getDataUrl(operation, path) {\n    return _getDataUrl(this, operation, path);\n  }\n}\nfunction defineCreateClientExports(envMiddleware, ClassConstructor) {\n  return { requester: defineHttpRequest(envMiddleware), createClient: (config) => {\n    const clientRequester = defineHttpRequest(envMiddleware);\n    return new ClassConstructor(\n      (options, requester2) => (requester2 || clientRequester)({\n        maxRedirects: 0,\n        maxRetries: config.maxRetries,\n        retryDelay: config.retryDelay,\n        ...options\n      }),\n      config\n    );\n  } };\n}\nfunction defineDeprecatedCreateClient(createClient2) {\n  return function(config) {\n    return (0,_chunks_es_config_js__WEBPACK_IMPORTED_MODULE_7__.printNoDefaultExport)(), createClient2(config);\n  };\n}\nvar name = \"@sanity/client\", version = \"6.27.2\";\nconst middleware = [\n  (0,get_it_middleware__WEBPACK_IMPORTED_MODULE_1__.debug)({ verbose: !0, namespace: \"sanity:client\" }),\n  (0,get_it_middleware__WEBPACK_IMPORTED_MODULE_1__.headers)({ \"User-Agent\": `${name} ${version}` }),\n  // Enable keep-alive, and in addition limit the number of sockets that can be opened.\n  // This avoids opening too many connections to the server if someone tries to execute\n  // a bunch of requests in parallel. It's recommended to have a concurrency limit\n  // at a \"higher limit\" (i.e. you shouldn't actually execute hundreds of requests in parallel),\n  // and this is mainly to minimize the impact for the network and server.\n  //\n  // We're currently matching the same defaults as browsers:\n  // https://stackoverflow.com/questions/26003756/is-there-a-limit-practical-or-otherwise-to-the-number-of-web-sockets-a-page-op\n  (0,get_it_middleware__WEBPACK_IMPORTED_MODULE_1__.agent)({\n    keepAlive: !0,\n    maxSockets: 30,\n    maxTotalSockets: 256\n  })\n], exp = defineCreateClientExports(middleware, SanityClient), requester = exp.requester, createClient = exp.createClient, deprecatedCreateClient = defineDeprecatedCreateClient(createClient);\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNhbml0eS9jbGllbnQvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBK0I7QUFDZTtBQUNvRTtBQUNtQztBQUM3RjtBQUNRO0FBQzBNO0FBQzFRO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsWUFBWSxJQUFJLGFBQWE7QUFDM0Q7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEtBQUs7QUFDTDtBQUNBLFNBQVMscUJBQXFCLDJCQUEyQix1QkFBdUIsRUFBRSxTQUFTO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELGtCQUFrQjtBQUNsRSxZQUFZLFdBQVcsY0FBYyxTQUFTLG1CQUFtQixlQUFlLEVBQUUsY0FBYztBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixXQUFXO0FBQzNCO0FBQ0EsNERBQTRELFVBQVU7QUFDdEU7QUFDQSxjQUFjLFNBQVM7QUFDdkIsaU5BQWlOLElBQUk7QUFDck4sTUFBTTtBQUNOLDhIQUE4SCxJQUFJO0FBQ2xJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDZDQUFLO0FBQ2QsSUFBSSx3REFBSyxHQUFHLGFBQWE7QUFDekI7QUFDQTtBQUNBLElBQUksOERBQVc7QUFDZixJQUFJLCtEQUFZ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VywwRUFBb0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLHdEQUFLLEdBQUcseUNBQXlDO0FBQ25ELEVBQUUsMERBQU8sR0FBRyxpQkFBaUIsTUFBTSxFQUFFLFFBQVEsR0FBRztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSx3REFBSztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQXlCRTtBQUNGIiwic291cmNlcyI6WyJHOlxcTXkgQ2FyZWVyXFxXRUIgQU5EIE1PQklMRSBBUFAgREVWRUxPUEVNRU5UICAoSFRNTCxDU1MsIEpTIClcXEZyb250LUVuZCBEZXZlbG9wZW1lbnRcXEZpbmFsIFByb2plY3RcXEZyb250ZW5kXFxub2RlX21vZHVsZXNcXEBzYW5pdHlcXGNsaWVudFxcZGlzdFxcaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZ2V0SXQgfSBmcm9tIFwiZ2V0LWl0XCI7XG5pbXBvcnQgeyBhZGFwdGVyLCBlbnZpcm9ubWVudCB9IGZyb20gXCJnZXQtaXRcIjtcbmltcG9ydCB7IHJldHJ5LCBqc29uUmVxdWVzdCwganNvblJlc3BvbnNlLCBwcm9ncmVzcywgb2JzZXJ2YWJsZSwgZGVidWcsIGhlYWRlcnMsIGFnZW50IH0gZnJvbSBcImdldC1pdC9taWRkbGV3YXJlXCI7XG5pbXBvcnQgeyBPYnNlcnZhYmxlLCBkZWZlciwgaXNPYnNlcnZhYmxlLCBvZiwgbWVyZ2VNYXAsIGZyb20sIGxhc3RWYWx1ZUZyb20sIHNoYXJlUmVwbGF5LCBjYXRjaEVycm9yLCBjb25jYXQsIHRpbWVyLCB0aHJvd0Vycm9yLCBFTVBUWSB9IGZyb20gXCJyeGpzXCI7XG5pbXBvcnQgeyBzdGVnYUNsZWFuIH0gZnJvbSBcIi4vX2NodW5rcy1lcy9zdGVnYUNsZWFuLmpzXCI7XG5pbXBvcnQgeyBjb21iaW5lTGF0ZXN0V2l0aCwgbWFwLCBmaWx0ZXIgfSBmcm9tIFwicnhqcy9vcGVyYXRvcnNcIjtcbmltcG9ydCB7IHZhbGlkYXRlT2JqZWN0LCB2YWxpZGF0ZUluc2VydCwgcmVxdWlyZURvY3VtZW50SWQsIHZhbGlkYXRlRG9jdW1lbnRJZCwgcmVxdWVzdFRhZywgdmFsaWRhdGVBcGlQZXJzcGVjdGl2ZSwgcHJpbnRDZG5QcmV2aWV3RHJhZnRzV2FybmluZywgaGFzRGF0YXNldCwgdmFsaWRhdGVBc3NldFR5cGUsIGRhdGFzZXQsIGRlZmF1bHRDb25maWcsIGluaXRDb25maWcsIHByaW50Tm9EZWZhdWx0RXhwb3J0IH0gZnJvbSBcIi4vX2NodW5rcy1lcy9jb25maWcuanNcIjtcbmNsYXNzIENsaWVudEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICByZXNwb25zZTtcbiAgc3RhdHVzQ29kZSA9IDQwMDtcbiAgcmVzcG9uc2VCb2R5O1xuICBkZXRhaWxzO1xuICBjb25zdHJ1Y3RvcihyZXMpIHtcbiAgICBjb25zdCBwcm9wcyA9IGV4dHJhY3RFcnJvclByb3BzKHJlcyk7XG4gICAgc3VwZXIocHJvcHMubWVzc2FnZSksIE9iamVjdC5hc3NpZ24odGhpcywgcHJvcHMpO1xuICB9XG59XG5jbGFzcyBTZXJ2ZXJFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgcmVzcG9uc2U7XG4gIHN0YXR1c0NvZGUgPSA1MDA7XG4gIHJlc3BvbnNlQm9keTtcbiAgZGV0YWlscztcbiAgY29uc3RydWN0b3IocmVzKSB7XG4gICAgY29uc3QgcHJvcHMgPSBleHRyYWN0RXJyb3JQcm9wcyhyZXMpO1xuICAgIHN1cGVyKHByb3BzLm1lc3NhZ2UpLCBPYmplY3QuYXNzaWduKHRoaXMsIHByb3BzKTtcbiAgfVxufVxuZnVuY3Rpb24gZXh0cmFjdEVycm9yUHJvcHMocmVzKSB7XG4gIGNvbnN0IGJvZHkgPSByZXMuYm9keSwgcHJvcHMgPSB7XG4gICAgcmVzcG9uc2U6IHJlcyxcbiAgICBzdGF0dXNDb2RlOiByZXMuc3RhdHVzQ29kZSxcbiAgICByZXNwb25zZUJvZHk6IHN0cmluZ2lmeUJvZHkoYm9keSwgcmVzKSxcbiAgICBtZXNzYWdlOiBcIlwiLFxuICAgIGRldGFpbHM6IHZvaWQgMFxuICB9O1xuICBpZiAoYm9keS5lcnJvciAmJiBib2R5Lm1lc3NhZ2UpXG4gICAgcmV0dXJuIHByb3BzLm1lc3NhZ2UgPSBgJHtib2R5LmVycm9yfSAtICR7Ym9keS5tZXNzYWdlfWAsIHByb3BzO1xuICBpZiAoaXNNdXRhdGlvbkVycm9yKGJvZHkpIHx8IGlzQWN0aW9uRXJyb3IoYm9keSkpIHtcbiAgICBjb25zdCBhbGxJdGVtcyA9IGJvZHkuZXJyb3IuaXRlbXMgfHwgW10sIGl0ZW1zID0gYWxsSXRlbXMuc2xpY2UoMCwgNSkubWFwKChpdGVtKSA9PiBpdGVtLmVycm9yPy5kZXNjcmlwdGlvbikuZmlsdGVyKEJvb2xlYW4pO1xuICAgIGxldCBpdGVtc1N0ciA9IGl0ZW1zLmxlbmd0aCA/IGA6XG4tICR7aXRlbXMuam9pbihgXG4tIGApfWAgOiBcIlwiO1xuICAgIHJldHVybiBhbGxJdGVtcy5sZW5ndGggPiA1ICYmIChpdGVtc1N0ciArPSBgXG4uLi5hbmQgJHthbGxJdGVtcy5sZW5ndGggLSA1fSBtb3JlYCksIHByb3BzLm1lc3NhZ2UgPSBgJHtib2R5LmVycm9yLmRlc2NyaXB0aW9ufSR7aXRlbXNTdHJ9YCwgcHJvcHMuZGV0YWlscyA9IGJvZHkuZXJyb3IsIHByb3BzO1xuICB9XG4gIHJldHVybiBib2R5LmVycm9yICYmIGJvZHkuZXJyb3IuZGVzY3JpcHRpb24gPyAocHJvcHMubWVzc2FnZSA9IGJvZHkuZXJyb3IuZGVzY3JpcHRpb24sIHByb3BzLmRldGFpbHMgPSBib2R5LmVycm9yLCBwcm9wcykgOiAocHJvcHMubWVzc2FnZSA9IGJvZHkuZXJyb3IgfHwgYm9keS5tZXNzYWdlIHx8IGh0dHBFcnJvck1lc3NhZ2UocmVzKSwgcHJvcHMpO1xufVxuZnVuY3Rpb24gaXNNdXRhdGlvbkVycm9yKGJvZHkpIHtcbiAgcmV0dXJuIGlzUGxhaW5PYmplY3QoYm9keSkgJiYgaXNQbGFpbk9iamVjdChib2R5LmVycm9yKSAmJiBib2R5LmVycm9yLnR5cGUgPT09IFwibXV0YXRpb25FcnJvclwiICYmIHR5cGVvZiBib2R5LmVycm9yLmRlc2NyaXB0aW9uID09IFwic3RyaW5nXCI7XG59XG5mdW5jdGlvbiBpc0FjdGlvbkVycm9yKGJvZHkpIHtcbiAgcmV0dXJuIGlzUGxhaW5PYmplY3QoYm9keSkgJiYgaXNQbGFpbk9iamVjdChib2R5LmVycm9yKSAmJiBib2R5LmVycm9yLnR5cGUgPT09IFwiYWN0aW9uRXJyb3JcIiAmJiB0eXBlb2YgYm9keS5lcnJvci5kZXNjcmlwdGlvbiA9PSBcInN0cmluZ1wiO1xufVxuZnVuY3Rpb24gaXNQbGFpbk9iamVjdChvYmopIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmogPT0gXCJvYmplY3RcIiAmJiBvYmogIT09IG51bGwgJiYgIUFycmF5LmlzQXJyYXkob2JqKTtcbn1cbmZ1bmN0aW9uIGh0dHBFcnJvck1lc3NhZ2UocmVzKSB7XG4gIGNvbnN0IHN0YXR1c01lc3NhZ2UgPSByZXMuc3RhdHVzTWVzc2FnZSA/IGAgJHtyZXMuc3RhdHVzTWVzc2FnZX1gIDogXCJcIjtcbiAgcmV0dXJuIGAke3Jlcy5tZXRob2R9LXJlcXVlc3QgdG8gJHtyZXMudXJsfSByZXN1bHRlZCBpbiBIVFRQICR7cmVzLnN0YXR1c0NvZGV9JHtzdGF0dXNNZXNzYWdlfWA7XG59XG5mdW5jdGlvbiBzdHJpbmdpZnlCb2R5KGJvZHksIHJlcykge1xuICByZXR1cm4gKHJlcy5oZWFkZXJzW1wiY29udGVudC10eXBlXCJdIHx8IFwiXCIpLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihcImFwcGxpY2F0aW9uL2pzb25cIikgIT09IC0xID8gSlNPTi5zdHJpbmdpZnkoYm9keSwgbnVsbCwgMikgOiBib2R5O1xufVxuY2xhc3MgQ29yc09yaWdpbkVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBwcm9qZWN0SWQ7XG4gIGFkZE9yaWdpblVybDtcbiAgY29uc3RydWN0b3IoeyBwcm9qZWN0SWQgfSkge1xuICAgIHN1cGVyKFwiQ29yc09yaWdpbkVycm9yXCIpLCB0aGlzLm5hbWUgPSBcIkNvcnNPcmlnaW5FcnJvclwiLCB0aGlzLnByb2plY3RJZCA9IHByb2plY3RJZDtcbiAgICBjb25zdCB1cmwgPSBuZXcgVVJMKGBodHRwczovL3Nhbml0eS5pby9tYW5hZ2UvcHJvamVjdC8ke3Byb2plY3RJZH0vYXBpYCk7XG4gICAgaWYgKHR5cGVvZiBsb2NhdGlvbiA8IFwidVwiKSB7XG4gICAgICBjb25zdCB7IG9yaWdpbiB9ID0gbG9jYXRpb247XG4gICAgICB1cmwuc2VhcmNoUGFyYW1zLnNldChcImNvcnNcIiwgXCJhZGRcIiksIHVybC5zZWFyY2hQYXJhbXMuc2V0KFwib3JpZ2luXCIsIG9yaWdpbiksIHRoaXMuYWRkT3JpZ2luVXJsID0gdXJsLCB0aGlzLm1lc3NhZ2UgPSBgVGhlIGN1cnJlbnQgb3JpZ2luIGlzIG5vdCBhbGxvd2VkIHRvIGNvbm5lY3QgdG8gdGhlIExpdmUgQ29udGVudCBBUEkuIEFkZCBpdCBoZXJlOiAke3VybH1gO1xuICAgIH0gZWxzZVxuICAgICAgdGhpcy5tZXNzYWdlID0gYFRoZSBjdXJyZW50IG9yaWdpbiBpcyBub3QgYWxsb3dlZCB0byBjb25uZWN0IHRvIHRoZSBMaXZlIENvbnRlbnQgQVBJLiBDaGFuZ2UgeW91ciBjb25maWd1cmF0aW9uIGhlcmU6ICR7dXJsfWA7XG4gIH1cbn1cbmNvbnN0IGh0dHBFcnJvciA9IHtcbiAgb25SZXNwb25zZTogKHJlcykgPT4ge1xuICAgIGlmIChyZXMuc3RhdHVzQ29kZSA+PSA1MDApXG4gICAgICB0aHJvdyBuZXcgU2VydmVyRXJyb3IocmVzKTtcbiAgICBpZiAocmVzLnN0YXR1c0NvZGUgPj0gNDAwKVxuICAgICAgdGhyb3cgbmV3IENsaWVudEVycm9yKHJlcyk7XG4gICAgcmV0dXJuIHJlcztcbiAgfVxufTtcbmZ1bmN0aW9uIHByaW50V2FybmluZ3MoKSB7XG4gIGNvbnN0IHNlZW4gPSB7fTtcbiAgcmV0dXJuIHtcbiAgICBvblJlc3BvbnNlOiAocmVzKSA9PiB7XG4gICAgICBjb25zdCB3YXJuID0gcmVzLmhlYWRlcnNbXCJ4LXNhbml0eS13YXJuaW5nXCJdLCB3YXJuaW5ncyA9IEFycmF5LmlzQXJyYXkod2FybikgPyB3YXJuIDogW3dhcm5dO1xuICAgICAgZm9yIChjb25zdCBtc2cgb2Ygd2FybmluZ3MpXG4gICAgICAgICFtc2cgfHwgc2Vlblttc2ddIHx8IChzZWVuW21zZ10gPSAhMCwgY29uc29sZS53YXJuKG1zZykpO1xuICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBkZWZpbmVIdHRwUmVxdWVzdChlbnZNaWRkbGV3YXJlKSB7XG4gIHJldHVybiBnZXRJdChbXG4gICAgcmV0cnkoeyBzaG91bGRSZXRyeSB9KSxcbiAgICAuLi5lbnZNaWRkbGV3YXJlLFxuICAgIHByaW50V2FybmluZ3MoKSxcbiAgICBqc29uUmVxdWVzdCgpLFxuICAgIGpzb25SZXNwb25zZSgpLFxuICAgIHByb2dyZXNzKCksXG4gICAgaHR0cEVycm9yLFxuICAgIG9ic2VydmFibGUoeyBpbXBsZW1lbnRhdGlvbjogT2JzZXJ2YWJsZSB9KVxuICBdKTtcbn1cbmZ1bmN0aW9uIHNob3VsZFJldHJ5KGVyciwgYXR0ZW1wdCwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucy5tYXhSZXRyaWVzID09PSAwKSByZXR1cm4gITE7XG4gIGNvbnN0IGlzU2FmZSA9IG9wdGlvbnMubWV0aG9kID09PSBcIkdFVFwiIHx8IG9wdGlvbnMubWV0aG9kID09PSBcIkhFQURcIiwgaXNRdWVyeSA9IChvcHRpb25zLnVyaSB8fCBvcHRpb25zLnVybCkuc3RhcnRzV2l0aChcIi9kYXRhL3F1ZXJ5XCIpLCBpc1JldHJpYWJsZVJlc3BvbnNlID0gZXJyLnJlc3BvbnNlICYmIChlcnIucmVzcG9uc2Uuc3RhdHVzQ29kZSA9PT0gNDI5IHx8IGVyci5yZXNwb25zZS5zdGF0dXNDb2RlID09PSA1MDIgfHwgZXJyLnJlc3BvbnNlLnN0YXR1c0NvZGUgPT09IDUwMyk7XG4gIHJldHVybiAoaXNTYWZlIHx8IGlzUXVlcnkpICYmIGlzUmV0cmlhYmxlUmVzcG9uc2UgPyAhMCA6IHJldHJ5LnNob3VsZFJldHJ5KGVyciwgYXR0ZW1wdCwgb3B0aW9ucyk7XG59XG5jbGFzcyBDb25uZWN0aW9uRmFpbGVkRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIG5hbWUgPSBcIkNvbm5lY3Rpb25GYWlsZWRFcnJvclwiO1xufVxuY2xhc3MgRGlzY29ubmVjdEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBuYW1lID0gXCJEaXNjb25uZWN0RXJyb3JcIjtcbiAgcmVhc29uO1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCByZWFzb24sIG9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKG1lc3NhZ2UsIG9wdGlvbnMpLCB0aGlzLnJlYXNvbiA9IHJlYXNvbjtcbiAgfVxufVxuY2xhc3MgQ2hhbm5lbEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBuYW1lID0gXCJDaGFubmVsRXJyb3JcIjtcbiAgZGF0YTtcbiAgY29uc3RydWN0b3IobWVzc2FnZSwgZGF0YSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpLCB0aGlzLmRhdGEgPSBkYXRhO1xuICB9XG59XG5jbGFzcyBNZXNzYWdlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIG5hbWUgPSBcIk1lc3NhZ2VFcnJvclwiO1xuICBkYXRhO1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBkYXRhLCBvcHRpb25zID0ge30pIHtcbiAgICBzdXBlcihtZXNzYWdlLCBvcHRpb25zKSwgdGhpcy5kYXRhID0gZGF0YTtcbiAgfVxufVxuY2xhc3MgTWVzc2FnZVBhcnNlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIG5hbWUgPSBcIk1lc3NhZ2VQYXJzZUVycm9yXCI7XG59XG5jb25zdCBSRVFVSVJFRF9FVkVOVFMgPSBbXCJjaGFubmVsRXJyb3JcIiwgXCJkaXNjb25uZWN0XCJdO1xuZnVuY3Rpb24gY29ubmVjdEV2ZW50U291cmNlKGluaXRFdmVudFNvdXJjZSwgZXZlbnRzKSB7XG4gIHJldHVybiBkZWZlcigoKSA9PiB7XG4gICAgY29uc3QgZXMgPSBpbml0RXZlbnRTb3VyY2UoKTtcbiAgICByZXR1cm4gaXNPYnNlcnZhYmxlKGVzKSA/IGVzIDogb2YoZXMpO1xuICB9KS5waXBlKG1lcmdlTWFwKChlcykgPT4gY29ubmVjdFdpdGhFU0luc3RhbmNlKGVzLCBldmVudHMpKSk7XG59XG5mdW5jdGlvbiBjb25uZWN0V2l0aEVTSW5zdGFuY2UoZXMsIGV2ZW50cykge1xuICByZXR1cm4gbmV3IE9ic2VydmFibGUoKG9ic2VydmVyKSA9PiB7XG4gICAgY29uc3QgZW1pdE9wZW4gPSBldmVudHMuaW5jbHVkZXMoXCJvcGVuXCIpLCBlbWl0UmVjb25uZWN0ID0gZXZlbnRzLmluY2x1ZGVzKFwicmVjb25uZWN0XCIpO1xuICAgIGZ1bmN0aW9uIG9uRXJyb3IoZXZ0KSB7XG4gICAgICBpZiAoXCJkYXRhXCIgaW4gZXZ0KSB7XG4gICAgICAgIGNvbnN0IFtwYXJzZUVycm9yLCBldmVudF0gPSBwYXJzZUV2ZW50KGV2dCk7XG4gICAgICAgIG9ic2VydmVyLmVycm9yKFxuICAgICAgICAgIHBhcnNlRXJyb3IgPyBuZXcgTWVzc2FnZVBhcnNlRXJyb3IoXCJVbmFibGUgdG8gcGFyc2UgRXZlbnRTb3VyY2UgZXJyb3IgbWVzc2FnZVwiLCB7IGNhdXNlOiBldmVudCB9KSA6IG5ldyBNZXNzYWdlRXJyb3IoKGV2ZW50Py5kYXRhKS5tZXNzYWdlLCBldmVudClcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZXMucmVhZHlTdGF0ZSA9PT0gZXMuQ0xPU0VEID8gb2JzZXJ2ZXIuZXJyb3IobmV3IENvbm5lY3Rpb25GYWlsZWRFcnJvcihcIkV2ZW50U291cmNlIGNvbm5lY3Rpb24gZmFpbGVkXCIpKSA6IGVtaXRSZWNvbm5lY3QgJiYgb2JzZXJ2ZXIubmV4dCh7IHR5cGU6IFwicmVjb25uZWN0XCIgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uT3BlbigpIHtcbiAgICAgIG9ic2VydmVyLm5leHQoeyB0eXBlOiBcIm9wZW5cIiB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gb25NZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgIGNvbnN0IFtwYXJzZUVycm9yLCBldmVudF0gPSBwYXJzZUV2ZW50KG1lc3NhZ2UpO1xuICAgICAgaWYgKHBhcnNlRXJyb3IpIHtcbiAgICAgICAgb2JzZXJ2ZXIuZXJyb3IoXG4gICAgICAgICAgbmV3IE1lc3NhZ2VQYXJzZUVycm9yKFwiVW5hYmxlIHRvIHBhcnNlIEV2ZW50U291cmNlIG1lc3NhZ2VcIiwgeyBjYXVzZTogcGFyc2VFcnJvciB9KVxuICAgICAgICApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAobWVzc2FnZS50eXBlID09PSBcImNoYW5uZWxFcnJvclwiKSB7XG4gICAgICAgIG9ic2VydmVyLmVycm9yKG5ldyBDaGFubmVsRXJyb3IoZXh0cmFjdEVycm9yTWVzc2FnZShldmVudD8uZGF0YSksIGV2ZW50LmRhdGEpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKG1lc3NhZ2UudHlwZSA9PT0gXCJkaXNjb25uZWN0XCIpIHtcbiAgICAgICAgb2JzZXJ2ZXIuZXJyb3IoXG4gICAgICAgICAgbmV3IERpc2Nvbm5lY3RFcnJvcihcbiAgICAgICAgICAgIGBTZXJ2ZXIgZGlzY29ubmVjdGVkIGNsaWVudDogJHtldmVudC5kYXRhPy5yZWFzb24gfHwgXCJ1bmtub3duIGVycm9yXCJ9YFxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgb2JzZXJ2ZXIubmV4dCh7XG4gICAgICAgIHR5cGU6IG1lc3NhZ2UudHlwZSxcbiAgICAgICAgaWQ6IG1lc3NhZ2UubGFzdEV2ZW50SWQsXG4gICAgICAgIC4uLmV2ZW50LmRhdGEgPyB7IGRhdGE6IGV2ZW50LmRhdGEgfSA6IHt9XG4gICAgICB9KTtcbiAgICB9XG4gICAgZXMuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIG9uRXJyb3IpLCBlbWl0T3BlbiAmJiBlcy5hZGRFdmVudExpc3RlbmVyKFwib3BlblwiLCBvbk9wZW4pO1xuICAgIGNvbnN0IGNsZWFuZWRFdmVudHMgPSBbLi4uLyogQF9fUFVSRV9fICovIG5ldyBTZXQoWy4uLlJFUVVJUkVEX0VWRU5UUywgLi4uZXZlbnRzXSldLmZpbHRlcigodHlwZSkgPT4gdHlwZSAhPT0gXCJlcnJvclwiICYmIHR5cGUgIT09IFwib3BlblwiICYmIHR5cGUgIT09IFwicmVjb25uZWN0XCIpO1xuICAgIHJldHVybiBjbGVhbmVkRXZlbnRzLmZvckVhY2goKHR5cGUpID0+IGVzLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgb25NZXNzYWdlKSksICgpID0+IHtcbiAgICAgIGVzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCBvbkVycm9yKSwgZW1pdE9wZW4gJiYgZXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm9wZW5cIiwgb25PcGVuKSwgY2xlYW5lZEV2ZW50cy5mb3JFYWNoKCh0eXBlKSA9PiBlcy5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIG9uTWVzc2FnZSkpLCBlcy5jbG9zZSgpO1xuICAgIH07XG4gIH0pO1xufVxuZnVuY3Rpb24gcGFyc2VFdmVudChtZXNzYWdlKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgZGF0YSA9IHR5cGVvZiBtZXNzYWdlLmRhdGEgPT0gXCJzdHJpbmdcIiAmJiBKU09OLnBhcnNlKG1lc3NhZ2UuZGF0YSk7XG4gICAgcmV0dXJuIFtcbiAgICAgIG51bGwsXG4gICAgICB7XG4gICAgICAgIHR5cGU6IG1lc3NhZ2UudHlwZSxcbiAgICAgICAgaWQ6IG1lc3NhZ2UubGFzdEV2ZW50SWQsXG4gICAgICAgIC4uLmlzRW1wdHlPYmplY3QoZGF0YSkgPyB7fSA6IHsgZGF0YSB9XG4gICAgICB9XG4gICAgXTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIFtlcnIsIG51bGxdO1xuICB9XG59XG5mdW5jdGlvbiBleHRyYWN0RXJyb3JNZXNzYWdlKGVycikge1xuICByZXR1cm4gZXJyLmVycm9yID8gZXJyLmVycm9yLmRlc2NyaXB0aW9uID8gZXJyLmVycm9yLmRlc2NyaXB0aW9uIDogdHlwZW9mIGVyci5lcnJvciA9PSBcInN0cmluZ1wiID8gZXJyLmVycm9yIDogSlNPTi5zdHJpbmdpZnkoZXJyLmVycm9yLCBudWxsLCAyKSA6IGVyci5tZXNzYWdlIHx8IFwiVW5rbm93biBsaXN0ZW5lciBlcnJvclwiO1xufVxuZnVuY3Rpb24gaXNFbXB0eU9iamVjdChkYXRhKSB7XG4gIGZvciAoY29uc3QgXyBpbiBkYXRhKVxuICAgIHJldHVybiAhMTtcbiAgcmV0dXJuICEwO1xufVxuZnVuY3Rpb24gZ2V0U2VsZWN0aW9uKHNlbCkge1xuICBpZiAodHlwZW9mIHNlbCA9PSBcInN0cmluZ1wiKVxuICAgIHJldHVybiB7IGlkOiBzZWwgfTtcbiAgaWYgKEFycmF5LmlzQXJyYXkoc2VsKSlcbiAgICByZXR1cm4geyBxdWVyeTogXCIqW19pZCBpbiAkaWRzXVwiLCBwYXJhbXM6IHsgaWRzOiBzZWwgfSB9O1xuICBpZiAodHlwZW9mIHNlbCA9PSBcIm9iamVjdFwiICYmIHNlbCAhPT0gbnVsbCAmJiBcInF1ZXJ5XCIgaW4gc2VsICYmIHR5cGVvZiBzZWwucXVlcnkgPT0gXCJzdHJpbmdcIilcbiAgICByZXR1cm4gXCJwYXJhbXNcIiBpbiBzZWwgJiYgdHlwZW9mIHNlbC5wYXJhbXMgPT0gXCJvYmplY3RcIiAmJiBzZWwucGFyYW1zICE9PSBudWxsID8geyBxdWVyeTogc2VsLnF1ZXJ5LCBwYXJhbXM6IHNlbC5wYXJhbXMgfSA6IHsgcXVlcnk6IHNlbC5xdWVyeSB9O1xuICBjb25zdCBzZWxlY3Rpb25PcHRzID0gW1xuICAgIFwiKiBEb2N1bWVudCBJRCAoPGRvY0lkPilcIixcbiAgICBcIiogQXJyYXkgb2YgZG9jdW1lbnQgSURzXCIsXG4gICAgXCIqIE9iamVjdCBjb250YWluaW5nIGBxdWVyeWBcIlxuICBdLmpvaW4oYFxuYCk7XG4gIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBzZWxlY3Rpb24gLSBtdXN0IGJlIG9uZSBvZjpcblxuJHtzZWxlY3Rpb25PcHRzfWApO1xufVxuY2xhc3MgQmFzZVBhdGNoIHtcbiAgc2VsZWN0aW9uO1xuICBvcGVyYXRpb25zO1xuICBjb25zdHJ1Y3RvcihzZWxlY3Rpb24sIG9wZXJhdGlvbnMgPSB7fSkge1xuICAgIHRoaXMuc2VsZWN0aW9uID0gc2VsZWN0aW9uLCB0aGlzLm9wZXJhdGlvbnMgPSBvcGVyYXRpb25zO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBnaXZlbiBhdHRyaWJ1dGVzIHRvIHRoZSBkb2N1bWVudC4gRG9lcyBOT1QgbWVyZ2Ugb2JqZWN0cy5cbiAgICogVGhlIG9wZXJhdGlvbiBpcyBhZGRlZCB0byB0aGUgY3VycmVudCBwYXRjaCwgcmVhZHkgdG8gYmUgY29tbWl0ZWQgYnkgYGNvbW1pdCgpYFxuICAgKlxuICAgKiBAcGFyYW0gYXR0cnMgLSBBdHRyaWJ1dGVzIHRvIHNldC4gVG8gc2V0IGEgZGVlcCBhdHRyaWJ1dGUsIHVzZSBKU09OTWF0Y2gsIGVnOiBcXHtcIm5lc3RlZC5wcm9wXCI6IFwidmFsdWVcIlxcfVxuICAgKi9cbiAgc2V0KGF0dHJzKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Fzc2lnbihcInNldFwiLCBhdHRycyk7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGdpdmVuIGF0dHJpYnV0ZXMgdG8gdGhlIGRvY3VtZW50IGlmIHRoZXkgYXJlIG5vdCBjdXJyZW50bHkgc2V0LiBEb2VzIE5PVCBtZXJnZSBvYmplY3RzLlxuICAgKiBUaGUgb3BlcmF0aW9uIGlzIGFkZGVkIHRvIHRoZSBjdXJyZW50IHBhdGNoLCByZWFkeSB0byBiZSBjb21taXRlZCBieSBgY29tbWl0KClgXG4gICAqXG4gICAqIEBwYXJhbSBhdHRycyAtIEF0dHJpYnV0ZXMgdG8gc2V0LiBUbyBzZXQgYSBkZWVwIGF0dHJpYnV0ZSwgdXNlIEpTT05NYXRjaCwgZWc6IFxce1wibmVzdGVkLnByb3BcIjogXCJ2YWx1ZVwiXFx9XG4gICAqL1xuICBzZXRJZk1pc3NpbmcoYXR0cnMpIHtcbiAgICByZXR1cm4gdGhpcy5fYXNzaWduKFwic2V0SWZNaXNzaW5nXCIsIGF0dHJzKTtcbiAgfVxuICAvKipcbiAgICogUGVyZm9ybXMgYSBcImRpZmYtbWF0Y2gtcGF0Y2hcIiBvcGVyYXRpb24gb24gdGhlIHN0cmluZyBhdHRyaWJ1dGVzIHByb3ZpZGVkLlxuICAgKiBUaGUgb3BlcmF0aW9uIGlzIGFkZGVkIHRvIHRoZSBjdXJyZW50IHBhdGNoLCByZWFkeSB0byBiZSBjb21taXRlZCBieSBgY29tbWl0KClgXG4gICAqXG4gICAqIEBwYXJhbSBhdHRycyAtIEF0dHJpYnV0ZXMgdG8gcGVyZm9ybSBvcGVyYXRpb24gb24uIFRvIHNldCBhIGRlZXAgYXR0cmlidXRlLCB1c2UgSlNPTk1hdGNoLCBlZzogXFx7XCJuZXN0ZWQucHJvcFwiOiBcImRtcFwiXFx9XG4gICAqL1xuICBkaWZmTWF0Y2hQYXRjaChhdHRycykge1xuICAgIHJldHVybiB2YWxpZGF0ZU9iamVjdChcImRpZmZNYXRjaFBhdGNoXCIsIGF0dHJzKSwgdGhpcy5fYXNzaWduKFwiZGlmZk1hdGNoUGF0Y2hcIiwgYXR0cnMpO1xuICB9XG4gIC8qKlxuICAgKiBVbnNldHMgdGhlIGF0dHJpYnV0ZSBwYXRocyBwcm92aWRlZC5cbiAgICogVGhlIG9wZXJhdGlvbiBpcyBhZGRlZCB0byB0aGUgY3VycmVudCBwYXRjaCwgcmVhZHkgdG8gYmUgY29tbWl0ZWQgYnkgYGNvbW1pdCgpYFxuICAgKlxuICAgKiBAcGFyYW0gYXR0cnMgLSBBdHRyaWJ1dGUgcGF0aHMgdG8gdW5zZXQuXG4gICAqL1xuICB1bnNldChhdHRycykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShhdHRycykpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bnNldChhdHRycykgdGFrZXMgYW4gYXJyYXkgb2YgYXR0cmlidXRlcyB0byB1bnNldCwgbm9uLWFycmF5IGdpdmVuXCIpO1xuICAgIHJldHVybiB0aGlzLm9wZXJhdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLm9wZXJhdGlvbnMsIHsgdW5zZXQ6IGF0dHJzIH0pLCB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBJbmNyZW1lbnQgYSBudW1lcmljIHZhbHVlLiBFYWNoIGVudHJ5IGluIHRoZSBhcmd1bWVudCBpcyBlaXRoZXIgYW4gYXR0cmlidXRlIG9yIGEgSlNPTiBwYXRoLiBUaGUgdmFsdWUgbWF5IGJlIGEgcG9zaXRpdmUgb3IgbmVnYXRpdmUgaW50ZWdlciBvciBmbG9hdGluZy1wb2ludCB2YWx1ZS4gVGhlIG9wZXJhdGlvbiB3aWxsIGZhaWwgaWYgdGFyZ2V0IHZhbHVlIGlzIG5vdCBhIG51bWVyaWMgdmFsdWUsIG9yIGRvZXNuJ3QgZXhpc3QuXG4gICAqXG4gICAqIEBwYXJhbSBhdHRycyAtIE9iamVjdCBvZiBhdHRyaWJ1dGUgcGF0aHMgdG8gaW5jcmVtZW50LCB2YWx1ZXMgcmVwcmVzZW50aW5nIHRoZSBudW1iZXIgdG8gaW5jcmVtZW50IGJ5LlxuICAgKi9cbiAgaW5jKGF0dHJzKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Fzc2lnbihcImluY1wiLCBhdHRycyk7XG4gIH1cbiAgLyoqXG4gICAqIERlY3JlbWVudCBhIG51bWVyaWMgdmFsdWUuIEVhY2ggZW50cnkgaW4gdGhlIGFyZ3VtZW50IGlzIGVpdGhlciBhbiBhdHRyaWJ1dGUgb3IgYSBKU09OIHBhdGguIFRoZSB2YWx1ZSBtYXkgYmUgYSBwb3NpdGl2ZSBvciBuZWdhdGl2ZSBpbnRlZ2VyIG9yIGZsb2F0aW5nLXBvaW50IHZhbHVlLiBUaGUgb3BlcmF0aW9uIHdpbGwgZmFpbCBpZiB0YXJnZXQgdmFsdWUgaXMgbm90IGEgbnVtZXJpYyB2YWx1ZSwgb3IgZG9lc24ndCBleGlzdC5cbiAgICpcbiAgICogQHBhcmFtIGF0dHJzIC0gT2JqZWN0IG9mIGF0dHJpYnV0ZSBwYXRocyB0byBkZWNyZW1lbnQsIHZhbHVlcyByZXByZXNlbnRpbmcgdGhlIG51bWJlciB0byBkZWNyZW1lbnQgYnkuXG4gICAqL1xuICBkZWMoYXR0cnMpIHtcbiAgICByZXR1cm4gdGhpcy5fYXNzaWduKFwiZGVjXCIsIGF0dHJzKTtcbiAgfVxuICAvKipcbiAgICogUHJvdmlkZXMgbWV0aG9kcyBmb3IgbW9kaWZ5aW5nIGFycmF5cywgYnkgaW5zZXJ0aW5nLCBhcHBlbmRpbmcgYW5kIHJlcGxhY2luZyBlbGVtZW50cyB2aWEgYSBKU09OUGF0aCBleHByZXNzaW9uLlxuICAgKlxuICAgKiBAcGFyYW0gYXQgLSBMb2NhdGlvbiB0byBpbnNlcnQgYXQsIHJlbGF0aXZlIHRvIHRoZSBnaXZlbiBzZWxlY3Rvciwgb3IgJ3JlcGxhY2UnIHRoZSBtYXRjaGVkIHBhdGhcbiAgICogQHBhcmFtIHNlbGVjdG9yIC0gSlNPTlBhdGggZXhwcmVzc2lvbiwgZWcgYGNvbW1lbnRzWy0xXWAgb3IgYGJsb2Nrc1tfa2V5PT1cImFiYzEyM1wiXWBcbiAgICogQHBhcmFtIGl0ZW1zIC0gQXJyYXkgb2YgaXRlbXMgdG8gaW5zZXJ0L3JlcGxhY2VcbiAgICovXG4gIGluc2VydChhdCwgc2VsZWN0b3IsIGl0ZW1zKSB7XG4gICAgcmV0dXJuIHZhbGlkYXRlSW5zZXJ0KGF0LCBzZWxlY3RvciwgaXRlbXMpLCB0aGlzLl9hc3NpZ24oXCJpbnNlcnRcIiwgeyBbYXRdOiBzZWxlY3RvciwgaXRlbXMgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEFwcGVuZCB0aGUgZ2l2ZW4gaXRlbXMgdG8gdGhlIGFycmF5IGF0IHRoZSBnaXZlbiBKU09OUGF0aFxuICAgKlxuICAgKiBAcGFyYW0gc2VsZWN0b3IgLSBBdHRyaWJ1dGUvcGF0aCB0byBhcHBlbmQgdG8sIGVnIGBjb21tZW50c2Agb3IgYHBlcnNvbi5ob2JiaWVzYFxuICAgKiBAcGFyYW0gaXRlbXMgLSBBcnJheSBvZiBpdGVtcyB0byBhcHBlbmQgdG8gdGhlIGFycmF5XG4gICAqL1xuICBhcHBlbmQoc2VsZWN0b3IsIGl0ZW1zKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5zZXJ0KFwiYWZ0ZXJcIiwgYCR7c2VsZWN0b3J9Wy0xXWAsIGl0ZW1zKTtcbiAgfVxuICAvKipcbiAgICogUHJlcGVuZCB0aGUgZ2l2ZW4gaXRlbXMgdG8gdGhlIGFycmF5IGF0IHRoZSBnaXZlbiBKU09OUGF0aFxuICAgKlxuICAgKiBAcGFyYW0gc2VsZWN0b3IgLSBBdHRyaWJ1dGUvcGF0aCB0byBwcmVwZW5kIHRvLCBlZyBgY29tbWVudHNgIG9yIGBwZXJzb24uaG9iYmllc2BcbiAgICogQHBhcmFtIGl0ZW1zIC0gQXJyYXkgb2YgaXRlbXMgdG8gcHJlcGVuZCB0byB0aGUgYXJyYXlcbiAgICovXG4gIHByZXBlbmQoc2VsZWN0b3IsIGl0ZW1zKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5zZXJ0KFwiYmVmb3JlXCIsIGAke3NlbGVjdG9yfVswXWAsIGl0ZW1zKTtcbiAgfVxuICAvKipcbiAgICogQ2hhbmdlIHRoZSBjb250ZW50cyBvZiBhbiBhcnJheSBieSByZW1vdmluZyBleGlzdGluZyBlbGVtZW50cyBhbmQvb3IgYWRkaW5nIG5ldyBlbGVtZW50cy5cbiAgICpcbiAgICogQHBhcmFtIHNlbGVjdG9yIC0gQXR0cmlidXRlIG9yIEpTT05QYXRoIGV4cHJlc3Npb24gZm9yIGFycmF5XG4gICAqIEBwYXJhbSBzdGFydCAtIEluZGV4IGF0IHdoaWNoIHRvIHN0YXJ0IGNoYW5naW5nIHRoZSBhcnJheSAod2l0aCBvcmlnaW4gMCkuIElmIGdyZWF0ZXIgdGhhbiB0aGUgbGVuZ3RoIG9mIHRoZSBhcnJheSwgYWN0dWFsIHN0YXJ0aW5nIGluZGV4IHdpbGwgYmUgc2V0IHRvIHRoZSBsZW5ndGggb2YgdGhlIGFycmF5LiBJZiBuZWdhdGl2ZSwgd2lsbCBiZWdpbiB0aGF0IG1hbnkgZWxlbWVudHMgZnJvbSB0aGUgZW5kIG9mIHRoZSBhcnJheSAod2l0aCBvcmlnaW4gLTEpIGFuZCB3aWxsIGJlIHNldCB0byAwIGlmIGFic29sdXRlIHZhbHVlIGlzIGdyZWF0ZXIgdGhhbiB0aGUgbGVuZ3RoIG9mIHRoZSBhcnJheS54XG4gICAqIEBwYXJhbSBkZWxldGVDb3VudCAtIEFuIGludGVnZXIgaW5kaWNhdGluZyB0aGUgbnVtYmVyIG9mIG9sZCBhcnJheSBlbGVtZW50cyB0byByZW1vdmUuXG4gICAqIEBwYXJhbSBpdGVtcyAtIFRoZSBlbGVtZW50cyB0byBhZGQgdG8gdGhlIGFycmF5LCBiZWdpbm5pbmcgYXQgdGhlIHN0YXJ0IGluZGV4LiBJZiB5b3UgZG9uJ3Qgc3BlY2lmeSBhbnkgZWxlbWVudHMsIHNwbGljZSgpIHdpbGwgb25seSByZW1vdmUgZWxlbWVudHMgZnJvbSB0aGUgYXJyYXkuXG4gICAqL1xuICBzcGxpY2Uoc2VsZWN0b3IsIHN0YXJ0LCBkZWxldGVDb3VudCwgaXRlbXMpIHtcbiAgICBjb25zdCBkZWxBbGwgPSB0eXBlb2YgZGVsZXRlQ291bnQgPiBcInVcIiB8fCBkZWxldGVDb3VudCA9PT0gLTEsIHN0YXJ0SW5kZXggPSBzdGFydCA8IDAgPyBzdGFydCAtIDEgOiBzdGFydCwgZGVsQ291bnQgPSBkZWxBbGwgPyAtMSA6IE1hdGgubWF4KDAsIHN0YXJ0ICsgZGVsZXRlQ291bnQpLCBkZWxSYW5nZSA9IHN0YXJ0SW5kZXggPCAwICYmIGRlbENvdW50ID49IDAgPyBcIlwiIDogZGVsQ291bnQsIHJhbmdlU2VsZWN0b3IgPSBgJHtzZWxlY3Rvcn1bJHtzdGFydEluZGV4fToke2RlbFJhbmdlfV1gO1xuICAgIHJldHVybiB0aGlzLmluc2VydChcInJlcGxhY2VcIiwgcmFuZ2VTZWxlY3RvciwgaXRlbXMgfHwgW10pO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIGEgcmV2aXNpb24gY2xhdXNlLCBwcmV2ZW50aW5nIHRoZSBkb2N1bWVudCBmcm9tIGJlaW5nIHBhdGNoZWQgaWYgdGhlIGBfcmV2YCBwcm9wZXJ0eSBkb2VzIG5vdCBtYXRjaCB0aGUgZ2l2ZW4gdmFsdWVcbiAgICpcbiAgICogQHBhcmFtIHJldiAtIFJldmlzaW9uIHRvIGxvY2sgdGhlIHBhdGNoIHRvXG4gICAqL1xuICBpZlJldmlzaW9uSWQocmV2KSB7XG4gICAgcmV0dXJuIHRoaXMub3BlcmF0aW9ucy5pZlJldmlzaW9uSUQgPSByZXYsIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiBhIHBsYWluIEpTT04gcmVwcmVzZW50YXRpb24gb2YgdGhlIHBhdGNoXG4gICAqL1xuICBzZXJpYWxpemUoKSB7XG4gICAgcmV0dXJuIHsgLi4uZ2V0U2VsZWN0aW9uKHRoaXMuc2VsZWN0aW9uKSwgLi4udGhpcy5vcGVyYXRpb25zIH07XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiBhIHBsYWluIEpTT04gcmVwcmVzZW50YXRpb24gb2YgdGhlIHBhdGNoXG4gICAqL1xuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VyaWFsaXplKCk7XG4gIH1cbiAgLyoqXG4gICAqIENsZWFycyB0aGUgcGF0Y2ggb2YgYWxsIG9wZXJhdGlvbnNcbiAgICovXG4gIHJlc2V0KCkge1xuICAgIHJldHVybiB0aGlzLm9wZXJhdGlvbnMgPSB7fSwgdGhpcztcbiAgfVxuICBfYXNzaWduKG9wLCBwcm9wcywgbWVyZ2UgPSAhMCkge1xuICAgIHJldHVybiB2YWxpZGF0ZU9iamVjdChvcCwgcHJvcHMpLCB0aGlzLm9wZXJhdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLm9wZXJhdGlvbnMsIHtcbiAgICAgIFtvcF06IE9iamVjdC5hc3NpZ24oe30sIG1lcmdlICYmIHRoaXMub3BlcmF0aW9uc1tvcF0gfHwge30sIHByb3BzKVxuICAgIH0pLCB0aGlzO1xuICB9XG4gIF9zZXQob3AsIHByb3BzKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Fzc2lnbihvcCwgcHJvcHMsICExKTtcbiAgfVxufVxuY2xhc3MgT2JzZXJ2YWJsZVBhdGNoIGV4dGVuZHMgQmFzZVBhdGNoIHtcbiAgI2NsaWVudDtcbiAgY29uc3RydWN0b3Ioc2VsZWN0aW9uLCBvcGVyYXRpb25zLCBjbGllbnQpIHtcbiAgICBzdXBlcihzZWxlY3Rpb24sIG9wZXJhdGlvbnMpLCB0aGlzLiNjbGllbnQgPSBjbGllbnQ7XG4gIH1cbiAgLyoqXG4gICAqIENsb25lcyB0aGUgcGF0Y2hcbiAgICovXG4gIGNsb25lKCkge1xuICAgIHJldHVybiBuZXcgT2JzZXJ2YWJsZVBhdGNoKHRoaXMuc2VsZWN0aW9uLCB7IC4uLnRoaXMub3BlcmF0aW9ucyB9LCB0aGlzLiNjbGllbnQpO1xuICB9XG4gIGNvbW1pdChvcHRpb25zKSB7XG4gICAgaWYgKCF0aGlzLiNjbGllbnQpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiTm8gYGNsaWVudGAgcGFzc2VkIHRvIHBhdGNoLCBlaXRoZXIgcHJvdmlkZSBvbmUgb3IgcGFzcyB0aGUgcGF0Y2ggdG8gYSBjbGllbnRzIGBtdXRhdGUoKWAgbWV0aG9kXCJcbiAgICAgICk7XG4gICAgY29uc3QgcmV0dXJuRmlyc3QgPSB0eXBlb2YgdGhpcy5zZWxlY3Rpb24gPT0gXCJzdHJpbmdcIiwgb3B0cyA9IE9iamVjdC5hc3NpZ24oeyByZXR1cm5GaXJzdCwgcmV0dXJuRG9jdW1lbnRzOiAhMCB9LCBvcHRpb25zKTtcbiAgICByZXR1cm4gdGhpcy4jY2xpZW50Lm11dGF0ZSh7IHBhdGNoOiB0aGlzLnNlcmlhbGl6ZSgpIH0sIG9wdHMpO1xuICB9XG59XG5jbGFzcyBQYXRjaCBleHRlbmRzIEJhc2VQYXRjaCB7XG4gICNjbGllbnQ7XG4gIGNvbnN0cnVjdG9yKHNlbGVjdGlvbiwgb3BlcmF0aW9ucywgY2xpZW50KSB7XG4gICAgc3VwZXIoc2VsZWN0aW9uLCBvcGVyYXRpb25zKSwgdGhpcy4jY2xpZW50ID0gY2xpZW50O1xuICB9XG4gIC8qKlxuICAgKiBDbG9uZXMgdGhlIHBhdGNoXG4gICAqL1xuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IFBhdGNoKHRoaXMuc2VsZWN0aW9uLCB7IC4uLnRoaXMub3BlcmF0aW9ucyB9LCB0aGlzLiNjbGllbnQpO1xuICB9XG4gIGNvbW1pdChvcHRpb25zKSB7XG4gICAgaWYgKCF0aGlzLiNjbGllbnQpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiTm8gYGNsaWVudGAgcGFzc2VkIHRvIHBhdGNoLCBlaXRoZXIgcHJvdmlkZSBvbmUgb3IgcGFzcyB0aGUgcGF0Y2ggdG8gYSBjbGllbnRzIGBtdXRhdGUoKWAgbWV0aG9kXCJcbiAgICAgICk7XG4gICAgY29uc3QgcmV0dXJuRmlyc3QgPSB0eXBlb2YgdGhpcy5zZWxlY3Rpb24gPT0gXCJzdHJpbmdcIiwgb3B0cyA9IE9iamVjdC5hc3NpZ24oeyByZXR1cm5GaXJzdCwgcmV0dXJuRG9jdW1lbnRzOiAhMCB9LCBvcHRpb25zKTtcbiAgICByZXR1cm4gdGhpcy4jY2xpZW50Lm11dGF0ZSh7IHBhdGNoOiB0aGlzLnNlcmlhbGl6ZSgpIH0sIG9wdHMpO1xuICB9XG59XG5jb25zdCBkZWZhdWx0TXV0YXRlT3B0aW9ucyA9IHsgcmV0dXJuRG9jdW1lbnRzOiAhMSB9O1xuY2xhc3MgQmFzZVRyYW5zYWN0aW9uIHtcbiAgb3BlcmF0aW9ucztcbiAgdHJ4SWQ7XG4gIGNvbnN0cnVjdG9yKG9wZXJhdGlvbnMgPSBbXSwgdHJhbnNhY3Rpb25JZCkge1xuICAgIHRoaXMub3BlcmF0aW9ucyA9IG9wZXJhdGlvbnMsIHRoaXMudHJ4SWQgPSB0cmFuc2FjdGlvbklkO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IFNhbml0eSBkb2N1bWVudC4gSWYgYF9pZGAgaXMgcHJvdmlkZWQgYW5kIGFscmVhZHkgZXhpc3RzLCB0aGUgbXV0YXRpb24gd2lsbCBmYWlsLiBJZiBubyBgX2lkYCBpcyBnaXZlbiwgb25lIHdpbGwgYXV0b21hdGljYWxseSBiZSBnZW5lcmF0ZWQgYnkgdGhlIGRhdGFiYXNlLlxuICAgKiBUaGUgb3BlcmF0aW9uIGlzIGFkZGVkIHRvIHRoZSBjdXJyZW50IHRyYW5zYWN0aW9uLCByZWFkeSB0byBiZSBjb21taXRlZCBieSBgY29tbWl0KClgXG4gICAqXG4gICAqIEBwYXJhbSBkb2MgLSBEb2N1bWVudCB0byBjcmVhdGUuIFJlcXVpcmVzIGEgYF90eXBlYCBwcm9wZXJ0eS5cbiAgICovXG4gIGNyZWF0ZShkb2MpIHtcbiAgICByZXR1cm4gdmFsaWRhdGVPYmplY3QoXCJjcmVhdGVcIiwgZG9jKSwgdGhpcy5fYWRkKHsgY3JlYXRlOiBkb2MgfSk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgU2FuaXR5IGRvY3VtZW50LiBJZiBhIGRvY3VtZW50IHdpdGggdGhlIHNhbWUgYF9pZGAgYWxyZWFkeSBleGlzdHMsIHRoZSBjcmVhdGUgb3BlcmF0aW9uIHdpbGwgYmUgaWdub3JlZC5cbiAgICogVGhlIG9wZXJhdGlvbiBpcyBhZGRlZCB0byB0aGUgY3VycmVudCB0cmFuc2FjdGlvbiwgcmVhZHkgdG8gYmUgY29tbWl0ZWQgYnkgYGNvbW1pdCgpYFxuICAgKlxuICAgKiBAcGFyYW0gZG9jIC0gRG9jdW1lbnQgdG8gY3JlYXRlIGlmIGl0IGRvZXMgbm90IGFscmVhZHkgZXhpc3QuIFJlcXVpcmVzIGBfaWRgIGFuZCBgX3R5cGVgIHByb3BlcnRpZXMuXG4gICAqL1xuICBjcmVhdGVJZk5vdEV4aXN0cyhkb2MpIHtcbiAgICBjb25zdCBvcCA9IFwiY3JlYXRlSWZOb3RFeGlzdHNcIjtcbiAgICByZXR1cm4gdmFsaWRhdGVPYmplY3Qob3AsIGRvYyksIHJlcXVpcmVEb2N1bWVudElkKG9wLCBkb2MpLCB0aGlzLl9hZGQoeyBbb3BdOiBkb2MgfSk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgU2FuaXR5IGRvY3VtZW50LCBvciByZXBsYWNlcyBhbiBleGlzdGluZyBvbmUgaWYgdGhlIHNhbWUgYF9pZGAgaXMgYWxyZWFkeSB1c2VkLlxuICAgKiBUaGUgb3BlcmF0aW9uIGlzIGFkZGVkIHRvIHRoZSBjdXJyZW50IHRyYW5zYWN0aW9uLCByZWFkeSB0byBiZSBjb21taXRlZCBieSBgY29tbWl0KClgXG4gICAqXG4gICAqIEBwYXJhbSBkb2MgLSBEb2N1bWVudCB0byBjcmVhdGUgb3IgcmVwbGFjZS4gUmVxdWlyZXMgYF9pZGAgYW5kIGBfdHlwZWAgcHJvcGVydGllcy5cbiAgICovXG4gIGNyZWF0ZU9yUmVwbGFjZShkb2MpIHtcbiAgICBjb25zdCBvcCA9IFwiY3JlYXRlT3JSZXBsYWNlXCI7XG4gICAgcmV0dXJuIHZhbGlkYXRlT2JqZWN0KG9wLCBkb2MpLCByZXF1aXJlRG9jdW1lbnRJZChvcCwgZG9jKSwgdGhpcy5fYWRkKHsgW29wXTogZG9jIH0pO1xuICB9XG4gIC8qKlxuICAgKiBEZWxldGVzIHRoZSBkb2N1bWVudCB3aXRoIHRoZSBnaXZlbiBkb2N1bWVudCBJRFxuICAgKiBUaGUgb3BlcmF0aW9uIGlzIGFkZGVkIHRvIHRoZSBjdXJyZW50IHRyYW5zYWN0aW9uLCByZWFkeSB0byBiZSBjb21taXRlZCBieSBgY29tbWl0KClgXG4gICAqXG4gICAqIEBwYXJhbSBkb2N1bWVudElkIC0gRG9jdW1lbnQgSUQgdG8gZGVsZXRlXG4gICAqL1xuICBkZWxldGUoZG9jdW1lbnRJZCkge1xuICAgIHJldHVybiB2YWxpZGF0ZURvY3VtZW50SWQoXCJkZWxldGVcIiwgZG9jdW1lbnRJZCksIHRoaXMuX2FkZCh7IGRlbGV0ZTogeyBpZDogZG9jdW1lbnRJZCB9IH0pO1xuICB9XG4gIHRyYW5zYWN0aW9uSWQoaWQpIHtcbiAgICByZXR1cm4gaWQgPyAodGhpcy50cnhJZCA9IGlkLCB0aGlzKSA6IHRoaXMudHJ4SWQ7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiBhIHBsYWluIEpTT04gcmVwcmVzZW50YXRpb24gb2YgdGhlIHRyYW5zYWN0aW9uXG4gICAqL1xuICBzZXJpYWxpemUoKSB7XG4gICAgcmV0dXJuIFsuLi50aGlzLm9wZXJhdGlvbnNdO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gYSBwbGFpbiBKU09OIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB0cmFuc2FjdGlvblxuICAgKi9cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB0aGlzLnNlcmlhbGl6ZSgpO1xuICB9XG4gIC8qKlxuICAgKiBDbGVhcnMgdGhlIHRyYW5zYWN0aW9uIG9mIGFsbCBvcGVyYXRpb25zXG4gICAqL1xuICByZXNldCgpIHtcbiAgICByZXR1cm4gdGhpcy5vcGVyYXRpb25zID0gW10sIHRoaXM7XG4gIH1cbiAgX2FkZChtdXQpIHtcbiAgICByZXR1cm4gdGhpcy5vcGVyYXRpb25zLnB1c2gobXV0KSwgdGhpcztcbiAgfVxufVxuY2xhc3MgVHJhbnNhY3Rpb24gZXh0ZW5kcyBCYXNlVHJhbnNhY3Rpb24ge1xuICAjY2xpZW50O1xuICBjb25zdHJ1Y3RvcihvcGVyYXRpb25zLCBjbGllbnQsIHRyYW5zYWN0aW9uSWQpIHtcbiAgICBzdXBlcihvcGVyYXRpb25zLCB0cmFuc2FjdGlvbklkKSwgdGhpcy4jY2xpZW50ID0gY2xpZW50O1xuICB9XG4gIC8qKlxuICAgKiBDbG9uZXMgdGhlIHRyYW5zYWN0aW9uXG4gICAqL1xuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uKFsuLi50aGlzLm9wZXJhdGlvbnNdLCB0aGlzLiNjbGllbnQsIHRoaXMudHJ4SWQpO1xuICB9XG4gIGNvbW1pdChvcHRpb25zKSB7XG4gICAgaWYgKCF0aGlzLiNjbGllbnQpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiTm8gYGNsaWVudGAgcGFzc2VkIHRvIHRyYW5zYWN0aW9uLCBlaXRoZXIgcHJvdmlkZSBvbmUgb3IgcGFzcyB0aGUgdHJhbnNhY3Rpb24gdG8gYSBjbGllbnRzIGBtdXRhdGUoKWAgbWV0aG9kXCJcbiAgICAgICk7XG4gICAgcmV0dXJuIHRoaXMuI2NsaWVudC5tdXRhdGUoXG4gICAgICB0aGlzLnNlcmlhbGl6ZSgpLFxuICAgICAgT2JqZWN0LmFzc2lnbih7IHRyYW5zYWN0aW9uSWQ6IHRoaXMudHJ4SWQgfSwgZGVmYXVsdE11dGF0ZU9wdGlvbnMsIG9wdGlvbnMgfHwge30pXG4gICAgKTtcbiAgfVxuICBwYXRjaChwYXRjaE9yRG9jdW1lbnRJZCwgcGF0Y2hPcHMpIHtcbiAgICBjb25zdCBpc0J1aWxkZXIgPSB0eXBlb2YgcGF0Y2hPcHMgPT0gXCJmdW5jdGlvblwiLCBpc1BhdGNoID0gdHlwZW9mIHBhdGNoT3JEb2N1bWVudElkICE9IFwic3RyaW5nXCIgJiYgcGF0Y2hPckRvY3VtZW50SWQgaW5zdGFuY2VvZiBQYXRjaCwgaXNNdXRhdGlvblNlbGVjdGlvbiA9IHR5cGVvZiBwYXRjaE9yRG9jdW1lbnRJZCA9PSBcIm9iamVjdFwiICYmIChcInF1ZXJ5XCIgaW4gcGF0Y2hPckRvY3VtZW50SWQgfHwgXCJpZFwiIGluIHBhdGNoT3JEb2N1bWVudElkKTtcbiAgICBpZiAoaXNQYXRjaClcbiAgICAgIHJldHVybiB0aGlzLl9hZGQoeyBwYXRjaDogcGF0Y2hPckRvY3VtZW50SWQuc2VyaWFsaXplKCkgfSk7XG4gICAgaWYgKGlzQnVpbGRlcikge1xuICAgICAgY29uc3QgcGF0Y2ggPSBwYXRjaE9wcyhuZXcgUGF0Y2gocGF0Y2hPckRvY3VtZW50SWQsIHt9LCB0aGlzLiNjbGllbnQpKTtcbiAgICAgIGlmICghKHBhdGNoIGluc3RhbmNlb2YgUGF0Y2gpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJmdW5jdGlvbiBwYXNzZWQgdG8gYHBhdGNoKClgIG11c3QgcmV0dXJuIHRoZSBwYXRjaFwiKTtcbiAgICAgIHJldHVybiB0aGlzLl9hZGQoeyBwYXRjaDogcGF0Y2guc2VyaWFsaXplKCkgfSk7XG4gICAgfVxuICAgIGlmIChpc011dGF0aW9uU2VsZWN0aW9uKSB7XG4gICAgICBjb25zdCBwYXRjaCA9IG5ldyBQYXRjaChwYXRjaE9yRG9jdW1lbnRJZCwgcGF0Y2hPcHMgfHwge30sIHRoaXMuI2NsaWVudCk7XG4gICAgICByZXR1cm4gdGhpcy5fYWRkKHsgcGF0Y2g6IHBhdGNoLnNlcmlhbGl6ZSgpIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fYWRkKHsgcGF0Y2g6IHsgaWQ6IHBhdGNoT3JEb2N1bWVudElkLCAuLi5wYXRjaE9wcyB9IH0pO1xuICB9XG59XG5jbGFzcyBPYnNlcnZhYmxlVHJhbnNhY3Rpb24gZXh0ZW5kcyBCYXNlVHJhbnNhY3Rpb24ge1xuICAjY2xpZW50O1xuICBjb25zdHJ1Y3RvcihvcGVyYXRpb25zLCBjbGllbnQsIHRyYW5zYWN0aW9uSWQpIHtcbiAgICBzdXBlcihvcGVyYXRpb25zLCB0cmFuc2FjdGlvbklkKSwgdGhpcy4jY2xpZW50ID0gY2xpZW50O1xuICB9XG4gIC8qKlxuICAgKiBDbG9uZXMgdGhlIHRyYW5zYWN0aW9uXG4gICAqL1xuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IE9ic2VydmFibGVUcmFuc2FjdGlvbihbLi4udGhpcy5vcGVyYXRpb25zXSwgdGhpcy4jY2xpZW50LCB0aGlzLnRyeElkKTtcbiAgfVxuICBjb21taXQob3B0aW9ucykge1xuICAgIGlmICghdGhpcy4jY2xpZW50KVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIk5vIGBjbGllbnRgIHBhc3NlZCB0byB0cmFuc2FjdGlvbiwgZWl0aGVyIHByb3ZpZGUgb25lIG9yIHBhc3MgdGhlIHRyYW5zYWN0aW9uIHRvIGEgY2xpZW50cyBgbXV0YXRlKClgIG1ldGhvZFwiXG4gICAgICApO1xuICAgIHJldHVybiB0aGlzLiNjbGllbnQubXV0YXRlKFxuICAgICAgdGhpcy5zZXJpYWxpemUoKSxcbiAgICAgIE9iamVjdC5hc3NpZ24oeyB0cmFuc2FjdGlvbklkOiB0aGlzLnRyeElkIH0sIGRlZmF1bHRNdXRhdGVPcHRpb25zLCBvcHRpb25zIHx8IHt9KVxuICAgICk7XG4gIH1cbiAgcGF0Y2gocGF0Y2hPckRvY3VtZW50SWQsIHBhdGNoT3BzKSB7XG4gICAgY29uc3QgaXNCdWlsZGVyID0gdHlwZW9mIHBhdGNoT3BzID09IFwiZnVuY3Rpb25cIjtcbiAgICBpZiAodHlwZW9mIHBhdGNoT3JEb2N1bWVudElkICE9IFwic3RyaW5nXCIgJiYgcGF0Y2hPckRvY3VtZW50SWQgaW5zdGFuY2VvZiBPYnNlcnZhYmxlUGF0Y2gpXG4gICAgICByZXR1cm4gdGhpcy5fYWRkKHsgcGF0Y2g6IHBhdGNoT3JEb2N1bWVudElkLnNlcmlhbGl6ZSgpIH0pO1xuICAgIGlmIChpc0J1aWxkZXIpIHtcbiAgICAgIGNvbnN0IHBhdGNoID0gcGF0Y2hPcHMobmV3IE9ic2VydmFibGVQYXRjaChwYXRjaE9yRG9jdW1lbnRJZCwge30sIHRoaXMuI2NsaWVudCkpO1xuICAgICAgaWYgKCEocGF0Y2ggaW5zdGFuY2VvZiBPYnNlcnZhYmxlUGF0Y2gpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJmdW5jdGlvbiBwYXNzZWQgdG8gYHBhdGNoKClgIG11c3QgcmV0dXJuIHRoZSBwYXRjaFwiKTtcbiAgICAgIHJldHVybiB0aGlzLl9hZGQoeyBwYXRjaDogcGF0Y2guc2VyaWFsaXplKCkgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9hZGQoeyBwYXRjaDogeyBpZDogcGF0Y2hPckRvY3VtZW50SWQsIC4uLnBhdGNoT3BzIH0gfSk7XG4gIH1cbn1cbmNvbnN0IHByb2plY3RIZWFkZXIgPSBcIlgtU2FuaXR5LVByb2plY3QtSURcIjtcbmZ1bmN0aW9uIHJlcXVlc3RPcHRpb25zKGNvbmZpZywgb3ZlcnJpZGVzID0ge30pIHtcbiAgY29uc3QgaGVhZGVyczIgPSB7fSwgdG9rZW4gPSBvdmVycmlkZXMudG9rZW4gfHwgY29uZmlnLnRva2VuO1xuICB0b2tlbiAmJiAoaGVhZGVyczIuQXV0aG9yaXphdGlvbiA9IGBCZWFyZXIgJHt0b2tlbn1gKSwgIW92ZXJyaWRlcy51c2VHbG9iYWxBcGkgJiYgIWNvbmZpZy51c2VQcm9qZWN0SG9zdG5hbWUgJiYgY29uZmlnLnByb2plY3RJZCAmJiAoaGVhZGVyczJbcHJvamVjdEhlYWRlcl0gPSBjb25maWcucHJvamVjdElkKTtcbiAgY29uc3Qgd2l0aENyZWRlbnRpYWxzID0gISEodHlwZW9mIG92ZXJyaWRlcy53aXRoQ3JlZGVudGlhbHMgPiBcInVcIiA/IGNvbmZpZy50b2tlbiB8fCBjb25maWcud2l0aENyZWRlbnRpYWxzIDogb3ZlcnJpZGVzLndpdGhDcmVkZW50aWFscyksIHRpbWVvdXQgPSB0eXBlb2Ygb3ZlcnJpZGVzLnRpbWVvdXQgPiBcInVcIiA/IGNvbmZpZy50aW1lb3V0IDogb3ZlcnJpZGVzLnRpbWVvdXQ7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBvdmVycmlkZXMsIHtcbiAgICBoZWFkZXJzOiBPYmplY3QuYXNzaWduKHt9LCBoZWFkZXJzMiwgb3ZlcnJpZGVzLmhlYWRlcnMgfHwge30pLFxuICAgIHRpbWVvdXQ6IHR5cGVvZiB0aW1lb3V0ID4gXCJ1XCIgPyA1ICogNjAgKiAxZTMgOiB0aW1lb3V0LFxuICAgIHByb3h5OiBvdmVycmlkZXMucHJveHkgfHwgY29uZmlnLnByb3h5LFxuICAgIGpzb246ICEwLFxuICAgIHdpdGhDcmVkZW50aWFscyxcbiAgICBmZXRjaDogdHlwZW9mIG92ZXJyaWRlcy5mZXRjaCA9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBjb25maWcuZmV0Y2ggPT0gXCJvYmplY3RcIiA/IHsgLi4uY29uZmlnLmZldGNoLCAuLi5vdmVycmlkZXMuZmV0Y2ggfSA6IG92ZXJyaWRlcy5mZXRjaCB8fCBjb25maWcuZmV0Y2hcbiAgfSk7XG59XG5jb25zdCBlbmNvZGVRdWVyeVN0cmluZyA9ICh7XG4gIHF1ZXJ5LFxuICBwYXJhbXMgPSB7fSxcbiAgb3B0aW9ucyA9IHt9XG59KSA9PiB7XG4gIGNvbnN0IHNlYXJjaFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKSwgeyB0YWcsIGluY2x1ZGVNdXRhdGlvbnMsIHJldHVyblF1ZXJ5LCAuLi5vcHRzIH0gPSBvcHRpb25zO1xuICB0YWcgJiYgc2VhcmNoUGFyYW1zLmFwcGVuZChcInRhZ1wiLCB0YWcpLCBzZWFyY2hQYXJhbXMuYXBwZW5kKFwicXVlcnlcIiwgcXVlcnkpO1xuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhwYXJhbXMpKVxuICAgIHNlYXJjaFBhcmFtcy5hcHBlbmQoYCQke2tleX1gLCBKU09OLnN0cmluZ2lmeSh2YWx1ZSkpO1xuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhvcHRzKSlcbiAgICB2YWx1ZSAmJiBzZWFyY2hQYXJhbXMuYXBwZW5kKGtleSwgYCR7dmFsdWV9YCk7XG4gIHJldHVybiByZXR1cm5RdWVyeSA9PT0gITEgJiYgc2VhcmNoUGFyYW1zLmFwcGVuZChcInJldHVyblF1ZXJ5XCIsIFwiZmFsc2VcIiksIGluY2x1ZGVNdXRhdGlvbnMgPT09ICExICYmIHNlYXJjaFBhcmFtcy5hcHBlbmQoXCJpbmNsdWRlTXV0YXRpb25zXCIsIFwiZmFsc2VcIiksIGA/JHtzZWFyY2hQYXJhbXN9YDtcbn0sIGV4Y2x1ZGVGYWxzZXkgPSAocGFyYW0sIGRlZlZhbHVlKSA9PiBwYXJhbSA9PT0gITEgPyB2b2lkIDAgOiB0eXBlb2YgcGFyYW0gPiBcInVcIiA/IGRlZlZhbHVlIDogcGFyYW0sIGdldE11dGF0aW9uUXVlcnkgPSAob3B0aW9ucyA9IHt9KSA9PiAoe1xuICBkcnlSdW46IG9wdGlvbnMuZHJ5UnVuLFxuICByZXR1cm5JZHM6ICEwLFxuICByZXR1cm5Eb2N1bWVudHM6IGV4Y2x1ZGVGYWxzZXkob3B0aW9ucy5yZXR1cm5Eb2N1bWVudHMsICEwKSxcbiAgdmlzaWJpbGl0eTogb3B0aW9ucy52aXNpYmlsaXR5IHx8IFwic3luY1wiLFxuICBhdXRvR2VuZXJhdGVBcnJheUtleXM6IG9wdGlvbnMuYXV0b0dlbmVyYXRlQXJyYXlLZXlzLFxuICBza2lwQ3Jvc3NEYXRhc2V0UmVmZXJlbmNlVmFsaWRhdGlvbjogb3B0aW9ucy5za2lwQ3Jvc3NEYXRhc2V0UmVmZXJlbmNlVmFsaWRhdGlvblxufSksIGlzUmVzcG9uc2UgPSAoZXZlbnQpID0+IGV2ZW50LnR5cGUgPT09IFwicmVzcG9uc2VcIiwgZ2V0Qm9keSA9IChldmVudCkgPT4gZXZlbnQuYm9keSwgaW5kZXhCeSA9IChkb2NzLCBhdHRyKSA9PiBkb2NzLnJlZHVjZSgoaW5kZXhlZCwgZG9jKSA9PiAoaW5kZXhlZFthdHRyKGRvYyldID0gZG9jLCBpbmRleGVkKSwgLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCkpLCBnZXRRdWVyeVNpemVMaW1pdCA9IDExMjY0O1xuZnVuY3Rpb24gX2ZldGNoKGNsaWVudCwgaHR0cFJlcXVlc3QsIF9zdGVnYSwgcXVlcnksIF9wYXJhbXMgPSB7fSwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHN0ZWdhID0gXCJzdGVnYVwiIGluIG9wdGlvbnMgPyB7XG4gICAgLi4uX3N0ZWdhIHx8IHt9LFxuICAgIC4uLnR5cGVvZiBvcHRpb25zLnN0ZWdhID09IFwiYm9vbGVhblwiID8geyBlbmFibGVkOiBvcHRpb25zLnN0ZWdhIH0gOiBvcHRpb25zLnN0ZWdhIHx8IHt9XG4gIH0gOiBfc3RlZ2EsIHBhcmFtcyA9IHN0ZWdhLmVuYWJsZWQgPyBzdGVnYUNsZWFuKF9wYXJhbXMpIDogX3BhcmFtcywgbWFwUmVzcG9uc2UgPSBvcHRpb25zLmZpbHRlclJlc3BvbnNlID09PSAhMSA/IChyZXMpID0+IHJlcyA6IChyZXMpID0+IHJlcy5yZXN1bHQsIHsgY2FjaGUsIG5leHQsIC4uLm9wdHMgfSA9IHtcbiAgICAvLyBPcHQgb3V0IG9mIHNldHRpbmcgYSBgc2lnbmFsYCBvbiBhbiBpbnRlcm5hbCBgZmV0Y2hgIGlmIG9uZSBpc24ndCBwcm92aWRlZC5cbiAgICAvLyBUaGlzIGlzIG5lY2Vzc2FyeSBpbiBSZWFjdCBTZXJ2ZXIgQ29tcG9uZW50cyB0byBhdm9pZCBvcHRpbmcgb3V0IG9mIFJlcXVlc3QgTWVtb2l6YXRpb24uXG4gICAgdXNlQWJvcnRTaWduYWw6IHR5cGVvZiBvcHRpb25zLnNpZ25hbCA8IFwidVwiLFxuICAgIC8vIFNldCBgcmVzdWx0U291cmNlTWFwJyB3aGVuIHN0ZWdhIGlzIGVuYWJsZWQsIGFzIGl0J3MgcmVxdWlyZWQgZm9yIGVuY29kaW5nLlxuICAgIHJlc3VsdFNvdXJjZU1hcDogc3RlZ2EuZW5hYmxlZCA/IFwid2l0aEtleUFycmF5U2VsZWN0b3JcIiA6IG9wdGlvbnMucmVzdWx0U291cmNlTWFwLFxuICAgIC4uLm9wdGlvbnMsXG4gICAgLy8gRGVmYXVsdCB0byBub3QgcmV0dXJuaW5nIHRoZSBxdWVyeSwgdW5sZXNzIGBmaWx0ZXJSZXNwb25zZWAgaXMgYGZhbHNlYCxcbiAgICAvLyBvciBgcmV0dXJuUXVlcnlgIGlzIGV4cGxpY2l0bHkgc2V0LiBgdHJ1ZWAgaXMgdGhlIGRlZmF1bHQgaW4gQ29udGVudCBMYWtlLCBzbyBza2lwIGlmIHRydXRoeVxuICAgIHJldHVyblF1ZXJ5OiBvcHRpb25zLmZpbHRlclJlc3BvbnNlID09PSAhMSAmJiBvcHRpb25zLnJldHVyblF1ZXJ5ICE9PSAhMVxuICB9LCByZXFPcHRzID0gdHlwZW9mIGNhY2hlIDwgXCJ1XCIgfHwgdHlwZW9mIG5leHQgPCBcInVcIiA/IHsgLi4ub3B0cywgZmV0Y2g6IHsgY2FjaGUsIG5leHQgfSB9IDogb3B0cywgJHJlcXVlc3QgPSBfZGF0YVJlcXVlc3QoY2xpZW50LCBodHRwUmVxdWVzdCwgXCJxdWVyeVwiLCB7IHF1ZXJ5LCBwYXJhbXMgfSwgcmVxT3B0cyk7XG4gIHJldHVybiBzdGVnYS5lbmFibGVkID8gJHJlcXVlc3QucGlwZShcbiAgICBjb21iaW5lTGF0ZXN0V2l0aChcbiAgICAgIGZyb20oXG4gICAgICAgIGltcG9ydChcIi4vX2NodW5rcy1lcy9zdGVnYUVuY29kZVNvdXJjZU1hcC5qc1wiKS50aGVuKGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgICByZXR1cm4gbi5zdGVnYUVuY29kZVNvdXJjZU1hcCQxO1xuICAgICAgICB9KS50aGVuKFxuICAgICAgICAgICh7IHN0ZWdhRW5jb2RlU291cmNlTWFwIH0pID0+IHN0ZWdhRW5jb2RlU291cmNlTWFwXG4gICAgICAgIClcbiAgICAgIClcbiAgICApLFxuICAgIG1hcChcbiAgICAgIChbcmVzLCBzdGVnYUVuY29kZVNvdXJjZU1hcF0pID0+IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gc3RlZ2FFbmNvZGVTb3VyY2VNYXAocmVzLnJlc3VsdCwgcmVzLnJlc3VsdFNvdXJjZU1hcCwgc3RlZ2EpO1xuICAgICAgICByZXR1cm4gbWFwUmVzcG9uc2UoeyAuLi5yZXMsIHJlc3VsdCB9KTtcbiAgICAgIH1cbiAgICApXG4gICkgOiAkcmVxdWVzdC5waXBlKG1hcChtYXBSZXNwb25zZSkpO1xufVxuZnVuY3Rpb24gX2dldERvY3VtZW50KGNsaWVudCwgaHR0cFJlcXVlc3QsIGlkLCBvcHRzID0ge30pIHtcbiAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICB1cmk6IF9nZXREYXRhVXJsKGNsaWVudCwgXCJkb2NcIiwgaWQpLFxuICAgIGpzb246ICEwLFxuICAgIHRhZzogb3B0cy50YWcsXG4gICAgc2lnbmFsOiBvcHRzLnNpZ25hbFxuICB9O1xuICByZXR1cm4gX3JlcXVlc3RPYnNlcnZhYmxlKGNsaWVudCwgaHR0cFJlcXVlc3QsIG9wdGlvbnMpLnBpcGUoXG4gICAgZmlsdGVyKGlzUmVzcG9uc2UpLFxuICAgIG1hcCgoZXZlbnQpID0+IGV2ZW50LmJvZHkuZG9jdW1lbnRzICYmIGV2ZW50LmJvZHkuZG9jdW1lbnRzWzBdKVxuICApO1xufVxuZnVuY3Rpb24gX2dldERvY3VtZW50cyhjbGllbnQsIGh0dHBSZXF1ZXN0LCBpZHMsIG9wdHMgPSB7fSkge1xuICBjb25zdCBvcHRpb25zID0ge1xuICAgIHVyaTogX2dldERhdGFVcmwoY2xpZW50LCBcImRvY1wiLCBpZHMuam9pbihcIixcIikpLFxuICAgIGpzb246ICEwLFxuICAgIHRhZzogb3B0cy50YWcsXG4gICAgc2lnbmFsOiBvcHRzLnNpZ25hbFxuICB9O1xuICByZXR1cm4gX3JlcXVlc3RPYnNlcnZhYmxlKGNsaWVudCwgaHR0cFJlcXVlc3QsIG9wdGlvbnMpLnBpcGUoXG4gICAgZmlsdGVyKGlzUmVzcG9uc2UpLFxuICAgIG1hcCgoZXZlbnQpID0+IHtcbiAgICAgIGNvbnN0IGluZGV4ZWQgPSBpbmRleEJ5KGV2ZW50LmJvZHkuZG9jdW1lbnRzIHx8IFtdLCAoZG9jKSA9PiBkb2MuX2lkKTtcbiAgICAgIHJldHVybiBpZHMubWFwKChpZCkgPT4gaW5kZXhlZFtpZF0gfHwgbnVsbCk7XG4gICAgfSlcbiAgKTtcbn1cbmZ1bmN0aW9uIF9jcmVhdGVJZk5vdEV4aXN0cyhjbGllbnQsIGh0dHBSZXF1ZXN0LCBkb2MsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHJlcXVpcmVEb2N1bWVudElkKFwiY3JlYXRlSWZOb3RFeGlzdHNcIiwgZG9jKSwgX2NyZWF0ZShjbGllbnQsIGh0dHBSZXF1ZXN0LCBkb2MsIFwiY3JlYXRlSWZOb3RFeGlzdHNcIiwgb3B0aW9ucyk7XG59XG5mdW5jdGlvbiBfY3JlYXRlT3JSZXBsYWNlKGNsaWVudCwgaHR0cFJlcXVlc3QsIGRvYywgb3B0aW9ucykge1xuICByZXR1cm4gcmVxdWlyZURvY3VtZW50SWQoXCJjcmVhdGVPclJlcGxhY2VcIiwgZG9jKSwgX2NyZWF0ZShjbGllbnQsIGh0dHBSZXF1ZXN0LCBkb2MsIFwiY3JlYXRlT3JSZXBsYWNlXCIsIG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gX2RlbGV0ZShjbGllbnQsIGh0dHBSZXF1ZXN0LCBzZWxlY3Rpb24sIG9wdGlvbnMpIHtcbiAgcmV0dXJuIF9kYXRhUmVxdWVzdChcbiAgICBjbGllbnQsXG4gICAgaHR0cFJlcXVlc3QsXG4gICAgXCJtdXRhdGVcIixcbiAgICB7IG11dGF0aW9uczogW3sgZGVsZXRlOiBnZXRTZWxlY3Rpb24oc2VsZWN0aW9uKSB9XSB9LFxuICAgIG9wdGlvbnNcbiAgKTtcbn1cbmZ1bmN0aW9uIF9tdXRhdGUoY2xpZW50LCBodHRwUmVxdWVzdCwgbXV0YXRpb25zLCBvcHRpb25zKSB7XG4gIGxldCBtdXQ7XG4gIG11dGF0aW9ucyBpbnN0YW5jZW9mIFBhdGNoIHx8IG11dGF0aW9ucyBpbnN0YW5jZW9mIE9ic2VydmFibGVQYXRjaCA/IG11dCA9IHsgcGF0Y2g6IG11dGF0aW9ucy5zZXJpYWxpemUoKSB9IDogbXV0YXRpb25zIGluc3RhbmNlb2YgVHJhbnNhY3Rpb24gfHwgbXV0YXRpb25zIGluc3RhbmNlb2YgT2JzZXJ2YWJsZVRyYW5zYWN0aW9uID8gbXV0ID0gbXV0YXRpb25zLnNlcmlhbGl6ZSgpIDogbXV0ID0gbXV0YXRpb25zO1xuICBjb25zdCBtdXRzID0gQXJyYXkuaXNBcnJheShtdXQpID8gbXV0IDogW211dF0sIHRyYW5zYWN0aW9uSWQgPSBvcHRpb25zICYmIG9wdGlvbnMudHJhbnNhY3Rpb25JZCB8fCB2b2lkIDA7XG4gIHJldHVybiBfZGF0YVJlcXVlc3QoY2xpZW50LCBodHRwUmVxdWVzdCwgXCJtdXRhdGVcIiwgeyBtdXRhdGlvbnM6IG11dHMsIHRyYW5zYWN0aW9uSWQgfSwgb3B0aW9ucyk7XG59XG5mdW5jdGlvbiBfYWN0aW9uKGNsaWVudCwgaHR0cFJlcXVlc3QsIGFjdGlvbnMsIG9wdGlvbnMpIHtcbiAgY29uc3QgYWN0cyA9IEFycmF5LmlzQXJyYXkoYWN0aW9ucykgPyBhY3Rpb25zIDogW2FjdGlvbnNdLCB0cmFuc2FjdGlvbklkID0gb3B0aW9ucyAmJiBvcHRpb25zLnRyYW5zYWN0aW9uSWQgfHwgdm9pZCAwLCBza2lwQ3Jvc3NEYXRhc2V0UmVmZXJlbmNlVmFsaWRhdGlvbiA9IG9wdGlvbnMgJiYgb3B0aW9ucy5za2lwQ3Jvc3NEYXRhc2V0UmVmZXJlbmNlVmFsaWRhdGlvbiB8fCB2b2lkIDAsIGRyeVJ1biA9IG9wdGlvbnMgJiYgb3B0aW9ucy5kcnlSdW4gfHwgdm9pZCAwO1xuICByZXR1cm4gX2RhdGFSZXF1ZXN0KFxuICAgIGNsaWVudCxcbiAgICBodHRwUmVxdWVzdCxcbiAgICBcImFjdGlvbnNcIixcbiAgICB7IGFjdGlvbnM6IGFjdHMsIHRyYW5zYWN0aW9uSWQsIHNraXBDcm9zc0RhdGFzZXRSZWZlcmVuY2VWYWxpZGF0aW9uLCBkcnlSdW4gfSxcbiAgICBvcHRpb25zXG4gICk7XG59XG5mdW5jdGlvbiBfZGF0YVJlcXVlc3QoY2xpZW50LCBodHRwUmVxdWVzdCwgZW5kcG9pbnQsIGJvZHksIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCBpc011dGF0aW9uID0gZW5kcG9pbnQgPT09IFwibXV0YXRlXCIsIGlzQWN0aW9uID0gZW5kcG9pbnQgPT09IFwiYWN0aW9uc1wiLCBpc1F1ZXJ5ID0gZW5kcG9pbnQgPT09IFwicXVlcnlcIiwgc3RyUXVlcnkgPSBpc011dGF0aW9uIHx8IGlzQWN0aW9uID8gXCJcIiA6IGVuY29kZVF1ZXJ5U3RyaW5nKGJvZHkpLCB1c2VHZXQgPSAhaXNNdXRhdGlvbiAmJiAhaXNBY3Rpb24gJiYgc3RyUXVlcnkubGVuZ3RoIDwgZ2V0UXVlcnlTaXplTGltaXQsIHN0cmluZ1F1ZXJ5ID0gdXNlR2V0ID8gc3RyUXVlcnkgOiBcIlwiLCByZXR1cm5GaXJzdCA9IG9wdGlvbnMucmV0dXJuRmlyc3QsIHsgdGltZW91dCwgdG9rZW4sIHRhZywgaGVhZGVyczogaGVhZGVyczIsIHJldHVyblF1ZXJ5LCBsYXN0TGl2ZUV2ZW50SWQsIGNhY2hlTW9kZSB9ID0gb3B0aW9ucywgdXJpID0gX2dldERhdGFVcmwoY2xpZW50LCBlbmRwb2ludCwgc3RyaW5nUXVlcnkpLCByZXFPcHRpb25zID0ge1xuICAgIG1ldGhvZDogdXNlR2V0ID8gXCJHRVRcIiA6IFwiUE9TVFwiLFxuICAgIHVyaSxcbiAgICBqc29uOiAhMCxcbiAgICBib2R5OiB1c2VHZXQgPyB2b2lkIDAgOiBib2R5LFxuICAgIHF1ZXJ5OiBpc011dGF0aW9uICYmIGdldE11dGF0aW9uUXVlcnkob3B0aW9ucyksXG4gICAgdGltZW91dCxcbiAgICBoZWFkZXJzOiBoZWFkZXJzMixcbiAgICB0b2tlbixcbiAgICB0YWcsXG4gICAgcmV0dXJuUXVlcnksXG4gICAgcGVyc3BlY3RpdmU6IG9wdGlvbnMucGVyc3BlY3RpdmUsXG4gICAgcmVzdWx0U291cmNlTWFwOiBvcHRpb25zLnJlc3VsdFNvdXJjZU1hcCxcbiAgICBsYXN0TGl2ZUV2ZW50SWQ6IEFycmF5LmlzQXJyYXkobGFzdExpdmVFdmVudElkKSA/IGxhc3RMaXZlRXZlbnRJZFswXSA6IGxhc3RMaXZlRXZlbnRJZCxcbiAgICBjYWNoZU1vZGUsXG4gICAgY2FuVXNlQ2RuOiBpc1F1ZXJ5LFxuICAgIHNpZ25hbDogb3B0aW9ucy5zaWduYWwsXG4gICAgZmV0Y2g6IG9wdGlvbnMuZmV0Y2gsXG4gICAgdXNlQWJvcnRTaWduYWw6IG9wdGlvbnMudXNlQWJvcnRTaWduYWwsXG4gICAgdXNlQ2RuOiBvcHRpb25zLnVzZUNkblxuICB9O1xuICByZXR1cm4gX3JlcXVlc3RPYnNlcnZhYmxlKGNsaWVudCwgaHR0cFJlcXVlc3QsIHJlcU9wdGlvbnMpLnBpcGUoXG4gICAgZmlsdGVyKGlzUmVzcG9uc2UpLFxuICAgIG1hcChnZXRCb2R5KSxcbiAgICBtYXAoKHJlcykgPT4ge1xuICAgICAgaWYgKCFpc011dGF0aW9uKVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgY29uc3QgcmVzdWx0cyA9IHJlcy5yZXN1bHRzIHx8IFtdO1xuICAgICAgaWYgKG9wdGlvbnMucmV0dXJuRG9jdW1lbnRzKVxuICAgICAgICByZXR1cm4gcmV0dXJuRmlyc3QgPyByZXN1bHRzWzBdICYmIHJlc3VsdHNbMF0uZG9jdW1lbnQgOiByZXN1bHRzLm1hcCgobXV0KSA9PiBtdXQuZG9jdW1lbnQpO1xuICAgICAgY29uc3Qga2V5ID0gcmV0dXJuRmlyc3QgPyBcImRvY3VtZW50SWRcIiA6IFwiZG9jdW1lbnRJZHNcIiwgaWRzID0gcmV0dXJuRmlyc3QgPyByZXN1bHRzWzBdICYmIHJlc3VsdHNbMF0uaWQgOiByZXN1bHRzLm1hcCgobXV0KSA9PiBtdXQuaWQpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHJhbnNhY3Rpb25JZDogcmVzLnRyYW5zYWN0aW9uSWQsXG4gICAgICAgIHJlc3VsdHMsXG4gICAgICAgIFtrZXldOiBpZHNcbiAgICAgIH07XG4gICAgfSlcbiAgKTtcbn1cbmZ1bmN0aW9uIF9jcmVhdGUoY2xpZW50LCBodHRwUmVxdWVzdCwgZG9jLCBvcCwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IG11dGF0aW9uID0geyBbb3BdOiBkb2MgfSwgb3B0cyA9IE9iamVjdC5hc3NpZ24oeyByZXR1cm5GaXJzdDogITAsIHJldHVybkRvY3VtZW50czogITAgfSwgb3B0aW9ucyk7XG4gIHJldHVybiBfZGF0YVJlcXVlc3QoY2xpZW50LCBodHRwUmVxdWVzdCwgXCJtdXRhdGVcIiwgeyBtdXRhdGlvbnM6IFttdXRhdGlvbl0gfSwgb3B0cyk7XG59XG5mdW5jdGlvbiBfcmVxdWVzdE9ic2VydmFibGUoY2xpZW50LCBodHRwUmVxdWVzdCwgb3B0aW9ucykge1xuICBjb25zdCB1cmkgPSBvcHRpb25zLnVybCB8fCBvcHRpb25zLnVyaSwgY29uZmlnID0gY2xpZW50LmNvbmZpZygpLCBjYW5Vc2VDZG4gPSB0eXBlb2Ygb3B0aW9ucy5jYW5Vc2VDZG4gPiBcInVcIiA/IFtcIkdFVFwiLCBcIkhFQURcIl0uaW5kZXhPZihvcHRpb25zLm1ldGhvZCB8fCBcIkdFVFwiKSA+PSAwICYmIHVyaS5pbmRleE9mKFwiL2RhdGEvXCIpID09PSAwIDogb3B0aW9ucy5jYW5Vc2VDZG47XG4gIGxldCB1c2VDZG4gPSAob3B0aW9ucy51c2VDZG4gPz8gY29uZmlnLnVzZUNkbikgJiYgY2FuVXNlQ2RuO1xuICBjb25zdCB0YWcgPSBvcHRpb25zLnRhZyAmJiBjb25maWcucmVxdWVzdFRhZ1ByZWZpeCA/IFtjb25maWcucmVxdWVzdFRhZ1ByZWZpeCwgb3B0aW9ucy50YWddLmpvaW4oXCIuXCIpIDogb3B0aW9ucy50YWcgfHwgY29uZmlnLnJlcXVlc3RUYWdQcmVmaXg7XG4gIGlmICh0YWcgJiYgb3B0aW9ucy50YWcgIT09IG51bGwgJiYgKG9wdGlvbnMucXVlcnkgPSB7IHRhZzogcmVxdWVzdFRhZyh0YWcpLCAuLi5vcHRpb25zLnF1ZXJ5IH0pLCBbXCJHRVRcIiwgXCJIRUFEXCIsIFwiUE9TVFwiXS5pbmRleE9mKG9wdGlvbnMubWV0aG9kIHx8IFwiR0VUXCIpID49IDAgJiYgdXJpLmluZGV4T2YoXCIvZGF0YS9xdWVyeS9cIikgPT09IDApIHtcbiAgICBjb25zdCByZXN1bHRTb3VyY2VNYXAgPSBvcHRpb25zLnJlc3VsdFNvdXJjZU1hcCA/PyBjb25maWcucmVzdWx0U291cmNlTWFwO1xuICAgIHJlc3VsdFNvdXJjZU1hcCAhPT0gdm9pZCAwICYmIHJlc3VsdFNvdXJjZU1hcCAhPT0gITEgJiYgKG9wdGlvbnMucXVlcnkgPSB7IHJlc3VsdFNvdXJjZU1hcCwgLi4ub3B0aW9ucy5xdWVyeSB9KTtcbiAgICBjb25zdCBwZXJzcGVjdGl2ZU9wdGlvbiA9IG9wdGlvbnMucGVyc3BlY3RpdmUgfHwgY29uZmlnLnBlcnNwZWN0aXZlO1xuICAgIHR5cGVvZiBwZXJzcGVjdGl2ZU9wdGlvbiA8IFwidVwiICYmICh2YWxpZGF0ZUFwaVBlcnNwZWN0aXZlKHBlcnNwZWN0aXZlT3B0aW9uKSwgb3B0aW9ucy5xdWVyeSA9IHtcbiAgICAgIHBlcnNwZWN0aXZlOiBBcnJheS5pc0FycmF5KHBlcnNwZWN0aXZlT3B0aW9uKSA/IHBlcnNwZWN0aXZlT3B0aW9uLmpvaW4oXCIsXCIpIDogcGVyc3BlY3RpdmVPcHRpb24sXG4gICAgICAuLi5vcHRpb25zLnF1ZXJ5XG4gICAgfSwgcGVyc3BlY3RpdmVPcHRpb24gPT09IFwicHJldmlld0RyYWZ0c1wiICYmIHVzZUNkbiAmJiAodXNlQ2RuID0gITEsIHByaW50Q2RuUHJldmlld0RyYWZ0c1dhcm5pbmcoKSkpLCBvcHRpb25zLmxhc3RMaXZlRXZlbnRJZCAmJiAob3B0aW9ucy5xdWVyeSA9IHsgLi4ub3B0aW9ucy5xdWVyeSwgbGFzdExpdmVFdmVudElkOiBvcHRpb25zLmxhc3RMaXZlRXZlbnRJZCB9KSwgb3B0aW9ucy5yZXR1cm5RdWVyeSA9PT0gITEgJiYgKG9wdGlvbnMucXVlcnkgPSB7IHJldHVyblF1ZXJ5OiBcImZhbHNlXCIsIC4uLm9wdGlvbnMucXVlcnkgfSksIHVzZUNkbiAmJiBvcHRpb25zLmNhY2hlTW9kZSA9PSBcIm5vU3RhbGVcIiAmJiAob3B0aW9ucy5xdWVyeSA9IHsgY2FjaGVNb2RlOiBcIm5vU3RhbGVcIiwgLi4ub3B0aW9ucy5xdWVyeSB9KTtcbiAgfVxuICBjb25zdCByZXFPcHRpb25zID0gcmVxdWVzdE9wdGlvbnMoXG4gICAgY29uZmlnLFxuICAgIE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHtcbiAgICAgIHVybDogX2dldFVybChjbGllbnQsIHVyaSwgdXNlQ2RuKVxuICAgIH0pXG4gICksIHJlcXVlc3QgPSBuZXcgT2JzZXJ2YWJsZShcbiAgICAoc3Vic2NyaWJlcikgPT4gaHR0cFJlcXVlc3QocmVxT3B0aW9ucywgY29uZmlnLnJlcXVlc3Rlcikuc3Vic2NyaWJlKHN1YnNjcmliZXIpXG4gICk7XG4gIHJldHVybiBvcHRpb25zLnNpZ25hbCA/IHJlcXVlc3QucGlwZShfd2l0aEFib3J0U2lnbmFsKG9wdGlvbnMuc2lnbmFsKSkgOiByZXF1ZXN0O1xufVxuZnVuY3Rpb24gX3JlcXVlc3QoY2xpZW50LCBodHRwUmVxdWVzdCwgb3B0aW9ucykge1xuICByZXR1cm4gX3JlcXVlc3RPYnNlcnZhYmxlKGNsaWVudCwgaHR0cFJlcXVlc3QsIG9wdGlvbnMpLnBpcGUoXG4gICAgZmlsdGVyKChldmVudCkgPT4gZXZlbnQudHlwZSA9PT0gXCJyZXNwb25zZVwiKSxcbiAgICBtYXAoKGV2ZW50KSA9PiBldmVudC5ib2R5KVxuICApO1xufVxuZnVuY3Rpb24gX2dldERhdGFVcmwoY2xpZW50LCBvcGVyYXRpb24sIHBhdGgpIHtcbiAgY29uc3QgY29uZmlnID0gY2xpZW50LmNvbmZpZygpLCBjYXRhbG9nID0gaGFzRGF0YXNldChjb25maWcpLCBiYXNlVXJpID0gYC8ke29wZXJhdGlvbn0vJHtjYXRhbG9nfWA7XG4gIHJldHVybiBgL2RhdGEke3BhdGggPyBgJHtiYXNlVXJpfS8ke3BhdGh9YCA6IGJhc2VVcml9YC5yZXBsYWNlKC9cXC8oJHxcXD8pLywgXCIkMVwiKTtcbn1cbmZ1bmN0aW9uIF9nZXRVcmwoY2xpZW50LCB1cmksIGNhblVzZUNkbiA9ICExKSB7XG4gIGNvbnN0IHsgdXJsLCBjZG5VcmwgfSA9IGNsaWVudC5jb25maWcoKTtcbiAgcmV0dXJuIGAke2NhblVzZUNkbiA/IGNkblVybCA6IHVybH0vJHt1cmkucmVwbGFjZSgvXlxcLy8sIFwiXCIpfWA7XG59XG5mdW5jdGlvbiBfd2l0aEFib3J0U2lnbmFsKHNpZ25hbCkge1xuICByZXR1cm4gKGlucHV0KSA9PiBuZXcgT2JzZXJ2YWJsZSgob2JzZXJ2ZXIpID0+IHtcbiAgICBjb25zdCBhYm9ydCA9ICgpID0+IG9ic2VydmVyLmVycm9yKF9jcmVhdGVBYm9ydEVycm9yKHNpZ25hbCkpO1xuICAgIGlmIChzaWduYWwgJiYgc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgIGFib3J0KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IGlucHV0LnN1YnNjcmliZShvYnNlcnZlcik7XG4gICAgcmV0dXJuIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgYWJvcnQpLCAoKSA9PiB7XG4gICAgICBzaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIGFib3J0KSwgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgfTtcbiAgfSk7XG59XG5jb25zdCBpc0RvbUV4Y2VwdGlvblN1cHBvcnRlZCA9ICEhZ2xvYmFsVGhpcy5ET01FeGNlcHRpb247XG5mdW5jdGlvbiBfY3JlYXRlQWJvcnRFcnJvcihzaWduYWwpIHtcbiAgaWYgKGlzRG9tRXhjZXB0aW9uU3VwcG9ydGVkKVxuICAgIHJldHVybiBuZXcgRE9NRXhjZXB0aW9uKHNpZ25hbD8ucmVhc29uID8/IFwiVGhlIG9wZXJhdGlvbiB3YXMgYWJvcnRlZC5cIiwgXCJBYm9ydEVycm9yXCIpO1xuICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihzaWduYWw/LnJlYXNvbiA/PyBcIlRoZSBvcGVyYXRpb24gd2FzIGFib3J0ZWQuXCIpO1xuICByZXR1cm4gZXJyb3IubmFtZSA9IFwiQWJvcnRFcnJvclwiLCBlcnJvcjtcbn1cbmNsYXNzIE9ic2VydmFibGVBc3NldHNDbGllbnQge1xuICAjY2xpZW50O1xuICAjaHR0cFJlcXVlc3Q7XG4gIGNvbnN0cnVjdG9yKGNsaWVudCwgaHR0cFJlcXVlc3QpIHtcbiAgICB0aGlzLiNjbGllbnQgPSBjbGllbnQsIHRoaXMuI2h0dHBSZXF1ZXN0ID0gaHR0cFJlcXVlc3Q7XG4gIH1cbiAgdXBsb2FkKGFzc2V0VHlwZSwgYm9keSwgb3B0aW9ucykge1xuICAgIHJldHVybiBfdXBsb2FkKHRoaXMuI2NsaWVudCwgdGhpcy4jaHR0cFJlcXVlc3QsIGFzc2V0VHlwZSwgYm9keSwgb3B0aW9ucyk7XG4gIH1cbn1cbmNsYXNzIEFzc2V0c0NsaWVudCB7XG4gICNjbGllbnQ7XG4gICNodHRwUmVxdWVzdDtcbiAgY29uc3RydWN0b3IoY2xpZW50LCBodHRwUmVxdWVzdCkge1xuICAgIHRoaXMuI2NsaWVudCA9IGNsaWVudCwgdGhpcy4jaHR0cFJlcXVlc3QgPSBodHRwUmVxdWVzdDtcbiAgfVxuICB1cGxvYWQoYXNzZXRUeXBlLCBib2R5LCBvcHRpb25zKSB7XG4gICAgY29uc3Qgb2JzZXJ2YWJsZTIgPSBfdXBsb2FkKHRoaXMuI2NsaWVudCwgdGhpcy4jaHR0cFJlcXVlc3QsIGFzc2V0VHlwZSwgYm9keSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIGxhc3RWYWx1ZUZyb20oXG4gICAgICBvYnNlcnZhYmxlMi5waXBlKFxuICAgICAgICBmaWx0ZXIoKGV2ZW50KSA9PiBldmVudC50eXBlID09PSBcInJlc3BvbnNlXCIpLFxuICAgICAgICBtYXAoXG4gICAgICAgICAgKGV2ZW50KSA9PiBldmVudC5ib2R5LmRvY3VtZW50XG4gICAgICAgIClcbiAgICAgIClcbiAgICApO1xuICB9XG59XG5mdW5jdGlvbiBfdXBsb2FkKGNsaWVudCwgaHR0cFJlcXVlc3QsIGFzc2V0VHlwZSwgYm9keSwgb3B0cyA9IHt9KSB7XG4gIHZhbGlkYXRlQXNzZXRUeXBlKGFzc2V0VHlwZSk7XG4gIGxldCBtZXRhID0gb3B0cy5leHRyYWN0IHx8IHZvaWQgMDtcbiAgbWV0YSAmJiAhbWV0YS5sZW5ndGggJiYgKG1ldGEgPSBbXCJub25lXCJdKTtcbiAgY29uc3QgZGF0YXNldDIgPSBoYXNEYXRhc2V0KGNsaWVudC5jb25maWcoKSksIGFzc2V0RW5kcG9pbnQgPSBhc3NldFR5cGUgPT09IFwiaW1hZ2VcIiA/IFwiaW1hZ2VzXCIgOiBcImZpbGVzXCIsIG9wdGlvbnMgPSBvcHRpb25zRnJvbUZpbGUob3B0cywgYm9keSksIHsgdGFnLCBsYWJlbCwgdGl0bGUsIGRlc2NyaXB0aW9uLCBjcmVkaXRMaW5lLCBmaWxlbmFtZSwgc291cmNlIH0gPSBvcHRpb25zLCBxdWVyeSA9IHtcbiAgICBsYWJlbCxcbiAgICB0aXRsZSxcbiAgICBkZXNjcmlwdGlvbixcbiAgICBmaWxlbmFtZSxcbiAgICBtZXRhLFxuICAgIGNyZWRpdExpbmVcbiAgfTtcbiAgcmV0dXJuIHNvdXJjZSAmJiAocXVlcnkuc291cmNlSWQgPSBzb3VyY2UuaWQsIHF1ZXJ5LnNvdXJjZU5hbWUgPSBzb3VyY2UubmFtZSwgcXVlcnkuc291cmNlVXJsID0gc291cmNlLnVybCksIF9yZXF1ZXN0T2JzZXJ2YWJsZShjbGllbnQsIGh0dHBSZXF1ZXN0LCB7XG4gICAgdGFnLFxuICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgdGltZW91dDogb3B0aW9ucy50aW1lb3V0IHx8IDAsXG4gICAgdXJpOiBgL2Fzc2V0cy8ke2Fzc2V0RW5kcG9pbnR9LyR7ZGF0YXNldDJ9YCxcbiAgICBoZWFkZXJzOiBvcHRpb25zLmNvbnRlbnRUeXBlID8geyBcIkNvbnRlbnQtVHlwZVwiOiBvcHRpb25zLmNvbnRlbnRUeXBlIH0gOiB7fSxcbiAgICBxdWVyeSxcbiAgICBib2R5XG4gIH0pO1xufVxuZnVuY3Rpb24gb3B0aW9uc0Zyb21GaWxlKG9wdHMsIGZpbGUpIHtcbiAgcmV0dXJuIHR5cGVvZiBGaWxlID4gXCJ1XCIgfHwgIShmaWxlIGluc3RhbmNlb2YgRmlsZSkgPyBvcHRzIDogT2JqZWN0LmFzc2lnbihcbiAgICB7XG4gICAgICBmaWxlbmFtZTogb3B0cy5wcmVzZXJ2ZUZpbGVuYW1lID09PSAhMSA/IHZvaWQgMCA6IGZpbGUubmFtZSxcbiAgICAgIGNvbnRlbnRUeXBlOiBmaWxlLnR5cGVcbiAgICB9LFxuICAgIG9wdHNcbiAgKTtcbn1cbnZhciBkZWZhdWx0cyA9IChvYmosIGRlZmF1bHRzMikgPT4gT2JqZWN0LmtleXMoZGVmYXVsdHMyKS5jb25jYXQoT2JqZWN0LmtleXMob2JqKSkucmVkdWNlKCh0YXJnZXQsIHByb3ApID0+ICh0YXJnZXRbcHJvcF0gPSB0eXBlb2Ygb2JqW3Byb3BdID4gXCJ1XCIgPyBkZWZhdWx0czJbcHJvcF0gOiBvYmpbcHJvcF0sIHRhcmdldCksIHt9KTtcbmNvbnN0IHBpY2sgPSAob2JqLCBwcm9wcykgPT4gcHJvcHMucmVkdWNlKChzZWxlY3Rpb24sIHByb3ApID0+ICh0eXBlb2Ygb2JqW3Byb3BdID4gXCJ1XCIgfHwgKHNlbGVjdGlvbltwcm9wXSA9IG9ialtwcm9wXSksIHNlbGVjdGlvbiksIHt9KSwgZXZlbnRTb3VyY2VQb2x5ZmlsbCA9IGRlZmVyKCgpID0+IGltcG9ydChcIkBzYW5pdHkvZXZlbnRzb3VyY2VcIikpLnBpcGUoXG4gIG1hcCgoeyBkZWZhdWx0OiBFdmVudFNvdXJjZTIgfSkgPT4gRXZlbnRTb3VyY2UyKSxcbiAgc2hhcmVSZXBsYXkoMSlcbik7XG5mdW5jdGlvbiByZWNvbm5lY3RPbkNvbm5lY3Rpb25GYWlsdXJlKCkge1xuICByZXR1cm4gZnVuY3Rpb24oc291cmNlKSB7XG4gICAgcmV0dXJuIHNvdXJjZS5waXBlKFxuICAgICAgY2F0Y2hFcnJvcigoZXJyLCBjYXVnaHQpID0+IGVyciBpbnN0YW5jZW9mIENvbm5lY3Rpb25GYWlsZWRFcnJvciA/IGNvbmNhdChvZih7IHR5cGU6IFwicmVjb25uZWN0XCIgfSksIHRpbWVyKDFlMykucGlwZShtZXJnZU1hcCgoKSA9PiBjYXVnaHQpKSkgOiB0aHJvd0Vycm9yKCgpID0+IGVycikpXG4gICAgKTtcbiAgfTtcbn1cbmNvbnN0IE1BWF9VUkxfTEVOR1RIID0gMTQ4MDAsIHBvc3NpYmxlT3B0aW9ucyA9IFtcbiAgXCJpbmNsdWRlUHJldmlvdXNSZXZpc2lvblwiLFxuICBcImluY2x1ZGVSZXN1bHRcIixcbiAgXCJpbmNsdWRlTXV0YXRpb25zXCIsXG4gIFwidmlzaWJpbGl0eVwiLFxuICBcImVmZmVjdEZvcm1hdFwiLFxuICBcInRhZ1wiXG5dLCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgaW5jbHVkZVJlc3VsdDogITBcbn07XG5mdW5jdGlvbiBfbGlzdGVuKHF1ZXJ5LCBwYXJhbXMsIG9wdHMgPSB7fSkge1xuICBjb25zdCB7IHVybCwgdG9rZW4sIHdpdGhDcmVkZW50aWFscywgcmVxdWVzdFRhZ1ByZWZpeCB9ID0gdGhpcy5jb25maWcoKSwgdGFnID0gb3B0cy50YWcgJiYgcmVxdWVzdFRhZ1ByZWZpeCA/IFtyZXF1ZXN0VGFnUHJlZml4LCBvcHRzLnRhZ10uam9pbihcIi5cIikgOiBvcHRzLnRhZywgb3B0aW9ucyA9IHsgLi4uZGVmYXVsdHMob3B0cywgZGVmYXVsdE9wdGlvbnMpLCB0YWcgfSwgbGlzdGVuT3B0cyA9IHBpY2sob3B0aW9ucywgcG9zc2libGVPcHRpb25zKSwgcXMgPSBlbmNvZGVRdWVyeVN0cmluZyh7IHF1ZXJ5LCBwYXJhbXMsIG9wdGlvbnM6IHsgdGFnLCAuLi5saXN0ZW5PcHRzIH0gfSksIHVyaSA9IGAke3VybH0ke19nZXREYXRhVXJsKHRoaXMsIFwibGlzdGVuXCIsIHFzKX1gO1xuICBpZiAodXJpLmxlbmd0aCA+IE1BWF9VUkxfTEVOR1RIKVxuICAgIHJldHVybiB0aHJvd0Vycm9yKCgpID0+IG5ldyBFcnJvcihcIlF1ZXJ5IHRvbyBsYXJnZSBmb3IgbGlzdGVuZXJcIikpO1xuICBjb25zdCBsaXN0ZW5Gb3IgPSBvcHRpb25zLmV2ZW50cyA/IG9wdGlvbnMuZXZlbnRzIDogW1wibXV0YXRpb25cIl0sIGVzT3B0aW9ucyA9IHt9O1xuICByZXR1cm4gKHRva2VuIHx8IHdpdGhDcmVkZW50aWFscykgJiYgKGVzT3B0aW9ucy53aXRoQ3JlZGVudGlhbHMgPSAhMCksIHRva2VuICYmIChlc09wdGlvbnMuaGVhZGVycyA9IHtcbiAgICBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7dG9rZW59YFxuICB9KSwgY29ubmVjdEV2ZW50U291cmNlKCgpID0+IChcbiAgICAvLyB1c2UgcG9seWZpbGwgaWYgdGhlcmUgaXMgbm8gZ2xvYmFsIEV2ZW50U291cmNlIG9yIGlmIHdlIG5lZWQgdG8gc2V0IGhlYWRlcnNcbiAgICAodHlwZW9mIEV2ZW50U291cmNlID4gXCJ1XCIgfHwgZXNPcHRpb25zLmhlYWRlcnMgPyBldmVudFNvdXJjZVBvbHlmaWxsIDogb2YoRXZlbnRTb3VyY2UpKS5waXBlKG1hcCgoRXZlbnRTb3VyY2UyKSA9PiBuZXcgRXZlbnRTb3VyY2UyKHVyaSwgZXNPcHRpb25zKSkpXG4gICksIGxpc3RlbkZvcikucGlwZShcbiAgICByZWNvbm5lY3RPbkNvbm5lY3Rpb25GYWlsdXJlKCksXG4gICAgZmlsdGVyKChldmVudCkgPT4gbGlzdGVuRm9yLmluY2x1ZGVzKGV2ZW50LnR5cGUpKSxcbiAgICBtYXAoXG4gICAgICAoZXZlbnQpID0+ICh7XG4gICAgICAgIHR5cGU6IGV2ZW50LnR5cGUsXG4gICAgICAgIC4uLlwiZGF0YVwiIGluIGV2ZW50ID8gZXZlbnQuZGF0YSA6IHt9XG4gICAgICB9KVxuICAgIClcbiAgKTtcbn1cbmNvbnN0IHJlcXVpcmVkQXBpVmVyc2lvbiA9IFwiMjAyMS0wMy0yNVwiO1xuY2xhc3MgTGl2ZUNsaWVudCB7XG4gICNjbGllbnQ7XG4gIGNvbnN0cnVjdG9yKGNsaWVudCkge1xuICAgIHRoaXMuI2NsaWVudCA9IGNsaWVudDtcbiAgfVxuICAvKipcbiAgICogUmVxdWlyZXMgYGFwaVZlcnNpb25gIHRvIGJlIGAyMDIxLTAzLTI1YCBvciBsYXRlci5cbiAgICovXG4gIGV2ZW50cyh7XG4gICAgaW5jbHVkZURyYWZ0cyA9ICExLFxuICAgIHRhZzogX3RhZ1xuICB9ID0ge30pIHtcbiAgICBjb25zdCB7XG4gICAgICBwcm9qZWN0SWQsXG4gICAgICBhcGlWZXJzaW9uOiBfYXBpVmVyc2lvbixcbiAgICAgIHRva2VuLFxuICAgICAgd2l0aENyZWRlbnRpYWxzLFxuICAgICAgcmVxdWVzdFRhZ1ByZWZpeFxuICAgIH0gPSB0aGlzLiNjbGllbnQuY29uZmlnKCksIGFwaVZlcnNpb24gPSBfYXBpVmVyc2lvbi5yZXBsYWNlKC9edi8sIFwiXCIpO1xuICAgIGlmIChhcGlWZXJzaW9uICE9PSBcIlhcIiAmJiBhcGlWZXJzaW9uIDwgcmVxdWlyZWRBcGlWZXJzaW9uKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgVGhlIGxpdmUgZXZlbnRzIEFQSSByZXF1aXJlcyBBUEkgdmVyc2lvbiAke3JlcXVpcmVkQXBpVmVyc2lvbn0gb3IgbGF0ZXIuIFRoZSBjdXJyZW50IEFQSSB2ZXJzaW9uIGlzICR7YXBpVmVyc2lvbn0uIFBsZWFzZSB1cGRhdGUgeW91ciBBUEkgdmVyc2lvbiB0byB1c2UgdGhpcyBmZWF0dXJlLmBcbiAgICAgICk7XG4gICAgaWYgKGluY2x1ZGVEcmFmdHMgJiYgIXRva2VuICYmICF3aXRoQ3JlZGVudGlhbHMpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiVGhlIGxpdmUgZXZlbnRzIEFQSSByZXF1aXJlcyBhIHRva2VuIG9yIHdpdGhDcmVkZW50aWFscyB3aGVuICdpbmNsdWRlRHJhZnRzOiB0cnVlJy4gUGxlYXNlIHVwZGF0ZSB5b3VyIGNsaWVudCBjb25maWd1cmF0aW9uLiBUaGUgdG9rZW4gc2hvdWxkIGhhdmUgdGhlIGxvd2VzdCBwb3NzaWJsZSBhY2Nlc3Mgcm9sZS5cIlxuICAgICAgKTtcbiAgICBjb25zdCBwYXRoID0gX2dldERhdGFVcmwodGhpcy4jY2xpZW50LCBcImxpdmUvZXZlbnRzXCIpLCB1cmwgPSBuZXcgVVJMKHRoaXMuI2NsaWVudC5nZXRVcmwocGF0aCwgITEpKSwgdGFnID0gX3RhZyAmJiByZXF1ZXN0VGFnUHJlZml4ID8gW3JlcXVlc3RUYWdQcmVmaXgsIF90YWddLmpvaW4oXCIuXCIpIDogX3RhZztcbiAgICB0YWcgJiYgdXJsLnNlYXJjaFBhcmFtcy5zZXQoXCJ0YWdcIiwgdGFnKSwgaW5jbHVkZURyYWZ0cyAmJiB1cmwuc2VhcmNoUGFyYW1zLnNldChcImluY2x1ZGVEcmFmdHNcIiwgXCJ0cnVlXCIpO1xuICAgIGNvbnN0IGVzT3B0aW9ucyA9IHt9O1xuICAgIGluY2x1ZGVEcmFmdHMgJiYgdG9rZW4gJiYgKGVzT3B0aW9ucy5oZWFkZXJzID0ge1xuICAgICAgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke3Rva2VufWBcbiAgICB9KSwgaW5jbHVkZURyYWZ0cyAmJiB3aXRoQ3JlZGVudGlhbHMgJiYgKGVzT3B0aW9ucy53aXRoQ3JlZGVudGlhbHMgPSAhMCk7XG4gICAgY29uc3QgZXZlbnRzID0gY29ubmVjdEV2ZW50U291cmNlKCgpID0+IChcbiAgICAgIC8vIHVzZSBwb2x5ZmlsbCBpZiB0aGVyZSBpcyBubyBnbG9iYWwgRXZlbnRTb3VyY2Ugb3IgaWYgd2UgbmVlZCB0byBzZXQgaGVhZGVyc1xuICAgICAgKHR5cGVvZiBFdmVudFNvdXJjZSA+IFwidVwiIHx8IGVzT3B0aW9ucy5oZWFkZXJzID8gZXZlbnRTb3VyY2VQb2x5ZmlsbCA6IG9mKEV2ZW50U291cmNlKSkucGlwZShtYXAoKEV2ZW50U291cmNlMikgPT4gbmV3IEV2ZW50U291cmNlMih1cmwuaHJlZiwgZXNPcHRpb25zKSkpXG4gICAgKSwgW1xuICAgICAgXCJtZXNzYWdlXCIsXG4gICAgICBcInJlc3RhcnRcIixcbiAgICAgIFwid2VsY29tZVwiLFxuICAgICAgXCJyZWNvbm5lY3RcIlxuICAgIF0pLnBpcGUoXG4gICAgICByZWNvbm5lY3RPbkNvbm5lY3Rpb25GYWlsdXJlKCksXG4gICAgICBtYXAoKGV2ZW50KSA9PiB7XG4gICAgICAgIGlmIChldmVudC50eXBlID09PSBcIm1lc3NhZ2VcIikge1xuICAgICAgICAgIGNvbnN0IHsgZGF0YSwgLi4ucmVzdCB9ID0gZXZlbnQ7XG4gICAgICAgICAgcmV0dXJuIHsgLi4ucmVzdCwgdGFnczogZGF0YS50YWdzIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgICAgfSlcbiAgICApLCBjaGVja0NvcnMgPSBmZXRjaE9ic2VydmFibGUodXJsLCB7XG4gICAgICBtZXRob2Q6IFwiT1BUSU9OU1wiLFxuICAgICAgbW9kZTogXCJjb3JzXCIsXG4gICAgICBjcmVkZW50aWFsczogZXNPcHRpb25zLndpdGhDcmVkZW50aWFscyA/IFwiaW5jbHVkZVwiIDogXCJvbWl0XCIsXG4gICAgICBoZWFkZXJzOiBlc09wdGlvbnMuaGVhZGVyc1xuICAgIH0pLnBpcGUoXG4gICAgICBtZXJnZU1hcCgoKSA9PiBFTVBUWSksXG4gICAgICBjYXRjaEVycm9yKCgpID0+IHtcbiAgICAgICAgdGhyb3cgbmV3IENvcnNPcmlnaW5FcnJvcih7IHByb2plY3RJZCB9KTtcbiAgICAgIH0pXG4gICAgKTtcbiAgICByZXR1cm4gY29uY2F0KGNoZWNrQ29ycywgZXZlbnRzKTtcbiAgfVxufVxuZnVuY3Rpb24gZmV0Y2hPYnNlcnZhYmxlKHVybCwgaW5pdCkge1xuICByZXR1cm4gbmV3IE9ic2VydmFibGUoKG9ic2VydmVyKSA9PiB7XG4gICAgY29uc3QgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKSwgc2lnbmFsID0gY29udHJvbGxlci5zaWduYWw7XG4gICAgcmV0dXJuIGZldGNoKHVybCwgeyAuLi5pbml0LCBzaWduYWw6IGNvbnRyb2xsZXIuc2lnbmFsIH0pLnRoZW4oXG4gICAgICAocmVzcG9uc2UpID0+IHtcbiAgICAgICAgb2JzZXJ2ZXIubmV4dChyZXNwb25zZSksIG9ic2VydmVyLmNvbXBsZXRlKCk7XG4gICAgICB9LFxuICAgICAgKGVycikgPT4ge1xuICAgICAgICBzaWduYWwuYWJvcnRlZCB8fCBvYnNlcnZlci5lcnJvcihlcnIpO1xuICAgICAgfVxuICAgICksICgpID0+IGNvbnRyb2xsZXIuYWJvcnQoKTtcbiAgfSk7XG59XG5jbGFzcyBPYnNlcnZhYmxlRGF0YXNldHNDbGllbnQge1xuICAjY2xpZW50O1xuICAjaHR0cFJlcXVlc3Q7XG4gIGNvbnN0cnVjdG9yKGNsaWVudCwgaHR0cFJlcXVlc3QpIHtcbiAgICB0aGlzLiNjbGllbnQgPSBjbGllbnQsIHRoaXMuI2h0dHBSZXF1ZXN0ID0gaHR0cFJlcXVlc3Q7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBkYXRhc2V0IHdpdGggdGhlIGdpdmVuIG5hbWVcbiAgICpcbiAgICogQHBhcmFtIG5hbWUgLSBOYW1lIG9mIHRoZSBkYXRhc2V0IHRvIGNyZWF0ZVxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgZm9yIHRoZSBkYXRhc2V0XG4gICAqL1xuICBjcmVhdGUobmFtZTIsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gX21vZGlmeSh0aGlzLiNjbGllbnQsIHRoaXMuI2h0dHBSZXF1ZXN0LCBcIlBVVFwiLCBuYW1lMiwgb3B0aW9ucyk7XG4gIH1cbiAgLyoqXG4gICAqIEVkaXQgYSBkYXRhc2V0IHdpdGggdGhlIGdpdmVuIG5hbWVcbiAgICpcbiAgICogQHBhcmFtIG5hbWUgLSBOYW1lIG9mIHRoZSBkYXRhc2V0IHRvIGVkaXRcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBOZXcgb3B0aW9ucyBmb3IgdGhlIGRhdGFzZXRcbiAgICovXG4gIGVkaXQobmFtZTIsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gX21vZGlmeSh0aGlzLiNjbGllbnQsIHRoaXMuI2h0dHBSZXF1ZXN0LCBcIlBBVENIXCIsIG5hbWUyLCBvcHRpb25zKTtcbiAgfVxuICAvKipcbiAgICogRGVsZXRlIGEgZGF0YXNldCB3aXRoIHRoZSBnaXZlbiBuYW1lXG4gICAqXG4gICAqIEBwYXJhbSBuYW1lIC0gTmFtZSBvZiB0aGUgZGF0YXNldCB0byBkZWxldGVcbiAgICovXG4gIGRlbGV0ZShuYW1lMikge1xuICAgIHJldHVybiBfbW9kaWZ5KHRoaXMuI2NsaWVudCwgdGhpcy4jaHR0cFJlcXVlc3QsIFwiREVMRVRFXCIsIG5hbWUyKTtcbiAgfVxuICAvKipcbiAgICogRmV0Y2ggYSBsaXN0IG9mIGRhdGFzZXRzIGZvciB0aGUgY29uZmlndXJlZCBwcm9qZWN0XG4gICAqL1xuICBsaXN0KCkge1xuICAgIHJldHVybiBfcmVxdWVzdCh0aGlzLiNjbGllbnQsIHRoaXMuI2h0dHBSZXF1ZXN0LCB7XG4gICAgICB1cmk6IFwiL2RhdGFzZXRzXCIsXG4gICAgICB0YWc6IG51bGxcbiAgICB9KTtcbiAgfVxufVxuY2xhc3MgRGF0YXNldHNDbGllbnQge1xuICAjY2xpZW50O1xuICAjaHR0cFJlcXVlc3Q7XG4gIGNvbnN0cnVjdG9yKGNsaWVudCwgaHR0cFJlcXVlc3QpIHtcbiAgICB0aGlzLiNjbGllbnQgPSBjbGllbnQsIHRoaXMuI2h0dHBSZXF1ZXN0ID0gaHR0cFJlcXVlc3Q7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBkYXRhc2V0IHdpdGggdGhlIGdpdmVuIG5hbWVcbiAgICpcbiAgICogQHBhcmFtIG5hbWUgLSBOYW1lIG9mIHRoZSBkYXRhc2V0IHRvIGNyZWF0ZVxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgZm9yIHRoZSBkYXRhc2V0XG4gICAqL1xuICBjcmVhdGUobmFtZTIsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbGFzdFZhbHVlRnJvbShcbiAgICAgIF9tb2RpZnkodGhpcy4jY2xpZW50LCB0aGlzLiNodHRwUmVxdWVzdCwgXCJQVVRcIiwgbmFtZTIsIG9wdGlvbnMpXG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogRWRpdCBhIGRhdGFzZXQgd2l0aCB0aGUgZ2l2ZW4gbmFtZVxuICAgKlxuICAgKiBAcGFyYW0gbmFtZSAtIE5hbWUgb2YgdGhlIGRhdGFzZXQgdG8gZWRpdFxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE5ldyBvcHRpb25zIGZvciB0aGUgZGF0YXNldFxuICAgKi9cbiAgZWRpdChuYW1lMiwgb3B0aW9ucykge1xuICAgIHJldHVybiBsYXN0VmFsdWVGcm9tKFxuICAgICAgX21vZGlmeSh0aGlzLiNjbGllbnQsIHRoaXMuI2h0dHBSZXF1ZXN0LCBcIlBBVENIXCIsIG5hbWUyLCBvcHRpb25zKVxuICAgICk7XG4gIH1cbiAgLyoqXG4gICAqIERlbGV0ZSBhIGRhdGFzZXQgd2l0aCB0aGUgZ2l2ZW4gbmFtZVxuICAgKlxuICAgKiBAcGFyYW0gbmFtZSAtIE5hbWUgb2YgdGhlIGRhdGFzZXQgdG8gZGVsZXRlXG4gICAqL1xuICBkZWxldGUobmFtZTIpIHtcbiAgICByZXR1cm4gbGFzdFZhbHVlRnJvbShfbW9kaWZ5KHRoaXMuI2NsaWVudCwgdGhpcy4jaHR0cFJlcXVlc3QsIFwiREVMRVRFXCIsIG5hbWUyKSk7XG4gIH1cbiAgLyoqXG4gICAqIEZldGNoIGEgbGlzdCBvZiBkYXRhc2V0cyBmb3IgdGhlIGNvbmZpZ3VyZWQgcHJvamVjdFxuICAgKi9cbiAgbGlzdCgpIHtcbiAgICByZXR1cm4gbGFzdFZhbHVlRnJvbShcbiAgICAgIF9yZXF1ZXN0KHRoaXMuI2NsaWVudCwgdGhpcy4jaHR0cFJlcXVlc3QsIHsgdXJpOiBcIi9kYXRhc2V0c1wiLCB0YWc6IG51bGwgfSlcbiAgICApO1xuICB9XG59XG5mdW5jdGlvbiBfbW9kaWZ5KGNsaWVudCwgaHR0cFJlcXVlc3QsIG1ldGhvZCwgbmFtZTIsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIGRhdGFzZXQobmFtZTIpLCBfcmVxdWVzdChjbGllbnQsIGh0dHBSZXF1ZXN0LCB7XG4gICAgbWV0aG9kLFxuICAgIHVyaTogYC9kYXRhc2V0cy8ke25hbWUyfWAsXG4gICAgYm9keTogb3B0aW9ucyxcbiAgICB0YWc6IG51bGxcbiAgfSk7XG59XG5jbGFzcyBPYnNlcnZhYmxlUHJvamVjdHNDbGllbnQge1xuICAjY2xpZW50O1xuICAjaHR0cFJlcXVlc3Q7XG4gIGNvbnN0cnVjdG9yKGNsaWVudCwgaHR0cFJlcXVlc3QpIHtcbiAgICB0aGlzLiNjbGllbnQgPSBjbGllbnQsIHRoaXMuI2h0dHBSZXF1ZXN0ID0gaHR0cFJlcXVlc3Q7XG4gIH1cbiAgbGlzdChvcHRpb25zKSB7XG4gICAgY29uc3QgdXJpID0gb3B0aW9ucz8uaW5jbHVkZU1lbWJlcnMgPT09ICExID8gXCIvcHJvamVjdHM/aW5jbHVkZU1lbWJlcnM9ZmFsc2VcIiA6IFwiL3Byb2plY3RzXCI7XG4gICAgcmV0dXJuIF9yZXF1ZXN0KHRoaXMuI2NsaWVudCwgdGhpcy4jaHR0cFJlcXVlc3QsIHsgdXJpIH0pO1xuICB9XG4gIC8qKlxuICAgKiBGZXRjaCBhIHByb2plY3QgYnkgcHJvamVjdCBJRFxuICAgKlxuICAgKiBAcGFyYW0gcHJvamVjdElkIC0gSUQgb2YgdGhlIHByb2plY3QgdG8gZmV0Y2hcbiAgICovXG4gIGdldEJ5SWQocHJvamVjdElkKSB7XG4gICAgcmV0dXJuIF9yZXF1ZXN0KHRoaXMuI2NsaWVudCwgdGhpcy4jaHR0cFJlcXVlc3QsIHsgdXJpOiBgL3Byb2plY3RzLyR7cHJvamVjdElkfWAgfSk7XG4gIH1cbn1cbmNsYXNzIFByb2plY3RzQ2xpZW50IHtcbiAgI2NsaWVudDtcbiAgI2h0dHBSZXF1ZXN0O1xuICBjb25zdHJ1Y3RvcihjbGllbnQsIGh0dHBSZXF1ZXN0KSB7XG4gICAgdGhpcy4jY2xpZW50ID0gY2xpZW50LCB0aGlzLiNodHRwUmVxdWVzdCA9IGh0dHBSZXF1ZXN0O1xuICB9XG4gIGxpc3Qob3B0aW9ucykge1xuICAgIGNvbnN0IHVyaSA9IG9wdGlvbnM/LmluY2x1ZGVNZW1iZXJzID09PSAhMSA/IFwiL3Byb2plY3RzP2luY2x1ZGVNZW1iZXJzPWZhbHNlXCIgOiBcIi9wcm9qZWN0c1wiO1xuICAgIHJldHVybiBsYXN0VmFsdWVGcm9tKF9yZXF1ZXN0KHRoaXMuI2NsaWVudCwgdGhpcy4jaHR0cFJlcXVlc3QsIHsgdXJpIH0pKTtcbiAgfVxuICAvKipcbiAgICogRmV0Y2ggYSBwcm9qZWN0IGJ5IHByb2plY3QgSURcbiAgICpcbiAgICogQHBhcmFtIHByb2plY3RJZCAtIElEIG9mIHRoZSBwcm9qZWN0IHRvIGZldGNoXG4gICAqL1xuICBnZXRCeUlkKHByb2plY3RJZCkge1xuICAgIHJldHVybiBsYXN0VmFsdWVGcm9tKFxuICAgICAgX3JlcXVlc3QodGhpcy4jY2xpZW50LCB0aGlzLiNodHRwUmVxdWVzdCwgeyB1cmk6IGAvcHJvamVjdHMvJHtwcm9qZWN0SWR9YCB9KVxuICAgICk7XG4gIH1cbn1cbmNsYXNzIE9ic2VydmFibGVVc2Vyc0NsaWVudCB7XG4gICNjbGllbnQ7XG4gICNodHRwUmVxdWVzdDtcbiAgY29uc3RydWN0b3IoY2xpZW50LCBodHRwUmVxdWVzdCkge1xuICAgIHRoaXMuI2NsaWVudCA9IGNsaWVudCwgdGhpcy4jaHR0cFJlcXVlc3QgPSBodHRwUmVxdWVzdDtcbiAgfVxuICAvKipcbiAgICogRmV0Y2ggYSB1c2VyIGJ5IHVzZXIgSURcbiAgICpcbiAgICogQHBhcmFtIGlkIC0gVXNlciBJRCBvZiB0aGUgdXNlciB0byBmZXRjaC4gSWYgYG1lYCBpcyBwcm92aWRlZCwgYSBtaW5pbWFsIHJlc3BvbnNlIGluY2x1ZGluZyB0aGUgdXNlcnMgcm9sZSBpcyByZXR1cm5lZC5cbiAgICovXG4gIGdldEJ5SWQoaWQpIHtcbiAgICByZXR1cm4gX3JlcXVlc3QoXG4gICAgICB0aGlzLiNjbGllbnQsXG4gICAgICB0aGlzLiNodHRwUmVxdWVzdCxcbiAgICAgIHsgdXJpOiBgL3VzZXJzLyR7aWR9YCB9XG4gICAgKTtcbiAgfVxufVxuY2xhc3MgVXNlcnNDbGllbnQge1xuICAjY2xpZW50O1xuICAjaHR0cFJlcXVlc3Q7XG4gIGNvbnN0cnVjdG9yKGNsaWVudCwgaHR0cFJlcXVlc3QpIHtcbiAgICB0aGlzLiNjbGllbnQgPSBjbGllbnQsIHRoaXMuI2h0dHBSZXF1ZXN0ID0gaHR0cFJlcXVlc3Q7XG4gIH1cbiAgLyoqXG4gICAqIEZldGNoIGEgdXNlciBieSB1c2VyIElEXG4gICAqXG4gICAqIEBwYXJhbSBpZCAtIFVzZXIgSUQgb2YgdGhlIHVzZXIgdG8gZmV0Y2guIElmIGBtZWAgaXMgcHJvdmlkZWQsIGEgbWluaW1hbCByZXNwb25zZSBpbmNsdWRpbmcgdGhlIHVzZXJzIHJvbGUgaXMgcmV0dXJuZWQuXG4gICAqL1xuICBnZXRCeUlkKGlkKSB7XG4gICAgcmV0dXJuIGxhc3RWYWx1ZUZyb20oXG4gICAgICBfcmVxdWVzdCh0aGlzLiNjbGllbnQsIHRoaXMuI2h0dHBSZXF1ZXN0LCB7XG4gICAgICAgIHVyaTogYC91c2Vycy8ke2lkfWBcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxufVxuY2xhc3MgT2JzZXJ2YWJsZVNhbml0eUNsaWVudCB7XG4gIGFzc2V0cztcbiAgZGF0YXNldHM7XG4gIGxpdmU7XG4gIHByb2plY3RzO1xuICB1c2VycztcbiAgLyoqXG4gICAqIFByaXZhdGUgcHJvcGVydGllc1xuICAgKi9cbiAgI2NsaWVudENvbmZpZztcbiAgI2h0dHBSZXF1ZXN0O1xuICAvKipcbiAgICogSW5zdGFuY2UgcHJvcGVydGllc1xuICAgKi9cbiAgbGlzdGVuID0gX2xpc3RlbjtcbiAgY29uc3RydWN0b3IoaHR0cFJlcXVlc3QsIGNvbmZpZyA9IGRlZmF1bHRDb25maWcpIHtcbiAgICB0aGlzLmNvbmZpZyhjb25maWcpLCB0aGlzLiNodHRwUmVxdWVzdCA9IGh0dHBSZXF1ZXN0LCB0aGlzLmFzc2V0cyA9IG5ldyBPYnNlcnZhYmxlQXNzZXRzQ2xpZW50KHRoaXMsIHRoaXMuI2h0dHBSZXF1ZXN0KSwgdGhpcy5kYXRhc2V0cyA9IG5ldyBPYnNlcnZhYmxlRGF0YXNldHNDbGllbnQodGhpcywgdGhpcy4jaHR0cFJlcXVlc3QpLCB0aGlzLmxpdmUgPSBuZXcgTGl2ZUNsaWVudCh0aGlzKSwgdGhpcy5wcm9qZWN0cyA9IG5ldyBPYnNlcnZhYmxlUHJvamVjdHNDbGllbnQodGhpcywgdGhpcy4jaHR0cFJlcXVlc3QpLCB0aGlzLnVzZXJzID0gbmV3IE9ic2VydmFibGVVc2Vyc0NsaWVudCh0aGlzLCB0aGlzLiNodHRwUmVxdWVzdCk7XG4gIH1cbiAgLyoqXG4gICAqIENsb25lIHRoZSBjbGllbnQgLSByZXR1cm5zIGEgbmV3IGluc3RhbmNlXG4gICAqL1xuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IE9ic2VydmFibGVTYW5pdHlDbGllbnQodGhpcy4jaHR0cFJlcXVlc3QsIHRoaXMuY29uZmlnKCkpO1xuICB9XG4gIGNvbmZpZyhuZXdDb25maWcpIHtcbiAgICBpZiAobmV3Q29uZmlnID09PSB2b2lkIDApXG4gICAgICByZXR1cm4geyAuLi50aGlzLiNjbGllbnRDb25maWcgfTtcbiAgICBpZiAodGhpcy4jY2xpZW50Q29uZmlnICYmIHRoaXMuI2NsaWVudENvbmZpZy5hbGxvd1JlY29uZmlndXJlID09PSAhMSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJFeGlzdGluZyBjbGllbnQgaW5zdGFuY2UgY2Fubm90IGJlIHJlY29uZmlndXJlZCAtIHVzZSBgd2l0aENvbmZpZyhuZXdDb25maWcpYCB0byByZXR1cm4gYSBuZXcgY2xpZW50XCJcbiAgICAgICk7XG4gICAgcmV0dXJuIHRoaXMuI2NsaWVudENvbmZpZyA9IGluaXRDb25maWcobmV3Q29uZmlnLCB0aGlzLiNjbGllbnRDb25maWcgfHwge30pLCB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBDbG9uZSB0aGUgY2xpZW50IHdpdGggYSBuZXcgKHBhcnRpYWwpIGNvbmZpZ3VyYXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSBuZXdDb25maWcgLSBOZXcgY2xpZW50IGNvbmZpZ3VyYXRpb24gcHJvcGVydGllcywgc2hhbGxvd2x5IG1lcmdlZCB3aXRoIGV4aXN0aW5nIGNvbmZpZ3VyYXRpb25cbiAgICovXG4gIHdpdGhDb25maWcobmV3Q29uZmlnKSB7XG4gICAgY29uc3QgdGhpc0NvbmZpZyA9IHRoaXMuY29uZmlnKCk7XG4gICAgcmV0dXJuIG5ldyBPYnNlcnZhYmxlU2FuaXR5Q2xpZW50KHRoaXMuI2h0dHBSZXF1ZXN0LCB7XG4gICAgICAuLi50aGlzQ29uZmlnLFxuICAgICAgLi4ubmV3Q29uZmlnLFxuICAgICAgc3RlZ2E6IHtcbiAgICAgICAgLi4udGhpc0NvbmZpZy5zdGVnYSB8fCB7fSxcbiAgICAgICAgLi4udHlwZW9mIG5ld0NvbmZpZz8uc3RlZ2EgPT0gXCJib29sZWFuXCIgPyB7IGVuYWJsZWQ6IG5ld0NvbmZpZy5zdGVnYSB9IDogbmV3Q29uZmlnPy5zdGVnYSB8fCB7fVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGZldGNoKHF1ZXJ5LCBwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gX2ZldGNoKFxuICAgICAgdGhpcyxcbiAgICAgIHRoaXMuI2h0dHBSZXF1ZXN0LFxuICAgICAgdGhpcy4jY2xpZW50Q29uZmlnLnN0ZWdhLFxuICAgICAgcXVlcnksXG4gICAgICBwYXJhbXMsXG4gICAgICBvcHRpb25zXG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogRmV0Y2ggYSBzaW5nbGUgZG9jdW1lbnQgd2l0aCB0aGUgZ2l2ZW4gSUQuXG4gICAqXG4gICAqIEBwYXJhbSBpZCAtIERvY3VtZW50IElEIHRvIGZldGNoXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gUmVxdWVzdCBvcHRpb25zXG4gICAqL1xuICBnZXREb2N1bWVudChpZCwgb3B0aW9ucykge1xuICAgIHJldHVybiBfZ2V0RG9jdW1lbnQodGhpcywgdGhpcy4jaHR0cFJlcXVlc3QsIGlkLCBvcHRpb25zKTtcbiAgfVxuICAvKipcbiAgICogRmV0Y2ggbXVsdGlwbGUgZG9jdW1lbnRzIGluIG9uZSByZXF1ZXN0LlxuICAgKiBTaG91bGQgYmUgdXNlZCBzcGFyaW5nbHkgLSBwZXJmb3JtaW5nIGEgcXVlcnkgaXMgdXN1YWxseSBhIGJldHRlciBvcHRpb24uXG4gICAqIFRoZSBvcmRlci9wb3NpdGlvbiBvZiBkb2N1bWVudHMgaXMgcHJlc2VydmVkIGJhc2VkIG9uIHRoZSBvcmlnaW5hbCBhcnJheSBvZiBJRHMuXG4gICAqIElmIGFueSBvZiB0aGUgZG9jdW1lbnRzIGFyZSBtaXNzaW5nLCB0aGV5IHdpbGwgYmUgcmVwbGFjZWQgYnkgYSBgbnVsbGAgZW50cnkgaW4gdGhlIHJldHVybmVkIGFycmF5XG4gICAqXG4gICAqIEBwYXJhbSBpZHMgLSBEb2N1bWVudCBJRHMgdG8gZmV0Y2hcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBSZXF1ZXN0IG9wdGlvbnNcbiAgICovXG4gIGdldERvY3VtZW50cyhpZHMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gX2dldERvY3VtZW50cyh0aGlzLCB0aGlzLiNodHRwUmVxdWVzdCwgaWRzLCBvcHRpb25zKTtcbiAgfVxuICBjcmVhdGUoZG9jdW1lbnQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gX2NyZWF0ZSh0aGlzLCB0aGlzLiNodHRwUmVxdWVzdCwgZG9jdW1lbnQsIFwiY3JlYXRlXCIsIG9wdGlvbnMpO1xuICB9XG4gIGNyZWF0ZUlmTm90RXhpc3RzKGRvY3VtZW50LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIF9jcmVhdGVJZk5vdEV4aXN0cyh0aGlzLCB0aGlzLiNodHRwUmVxdWVzdCwgZG9jdW1lbnQsIG9wdGlvbnMpO1xuICB9XG4gIGNyZWF0ZU9yUmVwbGFjZShkb2N1bWVudCwgb3B0aW9ucykge1xuICAgIHJldHVybiBfY3JlYXRlT3JSZXBsYWNlKHRoaXMsIHRoaXMuI2h0dHBSZXF1ZXN0LCBkb2N1bWVudCwgb3B0aW9ucyk7XG4gIH1cbiAgZGVsZXRlKHNlbGVjdGlvbiwgb3B0aW9ucykge1xuICAgIHJldHVybiBfZGVsZXRlKHRoaXMsIHRoaXMuI2h0dHBSZXF1ZXN0LCBzZWxlY3Rpb24sIG9wdGlvbnMpO1xuICB9XG4gIG11dGF0ZShvcGVyYXRpb25zLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIF9tdXRhdGUodGhpcywgdGhpcy4jaHR0cFJlcXVlc3QsIG9wZXJhdGlvbnMsIG9wdGlvbnMpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgYnVpbGRhYmxlIHBhdGNoIG9mIG9wZXJhdGlvbnMgdG8gcGVyZm9ybVxuICAgKlxuICAgKiBAcGFyYW0gc2VsZWN0aW9uIC0gRG9jdW1lbnQgSUQsIGFuIGFycmF5IG9mIGRvY3VtZW50IElEcywgb3IgYW4gb2JqZWN0IHdpdGggYHF1ZXJ5YCBhbmQgb3B0aW9uYWwgYHBhcmFtc2AsIGRlZmluaW5nIHdoaWNoIGRvY3VtZW50KHMpIHRvIHBhdGNoXG4gICAqIEBwYXJhbSBvcGVyYXRpb25zIC0gT3B0aW9uYWwgb2JqZWN0IG9mIHBhdGNoIG9wZXJhdGlvbnMgdG8gaW5pdGlhbGl6ZSB0aGUgcGF0Y2ggaW5zdGFuY2Ugd2l0aFxuICAgKiBAcmV0dXJucyBQYXRjaCBpbnN0YW5jZSAtIGNhbGwgYC5jb21taXQoKWAgdG8gcGVyZm9ybSB0aGUgb3BlcmF0aW9ucyBkZWZpbmVkXG4gICAqL1xuICBwYXRjaChzZWxlY3Rpb24sIG9wZXJhdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IE9ic2VydmFibGVQYXRjaChzZWxlY3Rpb24sIG9wZXJhdGlvbnMsIHRoaXMpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgdHJhbnNhY3Rpb24gb2YgbXV0YXRpb25zXG4gICAqXG4gICAqIEBwYXJhbSBvcGVyYXRpb25zIC0gT3B0aW9uYWwgYXJyYXkgb2YgbXV0YXRpb24gb3BlcmF0aW9ucyB0byBpbml0aWFsaXplIHRoZSB0cmFuc2FjdGlvbiBpbnN0YW5jZSB3aXRoXG4gICAqL1xuICB0cmFuc2FjdGlvbihvcGVyYXRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBPYnNlcnZhYmxlVHJhbnNhY3Rpb24ob3BlcmF0aW9ucywgdGhpcyk7XG4gIH1cbiAgLyoqXG4gICAqIFBlcmZvcm0gYWN0aW9uIG9wZXJhdGlvbnMgYWdhaW5zdCB0aGUgY29uZmlndXJlZCBkYXRhc2V0XG4gICAqXG4gICAqIEBwYXJhbSBvcGVyYXRpb25zIC0gQWN0aW9uIG9wZXJhdGlvbihzKSB0byBleGVjdXRlXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gQWN0aW9uIG9wdGlvbnNcbiAgICovXG4gIGFjdGlvbihvcGVyYXRpb25zLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIF9hY3Rpb24odGhpcywgdGhpcy4jaHR0cFJlcXVlc3QsIG9wZXJhdGlvbnMsIG9wdGlvbnMpO1xuICB9XG4gIC8qKlxuICAgKiBQZXJmb3JtIGFuIEhUVFAgcmVxdWVzdCBhZ2FpbnN0IHRoZSBTYW5pdHkgQVBJXG4gICAqXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gUmVxdWVzdCBvcHRpb25zXG4gICAqL1xuICByZXF1ZXN0KG9wdGlvbnMpIHtcbiAgICByZXR1cm4gX3JlcXVlc3QodGhpcywgdGhpcy4jaHR0cFJlcXVlc3QsIG9wdGlvbnMpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgYSBTYW5pdHkgQVBJIFVSTCBmb3IgdGhlIFVSSSBwcm92aWRlZFxuICAgKlxuICAgKiBAcGFyYW0gdXJpIC0gVVJJL3BhdGggdG8gYnVpbGQgVVJMIGZvclxuICAgKiBAcGFyYW0gY2FuVXNlQ2RuIC0gV2hldGhlciBvciBub3QgdG8gYWxsb3cgdXNpbmcgdGhlIEFQSSBDRE4gZm9yIHRoaXMgcm91dGVcbiAgICovXG4gIGdldFVybCh1cmksIGNhblVzZUNkbikge1xuICAgIHJldHVybiBfZ2V0VXJsKHRoaXMsIHVyaSwgY2FuVXNlQ2RuKTtcbiAgfVxuICAvKipcbiAgICogR2V0IGEgU2FuaXR5IEFQSSBVUkwgZm9yIHRoZSBkYXRhIG9wZXJhdGlvbiBhbmQgcGF0aCBwcm92aWRlZFxuICAgKlxuICAgKiBAcGFyYW0gb3BlcmF0aW9uIC0gRGF0YSBvcGVyYXRpb24gKGVnIGBxdWVyeWAsIGBtdXRhdGVgLCBgbGlzdGVuYCBvciBzaW1pbGFyKVxuICAgKiBAcGFyYW0gcGF0aCAtIFBhdGggdG8gYXBwZW5kIGFmdGVyIHRoZSBvcGVyYXRpb25cbiAgICovXG4gIGdldERhdGFVcmwob3BlcmF0aW9uLCBwYXRoKSB7XG4gICAgcmV0dXJuIF9nZXREYXRhVXJsKHRoaXMsIG9wZXJhdGlvbiwgcGF0aCk7XG4gIH1cbn1cbmNsYXNzIFNhbml0eUNsaWVudCB7XG4gIGFzc2V0cztcbiAgZGF0YXNldHM7XG4gIGxpdmU7XG4gIHByb2plY3RzO1xuICB1c2VycztcbiAgLyoqXG4gICAqIE9ic2VydmFibGUgdmVyc2lvbiBvZiB0aGUgU2FuaXR5IGNsaWVudCwgd2l0aCB0aGUgc2FtZSBjb25maWd1cmF0aW9uIGFzIHRoZSBwcm9taXNlLWJhc2VkIG9uZVxuICAgKi9cbiAgb2JzZXJ2YWJsZTtcbiAgLyoqXG4gICAqIFByaXZhdGUgcHJvcGVydGllc1xuICAgKi9cbiAgI2NsaWVudENvbmZpZztcbiAgI2h0dHBSZXF1ZXN0O1xuICAvKipcbiAgICogSW5zdGFuY2UgcHJvcGVydGllc1xuICAgKi9cbiAgbGlzdGVuID0gX2xpc3RlbjtcbiAgY29uc3RydWN0b3IoaHR0cFJlcXVlc3QsIGNvbmZpZyA9IGRlZmF1bHRDb25maWcpIHtcbiAgICB0aGlzLmNvbmZpZyhjb25maWcpLCB0aGlzLiNodHRwUmVxdWVzdCA9IGh0dHBSZXF1ZXN0LCB0aGlzLmFzc2V0cyA9IG5ldyBBc3NldHNDbGllbnQodGhpcywgdGhpcy4jaHR0cFJlcXVlc3QpLCB0aGlzLmRhdGFzZXRzID0gbmV3IERhdGFzZXRzQ2xpZW50KHRoaXMsIHRoaXMuI2h0dHBSZXF1ZXN0KSwgdGhpcy5saXZlID0gbmV3IExpdmVDbGllbnQodGhpcyksIHRoaXMucHJvamVjdHMgPSBuZXcgUHJvamVjdHNDbGllbnQodGhpcywgdGhpcy4jaHR0cFJlcXVlc3QpLCB0aGlzLnVzZXJzID0gbmV3IFVzZXJzQ2xpZW50KHRoaXMsIHRoaXMuI2h0dHBSZXF1ZXN0KSwgdGhpcy5vYnNlcnZhYmxlID0gbmV3IE9ic2VydmFibGVTYW5pdHlDbGllbnQoaHR0cFJlcXVlc3QsIGNvbmZpZyk7XG4gIH1cbiAgLyoqXG4gICAqIENsb25lIHRoZSBjbGllbnQgLSByZXR1cm5zIGEgbmV3IGluc3RhbmNlXG4gICAqL1xuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IFNhbml0eUNsaWVudCh0aGlzLiNodHRwUmVxdWVzdCwgdGhpcy5jb25maWcoKSk7XG4gIH1cbiAgY29uZmlnKG5ld0NvbmZpZykge1xuICAgIGlmIChuZXdDb25maWcgPT09IHZvaWQgMClcbiAgICAgIHJldHVybiB7IC4uLnRoaXMuI2NsaWVudENvbmZpZyB9O1xuICAgIGlmICh0aGlzLiNjbGllbnRDb25maWcgJiYgdGhpcy4jY2xpZW50Q29uZmlnLmFsbG93UmVjb25maWd1cmUgPT09ICExKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIkV4aXN0aW5nIGNsaWVudCBpbnN0YW5jZSBjYW5ub3QgYmUgcmVjb25maWd1cmVkIC0gdXNlIGB3aXRoQ29uZmlnKG5ld0NvbmZpZylgIHRvIHJldHVybiBhIG5ldyBjbGllbnRcIlxuICAgICAgKTtcbiAgICByZXR1cm4gdGhpcy5vYnNlcnZhYmxlICYmIHRoaXMub2JzZXJ2YWJsZS5jb25maWcobmV3Q29uZmlnKSwgdGhpcy4jY2xpZW50Q29uZmlnID0gaW5pdENvbmZpZyhuZXdDb25maWcsIHRoaXMuI2NsaWVudENvbmZpZyB8fCB7fSksIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIENsb25lIHRoZSBjbGllbnQgd2l0aCBhIG5ldyAocGFydGlhbCkgY29uZmlndXJhdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIG5ld0NvbmZpZyAtIE5ldyBjbGllbnQgY29uZmlndXJhdGlvbiBwcm9wZXJ0aWVzLCBzaGFsbG93bHkgbWVyZ2VkIHdpdGggZXhpc3RpbmcgY29uZmlndXJhdGlvblxuICAgKi9cbiAgd2l0aENvbmZpZyhuZXdDb25maWcpIHtcbiAgICBjb25zdCB0aGlzQ29uZmlnID0gdGhpcy5jb25maWcoKTtcbiAgICByZXR1cm4gbmV3IFNhbml0eUNsaWVudCh0aGlzLiNodHRwUmVxdWVzdCwge1xuICAgICAgLi4udGhpc0NvbmZpZyxcbiAgICAgIC4uLm5ld0NvbmZpZyxcbiAgICAgIHN0ZWdhOiB7XG4gICAgICAgIC4uLnRoaXNDb25maWcuc3RlZ2EgfHwge30sXG4gICAgICAgIC4uLnR5cGVvZiBuZXdDb25maWc/LnN0ZWdhID09IFwiYm9vbGVhblwiID8geyBlbmFibGVkOiBuZXdDb25maWcuc3RlZ2EgfSA6IG5ld0NvbmZpZz8uc3RlZ2EgfHwge31cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBmZXRjaChxdWVyeSwgcGFyYW1zLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGxhc3RWYWx1ZUZyb20oXG4gICAgICBfZmV0Y2goXG4gICAgICAgIHRoaXMsXG4gICAgICAgIHRoaXMuI2h0dHBSZXF1ZXN0LFxuICAgICAgICB0aGlzLiNjbGllbnRDb25maWcuc3RlZ2EsXG4gICAgICAgIHF1ZXJ5LFxuICAgICAgICBwYXJhbXMsXG4gICAgICAgIG9wdGlvbnNcbiAgICAgIClcbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBGZXRjaCBhIHNpbmdsZSBkb2N1bWVudCB3aXRoIHRoZSBnaXZlbiBJRC5cbiAgICpcbiAgICogQHBhcmFtIGlkIC0gRG9jdW1lbnQgSUQgdG8gZmV0Y2hcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBSZXF1ZXN0IG9wdGlvbnNcbiAgICovXG4gIGdldERvY3VtZW50KGlkLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGxhc3RWYWx1ZUZyb20oX2dldERvY3VtZW50KHRoaXMsIHRoaXMuI2h0dHBSZXF1ZXN0LCBpZCwgb3B0aW9ucykpO1xuICB9XG4gIC8qKlxuICAgKiBGZXRjaCBtdWx0aXBsZSBkb2N1bWVudHMgaW4gb25lIHJlcXVlc3QuXG4gICAqIFNob3VsZCBiZSB1c2VkIHNwYXJpbmdseSAtIHBlcmZvcm1pbmcgYSBxdWVyeSBpcyB1c3VhbGx5IGEgYmV0dGVyIG9wdGlvbi5cbiAgICogVGhlIG9yZGVyL3Bvc2l0aW9uIG9mIGRvY3VtZW50cyBpcyBwcmVzZXJ2ZWQgYmFzZWQgb24gdGhlIG9yaWdpbmFsIGFycmF5IG9mIElEcy5cbiAgICogSWYgYW55IG9mIHRoZSBkb2N1bWVudHMgYXJlIG1pc3NpbmcsIHRoZXkgd2lsbCBiZSByZXBsYWNlZCBieSBhIGBudWxsYCBlbnRyeSBpbiB0aGUgcmV0dXJuZWQgYXJyYXlcbiAgICpcbiAgICogQHBhcmFtIGlkcyAtIERvY3VtZW50IElEcyB0byBmZXRjaFxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIFJlcXVlc3Qgb3B0aW9uc1xuICAgKi9cbiAgZ2V0RG9jdW1lbnRzKGlkcywgb3B0aW9ucykge1xuICAgIHJldHVybiBsYXN0VmFsdWVGcm9tKF9nZXREb2N1bWVudHModGhpcywgdGhpcy4jaHR0cFJlcXVlc3QsIGlkcywgb3B0aW9ucykpO1xuICB9XG4gIGNyZWF0ZShkb2N1bWVudCwgb3B0aW9ucykge1xuICAgIHJldHVybiBsYXN0VmFsdWVGcm9tKFxuICAgICAgX2NyZWF0ZSh0aGlzLCB0aGlzLiNodHRwUmVxdWVzdCwgZG9jdW1lbnQsIFwiY3JlYXRlXCIsIG9wdGlvbnMpXG4gICAgKTtcbiAgfVxuICBjcmVhdGVJZk5vdEV4aXN0cyhkb2N1bWVudCwgb3B0aW9ucykge1xuICAgIHJldHVybiBsYXN0VmFsdWVGcm9tKFxuICAgICAgX2NyZWF0ZUlmTm90RXhpc3RzKHRoaXMsIHRoaXMuI2h0dHBSZXF1ZXN0LCBkb2N1bWVudCwgb3B0aW9ucylcbiAgICApO1xuICB9XG4gIGNyZWF0ZU9yUmVwbGFjZShkb2N1bWVudCwgb3B0aW9ucykge1xuICAgIHJldHVybiBsYXN0VmFsdWVGcm9tKFxuICAgICAgX2NyZWF0ZU9yUmVwbGFjZSh0aGlzLCB0aGlzLiNodHRwUmVxdWVzdCwgZG9jdW1lbnQsIG9wdGlvbnMpXG4gICAgKTtcbiAgfVxuICBkZWxldGUoc2VsZWN0aW9uLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGxhc3RWYWx1ZUZyb20oX2RlbGV0ZSh0aGlzLCB0aGlzLiNodHRwUmVxdWVzdCwgc2VsZWN0aW9uLCBvcHRpb25zKSk7XG4gIH1cbiAgbXV0YXRlKG9wZXJhdGlvbnMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbGFzdFZhbHVlRnJvbShfbXV0YXRlKHRoaXMsIHRoaXMuI2h0dHBSZXF1ZXN0LCBvcGVyYXRpb25zLCBvcHRpb25zKSk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBidWlsZGFibGUgcGF0Y2ggb2Ygb3BlcmF0aW9ucyB0byBwZXJmb3JtXG4gICAqXG4gICAqIEBwYXJhbSBzZWxlY3Rpb24gLSBEb2N1bWVudCBJRCwgYW4gYXJyYXkgb2YgZG9jdW1lbnQgSURzLCBvciBhbiBvYmplY3Qgd2l0aCBgcXVlcnlgIGFuZCBvcHRpb25hbCBgcGFyYW1zYCwgZGVmaW5pbmcgd2hpY2ggZG9jdW1lbnQocykgdG8gcGF0Y2hcbiAgICogQHBhcmFtIG9wZXJhdGlvbnMgLSBPcHRpb25hbCBvYmplY3Qgb2YgcGF0Y2ggb3BlcmF0aW9ucyB0byBpbml0aWFsaXplIHRoZSBwYXRjaCBpbnN0YW5jZSB3aXRoXG4gICAqIEByZXR1cm5zIFBhdGNoIGluc3RhbmNlIC0gY2FsbCBgLmNvbW1pdCgpYCB0byBwZXJmb3JtIHRoZSBvcGVyYXRpb25zIGRlZmluZWRcbiAgICovXG4gIHBhdGNoKGRvY3VtZW50SWQsIG9wZXJhdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFBhdGNoKGRvY3VtZW50SWQsIG9wZXJhdGlvbnMsIHRoaXMpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgdHJhbnNhY3Rpb24gb2YgbXV0YXRpb25zXG4gICAqXG4gICAqIEBwYXJhbSBvcGVyYXRpb25zIC0gT3B0aW9uYWwgYXJyYXkgb2YgbXV0YXRpb24gb3BlcmF0aW9ucyB0byBpbml0aWFsaXplIHRoZSB0cmFuc2FjdGlvbiBpbnN0YW5jZSB3aXRoXG4gICAqL1xuICB0cmFuc2FjdGlvbihvcGVyYXRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbihvcGVyYXRpb25zLCB0aGlzKTtcbiAgfVxuICAvKipcbiAgICogUGVyZm9ybSBhY3Rpb24gb3BlcmF0aW9ucyBhZ2FpbnN0IHRoZSBjb25maWd1cmVkIGRhdGFzZXRcbiAgICogUmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgdHJhbnNhY3Rpb24gcmVzdWx0XG4gICAqXG4gICAqIEBwYXJhbSBvcGVyYXRpb25zIC0gQWN0aW9uIG9wZXJhdGlvbihzKSB0byBleGVjdXRlXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gQWN0aW9uIG9wdGlvbnNcbiAgICovXG4gIGFjdGlvbihvcGVyYXRpb25zLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGxhc3RWYWx1ZUZyb20oX2FjdGlvbih0aGlzLCB0aGlzLiNodHRwUmVxdWVzdCwgb3BlcmF0aW9ucywgb3B0aW9ucykpO1xuICB9XG4gIC8qKlxuICAgKiBQZXJmb3JtIGEgcmVxdWVzdCBhZ2FpbnN0IHRoZSBTYW5pdHkgQVBJXG4gICAqIE5PVEU6IE9ubHkgdXNlIHRoaXMgZm9yIFNhbml0eSBBUEkgZW5kcG9pbnRzLCBub3QgZm9yIHlvdXIgb3duIEFQSXMhXG4gICAqXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gUmVxdWVzdCBvcHRpb25zXG4gICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSByZXNwb25zZSBib2R5XG4gICAqL1xuICByZXF1ZXN0KG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbGFzdFZhbHVlRnJvbShfcmVxdWVzdCh0aGlzLCB0aGlzLiNodHRwUmVxdWVzdCwgb3B0aW9ucykpO1xuICB9XG4gIC8qKlxuICAgKiBQZXJmb3JtIGFuIEhUVFAgcmVxdWVzdCBhIGAvZGF0YWAgc3ViLWVuZHBvaW50XG4gICAqIE5PVEU6IENvbnNpZGVyZWQgaW50ZXJuYWwsIHRodXMgbWFya2VkIGFzIGRlcHJlY2F0ZWQuIFVzZSBgcmVxdWVzdGAgaW5zdGVhZC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgLSBVc2UgYHJlcXVlc3QoKWAgb3IgeW91ciBvd24gSFRUUCBsaWJyYXJ5IGluc3RlYWRcbiAgICogQHBhcmFtIGVuZHBvaW50IC0gRW5kcG9pbnQgdG8gaGl0IChtdXRhdGUsIHF1ZXJ5IGV0YylcbiAgICogQHBhcmFtIGJvZHkgLSBSZXF1ZXN0IGJvZHlcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBSZXF1ZXN0IG9wdGlvbnNcbiAgICogQGludGVybmFsXG4gICAqL1xuICBkYXRhUmVxdWVzdChlbmRwb2ludCwgYm9keSwgb3B0aW9ucykge1xuICAgIHJldHVybiBsYXN0VmFsdWVGcm9tKF9kYXRhUmVxdWVzdCh0aGlzLCB0aGlzLiNodHRwUmVxdWVzdCwgZW5kcG9pbnQsIGJvZHksIG9wdGlvbnMpKTtcbiAgfVxuICAvKipcbiAgICogR2V0IGEgU2FuaXR5IEFQSSBVUkwgZm9yIHRoZSBVUkkgcHJvdmlkZWRcbiAgICpcbiAgICogQHBhcmFtIHVyaSAtIFVSSS9wYXRoIHRvIGJ1aWxkIFVSTCBmb3JcbiAgICogQHBhcmFtIGNhblVzZUNkbiAtIFdoZXRoZXIgb3Igbm90IHRvIGFsbG93IHVzaW5nIHRoZSBBUEkgQ0ROIGZvciB0aGlzIHJvdXRlXG4gICAqL1xuICBnZXRVcmwodXJpLCBjYW5Vc2VDZG4pIHtcbiAgICByZXR1cm4gX2dldFVybCh0aGlzLCB1cmksIGNhblVzZUNkbik7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBhIFNhbml0eSBBUEkgVVJMIGZvciB0aGUgZGF0YSBvcGVyYXRpb24gYW5kIHBhdGggcHJvdmlkZWRcbiAgICpcbiAgICogQHBhcmFtIG9wZXJhdGlvbiAtIERhdGEgb3BlcmF0aW9uIChlZyBgcXVlcnlgLCBgbXV0YXRlYCwgYGxpc3RlbmAgb3Igc2ltaWxhcilcbiAgICogQHBhcmFtIHBhdGggLSBQYXRoIHRvIGFwcGVuZCBhZnRlciB0aGUgb3BlcmF0aW9uXG4gICAqL1xuICBnZXREYXRhVXJsKG9wZXJhdGlvbiwgcGF0aCkge1xuICAgIHJldHVybiBfZ2V0RGF0YVVybCh0aGlzLCBvcGVyYXRpb24sIHBhdGgpO1xuICB9XG59XG5mdW5jdGlvbiBkZWZpbmVDcmVhdGVDbGllbnRFeHBvcnRzKGVudk1pZGRsZXdhcmUsIENsYXNzQ29uc3RydWN0b3IpIHtcbiAgcmV0dXJuIHsgcmVxdWVzdGVyOiBkZWZpbmVIdHRwUmVxdWVzdChlbnZNaWRkbGV3YXJlKSwgY3JlYXRlQ2xpZW50OiAoY29uZmlnKSA9PiB7XG4gICAgY29uc3QgY2xpZW50UmVxdWVzdGVyID0gZGVmaW5lSHR0cFJlcXVlc3QoZW52TWlkZGxld2FyZSk7XG4gICAgcmV0dXJuIG5ldyBDbGFzc0NvbnN0cnVjdG9yKFxuICAgICAgKG9wdGlvbnMsIHJlcXVlc3RlcjIpID0+IChyZXF1ZXN0ZXIyIHx8IGNsaWVudFJlcXVlc3Rlcikoe1xuICAgICAgICBtYXhSZWRpcmVjdHM6IDAsXG4gICAgICAgIG1heFJldHJpZXM6IGNvbmZpZy5tYXhSZXRyaWVzLFxuICAgICAgICByZXRyeURlbGF5OiBjb25maWcucmV0cnlEZWxheSxcbiAgICAgICAgLi4ub3B0aW9uc1xuICAgICAgfSksXG4gICAgICBjb25maWdcbiAgICApO1xuICB9IH07XG59XG5mdW5jdGlvbiBkZWZpbmVEZXByZWNhdGVkQ3JlYXRlQ2xpZW50KGNyZWF0ZUNsaWVudDIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGNvbmZpZykge1xuICAgIHJldHVybiBwcmludE5vRGVmYXVsdEV4cG9ydCgpLCBjcmVhdGVDbGllbnQyKGNvbmZpZyk7XG4gIH07XG59XG52YXIgbmFtZSA9IFwiQHNhbml0eS9jbGllbnRcIiwgdmVyc2lvbiA9IFwiNi4yNy4yXCI7XG5jb25zdCBtaWRkbGV3YXJlID0gW1xuICBkZWJ1Zyh7IHZlcmJvc2U6ICEwLCBuYW1lc3BhY2U6IFwic2FuaXR5OmNsaWVudFwiIH0pLFxuICBoZWFkZXJzKHsgXCJVc2VyLUFnZW50XCI6IGAke25hbWV9ICR7dmVyc2lvbn1gIH0pLFxuICAvLyBFbmFibGUga2VlcC1hbGl2ZSwgYW5kIGluIGFkZGl0aW9uIGxpbWl0IHRoZSBudW1iZXIgb2Ygc29ja2V0cyB0aGF0IGNhbiBiZSBvcGVuZWQuXG4gIC8vIFRoaXMgYXZvaWRzIG9wZW5pbmcgdG9vIG1hbnkgY29ubmVjdGlvbnMgdG8gdGhlIHNlcnZlciBpZiBzb21lb25lIHRyaWVzIHRvIGV4ZWN1dGVcbiAgLy8gYSBidW5jaCBvZiByZXF1ZXN0cyBpbiBwYXJhbGxlbC4gSXQncyByZWNvbW1lbmRlZCB0byBoYXZlIGEgY29uY3VycmVuY3kgbGltaXRcbiAgLy8gYXQgYSBcImhpZ2hlciBsaW1pdFwiIChpLmUuIHlvdSBzaG91bGRuJ3QgYWN0dWFsbHkgZXhlY3V0ZSBodW5kcmVkcyBvZiByZXF1ZXN0cyBpbiBwYXJhbGxlbCksXG4gIC8vIGFuZCB0aGlzIGlzIG1haW5seSB0byBtaW5pbWl6ZSB0aGUgaW1wYWN0IGZvciB0aGUgbmV0d29yayBhbmQgc2VydmVyLlxuICAvL1xuICAvLyBXZSdyZSBjdXJyZW50bHkgbWF0Y2hpbmcgdGhlIHNhbWUgZGVmYXVsdHMgYXMgYnJvd3NlcnM6XG4gIC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzI2MDAzNzU2L2lzLXRoZXJlLWEtbGltaXQtcHJhY3RpY2FsLW9yLW90aGVyd2lzZS10by10aGUtbnVtYmVyLW9mLXdlYi1zb2NrZXRzLWEtcGFnZS1vcFxuICBhZ2VudCh7XG4gICAga2VlcEFsaXZlOiAhMCxcbiAgICBtYXhTb2NrZXRzOiAzMCxcbiAgICBtYXhUb3RhbFNvY2tldHM6IDI1NlxuICB9KVxuXSwgZXhwID0gZGVmaW5lQ3JlYXRlQ2xpZW50RXhwb3J0cyhtaWRkbGV3YXJlLCBTYW5pdHlDbGllbnQpLCByZXF1ZXN0ZXIgPSBleHAucmVxdWVzdGVyLCBjcmVhdGVDbGllbnQgPSBleHAuY3JlYXRlQ2xpZW50LCBkZXByZWNhdGVkQ3JlYXRlQ2xpZW50ID0gZGVmaW5lRGVwcmVjYXRlZENyZWF0ZUNsaWVudChjcmVhdGVDbGllbnQpO1xuZXhwb3J0IHtcbiAgQmFzZVBhdGNoLFxuICBCYXNlVHJhbnNhY3Rpb24sXG4gIENoYW5uZWxFcnJvcixcbiAgQ2xpZW50RXJyb3IsXG4gIENvbm5lY3Rpb25GYWlsZWRFcnJvcixcbiAgQ29yc09yaWdpbkVycm9yLFxuICBEaXNjb25uZWN0RXJyb3IsXG4gIE1lc3NhZ2VFcnJvcixcbiAgTWVzc2FnZVBhcnNlRXJyb3IsXG4gIE9ic2VydmFibGVQYXRjaCxcbiAgT2JzZXJ2YWJsZVNhbml0eUNsaWVudCxcbiAgT2JzZXJ2YWJsZVRyYW5zYWN0aW9uLFxuICBQYXRjaCxcbiAgU2FuaXR5Q2xpZW50LFxuICBTZXJ2ZXJFcnJvcixcbiAgVHJhbnNhY3Rpb24sXG4gIGNvbm5lY3RFdmVudFNvdXJjZSxcbiAgY3JlYXRlQ2xpZW50LFxuICBkZXByZWNhdGVkQ3JlYXRlQ2xpZW50IGFzIGRlZmF1bHQsXG4gIHJlcXVlc3RlcixcbiAgYWRhcHRlciBhcyB1bnN0YWJsZV9fYWRhcHRlcixcbiAgZW52aXJvbm1lbnQgYXMgdW5zdGFibGVfX2Vudmlyb25tZW50LFxuICB2YWxpZGF0ZUFwaVBlcnNwZWN0aXZlXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sanity/client/dist/index.js\n");

/***/ })

};
;